{"version":3,"sources":["webpack:///./node_modules/@jupyterlab/codemirror/node_modules/codemirror/keymap/vim.js"],"names":["CodeMirror","defaultKeymap","keys","type","toKeys","context","action","motion","motionArgs","linewise","toJumplist","forward","wordEnd","bigWord","inclusive","explicitRepeat","toFirstChar","repeatOffset","isEdit","actionArgs","after","matchIndent","sameLine","operator","operatorArgs","indentRight","toLower","operatorMotionArgs","visualLine","shouldMoveCursor","insertAt","interlaceInsertRepeat","blockwise","replace","position","increase","backtrack","textObjectInner","searchArgs","querySrc","wholeWordOnly","defaultExCommandMap","name","shortName","possiblyAsync","excludeFromCommandHistory","Pos","Vim","detachVimMap","cm","next","this","keyMap","vim","rmClass","getWrapperElement","getOption","document","body","style","caretColor","marks","state","fatCursorMarks","i","length","clear","off","updateFatCursorMark","disableFatCursorMark","getInputField","attach","attachVimMap","setOption","onCursorActivity","getOnPasteFn","leaveVimMode","prev","addClass","on","enableFatCursorMark","signal","mode","maybeInitVimState","enterVimMode","ranges","listSelections","result","range","empty","anchor","ch","getLine","line","push","markText","className","widget","createElement","textContent","setBookmark","cmKey","key","vimKey","charAt","pieces","split","lastPiece","hasCharacter","piece","modifiers","specialKeys","isUpperCase","toLowerCase","join","cmKeyToVimKey","cmd","findKey","defineOption","val","Init","test","Enter","Backspace","Delete","Insert","onPasteFn","insertMode","setCursor","offsetCursor","getCursor","actions","enterInsertMode","numberRegex","wordCharTest","isWordChar","bigWordCharTest","makeKeyRange","start","size","String","fromCharCode","upperCaseAlphabet","lowerCaseAlphabet","numbers","validMarks","concat","validRegisters","isLine","firstLine","lastLine","isLowerCase","k","isWhiteSpaceString","isEndOfSentenceSymbol","indexOf","inArray","arr","options","defaultValue","aliases","callback","undefined","Error","value","cfg","option","scope","local","vimGlobalState","lastInsertModeKeyTimer","createInsertModeChanges","c","changes","expectCursorActivityForChange","MacroModeState","latestRegister","isPlaying","isRecording","replaySearchQueries","onRecordingDone","lastInsertModeChanges","inputState","InputState","lastEditInputState","lastEditActionCommand","lastHPos","lastHSPos","lastMotion","fakeCursor","insertModeRepeat","visualMode","visualBlock","lastSelection","lastPastedText","sel","resetVimGlobalState","pointer","head","tail","buffer","optionName","searchQuery","searchIsReversed","lastSubstituteReplacePart","jumpList","Array","cachedCursor","add","oldCur","newCur","curMark","useNextSlot","cursor","trashMark","markPos","find","cursorEqual","move","offset","mark","inc","macroModeState","lastCharacterSearch","increment","selectedCharacter","registerController","RegisterController","searchHistoryController","HistoryController","exCommandHistoryController","prototype","exitMacroRecordMode","enterMacroRecordMode","registerName","register","getRegister","openDialog","bottom","vimApi","buildKeyMap","getRegisterController","resetVimGlobalState_","getVimGlobalState_","maybeInitVimState_","suppressErrorLogging","InsertModeKey","map","lhs","rhs","ctx","exCommandDispatcher","unmap","defineEx","prefix","func","exCommands","commandMap_","handleKey","origin","command","handleMacroRecording","clearInputState","pushText","logKey","handleEsc","exitVisualMode","exitInsertMode","keyBuffer","keysAreChars","match","commandDispatcher","matchCommand","slice","thisMatch","window","clearTimeout","setTimeout","selections","here","replaceRange","pop","handleKeyInsertMode","keysMatcher","exec","pushRepeatDigit","handleKeyNonInsertMode","operation","curOp","isVimOp","substring","index","doKeyToKey","processCommand","e","console","handleEx","input","defineMotion","fn","motions","defineAction","defineOperator","operators","mapCommand","args","extra","_mapCommand","defineRegister","registers","prefixRepeat","motionRepeat","reason","Register","text","insertModeChanges","searchQueries","unnamedRegister","historyBuffer","iterator","initialPrefix","n","getRepeat","repeat","parseInt","setText","pushInsertModeChanges","pushSearchQuery","query","toString","isValidRegister","shiftNumericRegisters_","nextMatch","up","dir","element","j","pushInput","splice","reset","bestMatch","matches","partial","full","commandMatch","commandMatches","character","lastChar","repeatOverride","processMotion","processOperator","processOperatorMotion","processAction","processSearch","processEx","copyArgs","evalInput","repeatIsExplicit","recordLastEdit","getSearchCursor","getSearchState","setReversed","promptPrefix","originalQuery","getQuery","originalScrollPos","getScrollInfo","handleQuery","shift","showPrompt","onClose","scrollTo","left","top","logSearchQuery","desc","searchPromptDesc","onKeyUp","close","parsedQuery","keyName","target","selectionEnd","selectionStart","Math","min","updateSearchQuery","scrollIntoView","findNext","clearSearchHighlight","onKeyDown","e_stop","focus","word","expandWordUnderCursor","isKeyword","end","ignoreCase","smartCase","showConfirm","onPromptClose","onPromptKeyDown","exArgs","selectValueOnOpen","newHead","newAnchor","origHead","copyCursor","clipCursorToContent","origAnchor","oldHead","oldAnchor","noRepeat","motionResult","recordJumpPosition","Infinity","updateCmSelection","updateMark","cursorIsBefore","lastSel","lineOffset","abs","chOffset","curStart","curEnd","cmSel","cursorMin","cursorMax","makeCmSelection","lineLength","tmp","_cm","expandSelectionToLine","selection","getRange","lines","clipToLine","setSelections","primary","operatorMoveTo","actionCommand","moveToTopLine","_head","getUserVisibleLines","findFirstNonWhiteSpaceCharacter","moveToMiddleLine","floor","moveToBottomLine","expandToLine","isReversed","highlightSearchMatches","goToMark","pos","getMarkPos","moveToOtherHighlightedEnd","jumpToMark","best","equal","between","cursorIsBetween","moveByCharacters","cur","moveByLines","endCh","moveByDisplayLines","moveByScroll","moveToColumn","moveToEol","first","last","moveToStartOfLine","charCoords","res","findPosV","hitSide","goalCoords","coordsChar","resCoords","moveByPage","moveByParagraph","findParagraph","moveBySentence","nextChar","idx","ln","stop","curr","last_valid","skip_empty_lines","reverse","curr_index","findSentence","scrollbox","clientHeight","defaultTextHeight","orig","dest","moveByWords","words","emptyLineIsWord","findWord","eodCh","from","to","shortCircuit","firstWord","lastWord","moveToWord","moveTillCharacter","moveToCharacter","recordLastCharacterSearch","moveToSymbol","symb","endLine","lineCount","curCh","lineText","nextCh","lastCh","reverseSymb","depth","curMoveThrough","symbolToMode","init","findSymbolModes","isComplete","lineLen","findSymbol","retval","clipPos","moveToFirstNonWhiteSpaceCharacter","moveToMatchedSymbol","symbol","getTokenTypeAt","findMatchingBracket","moveToLineOrEdgeOfDocument","lineNum","textObjectManipulation","bracketRegexp","openSym","scanForBracket","selectCompanionObject","'","len","chars","firstIndex","findBeginningAndEnd","expandSelection","repeatLastCharacterSearch","lastSearch","moveH","fillArray","times","change","finalHead","inVisualBlock","getSelection","replacement","replaceSelections","lastState","prevLineEnd","Number","MAX_VALUE","wasLastLine","commands","newlineAndIndent","indent","startLine","indentLine","changeCase","getSelections","swapped","toSwap","toUpperCase","yank","endPos","jumpListWalk","scroll","lineHeight","delta","newPos","cursorCoords","ceil","newBottom","scrollToCursor","height","y","replayMacro","executeMacroRegister","toggleOverwrite","overwrite","max","onChange","onKeyEventTargetKeyDown","selectForInsert","toggleVisualMode","subMode","reselectLastSelection","_actionArgs","updateLastSelection","anchorMark","headMark","joinLines","finalCh","curFinalPos","newLineAndEnterInsertMode","newlineAndIndentContinueComment","paste","tabSize","whitespaceLength","str","tabs","spaces","currentLine","chompedText","wasChomped","firstIndent","wspace","newIndent","quotient","curPosFinal","lastSelectionCurEnd","selectedArea","getCurrentSelectedAreaRange","block","width","setSelection","getLastSelectedAreaRange","getSelectedAreaRange","selectedText","emptyStrings","selectBlock","posFromIndex","indexFromPos","extendLineToColumn","undo","repeatFn","redo","setRegister","setMark","replaceTo","replaceWith","replaceWithStr","incrementNumberToken","numberStr","lineStr","re","baseStr","digits","base","zeroPadding","substr","repeatLastEdit","includeLineBreak","maxCh","ret","prop","hasOwnProperty","offsetLine","offsetCh","pressed","mapped","prefixLen","pressedPrefix","mappedPrefix","cur1","cur2","arguments","apply","call","cur3","cur1before2","cur2before3","trim","s","column","isClipped","primIndex","atAnchor","atHead","getIndex","wasClipped","baseCh","headCh","newDir","lineHead","updateFakeCursor","exclusive","headOffset","anchorOffset","right","moveHead","firstNonWS","search","_forward","noSymbol","getHead","wordStart","bracket","section","comment","found","method","preprocess","token","charTests","foundWord","charIdxInLine","markName","includeChar","lastIndexOf","isEmpty","isBoundary","any","startState","SearchState","searchState_","dialog","template","shortText","prompt","splitBySeparator","argString","separator","slashes","findUnescapedSeparators","tokens","escapeNextChar","setQuery","getOverlay","searchOverlay","setOverlay","overlay","reversed","getScrollbarAnnotate","annotate","setScrollbarAnnotate","charUnescapes","unescapes","parseQuery","RegExp","regexPart","forceIgnoreCase","out","specialComesNext","translateRegex","openNotification","duration","alert","raw","rawQuery","r1","r2","props","regexEqual","searchState","removeOverlay","source","matchSol","stream","sol","backUp","eol","skipToEnd","addOverlay","showMatchesOnScrollbar","scrollInfo","bottomY","history","doc","done","event","lastModTime","changeHistory","filter","el","ExCommandDispatcher","buildCommandMap_","opt_params","that","_processCommand","commandHistoryRegister","previousCommand","inputStream","StringStream","commandName","params","parseInput_","matchCommand_","parseCommandArgs_","toInput","eatWhile","eat","lineEnd","parseLineSpec_","numberMatch","parseLineSpecOffset_","offsetMatch","delim","argDelimiter","user","mapping","unshift","colorscheme","mapArgs","imap","nmap","vmap","set","setArgs","setCfg","expr","forceGet","optionIsBoolean","oldValue","message","setOptionReturn","setlocal","setglobal","regArgs","regInfo","sort","unique","number","pattern","err","eatSpace","opts","decimal","hex","octal","parseArgs","lineStart","radix","numPart","textPart","matchPart","a","b","compareFn","textOld","anum","bnum","global","splitBySlash","matchedLines","content","nextCommand","substitute","trailing","flagsPart","count","replacePart","confirm","output","peek","matched","matcher","unescapeRegexReplace","translateRegexReplace","startPos","searchCursor","exMode","lastPos","replaceAll","newText","_value","savedCallback","doReplace","write","save","nohlsearch","delmarks","sym","startMark","finishMark","charCodeAt","finish","insertModeChangeRegister","lastChange","selLength","logInsertModeChange","imc","repeatInsertModeChanges","changeObj","maybeReset","somethingSelected","handleExternalSelection","lookupKey","repeatForInsert","isAction","cachedInputState","repeatCommand","repeatInsert","changeObject","keyHandler","binding","getOffset","detach","fallthrough","mod"],"mappings":"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","file":"edea2dd3-b986c529c162e29b8baa.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n/**\n * Supported keybindings:\n *   Too many to list. Refer to defaultKeyMap below.\n *\n * Supported Ex commands:\n *   Refer to defaultExCommandMap below.\n *\n * Registers: unnamed, -, a-z, A-Z, 0-9\n *   (Does not respect the special case for number registers when delete\n *    operator is made with these commands: %, (, ),  , /, ?, n, N, {, } )\n *   TODO: Implement the remaining registers.\n *\n * Marks: a-z, A-Z, and 0-9\n *   TODO: Implement the remaining special marks. They have more complex\n *       behavior.\n *\n * Events:\n *  'vim-mode-change' - raised on the editor anytime the current mode changes,\n *                      Event object: {mode: \"visual\", subMode: \"linewise\"}\n *\n * Code structure:\n *  1. Default keymap\n *  2. Variable declarations and short basic helpers\n *  3. Instance (External API) implementation\n *  4. Internal state tracking objects (input state, counter) implementation\n *     and instantiation\n *  5. Key handler (the main command dispatcher) implementation\n *  6. Motion, operator, and action implementations\n *  7. Helper functions for the key handler, motions, operators, and actions\n *  8. Set up Vim to work as a keymap for CodeMirror.\n *  9. Ex command implementations.\n */\n\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\")\n    // CommonJS\n    mod(require(\"../lib/codemirror\"), require(\"../addon/search/searchcursor\"), require(\"../addon/dialog/dialog\"), require(\"../addon/edit/matchbrackets.js\"));else if (typeof define == \"function\" && define.amd)\n    // AMD\n    define([\"../lib/codemirror\", \"../addon/search/searchcursor\", \"../addon/dialog/dialog\", \"../addon/edit/matchbrackets\"], mod);else\n    // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  'use strict';\n\n  var defaultKeymap = [\n  // Key to key mapping. This goes first to make it possible to override\n  // existing mappings.\n  {\n    keys: '<Left>',\n    type: 'keyToKey',\n    toKeys: 'h'\n  }, {\n    keys: '<Right>',\n    type: 'keyToKey',\n    toKeys: 'l'\n  }, {\n    keys: '<Up>',\n    type: 'keyToKey',\n    toKeys: 'k'\n  }, {\n    keys: '<Down>',\n    type: 'keyToKey',\n    toKeys: 'j'\n  }, {\n    keys: '<Space>',\n    type: 'keyToKey',\n    toKeys: 'l'\n  }, {\n    keys: '<BS>',\n    type: 'keyToKey',\n    toKeys: 'h',\n    context: 'normal'\n  }, {\n    keys: '<C-Space>',\n    type: 'keyToKey',\n    toKeys: 'W'\n  }, {\n    keys: '<C-BS>',\n    type: 'keyToKey',\n    toKeys: 'B',\n    context: 'normal'\n  }, {\n    keys: '<S-Space>',\n    type: 'keyToKey',\n    toKeys: 'w'\n  }, {\n    keys: '<S-BS>',\n    type: 'keyToKey',\n    toKeys: 'b',\n    context: 'normal'\n  }, {\n    keys: '<C-n>',\n    type: 'keyToKey',\n    toKeys: 'j'\n  }, {\n    keys: '<C-p>',\n    type: 'keyToKey',\n    toKeys: 'k'\n  }, {\n    keys: '<C-[>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, {\n    keys: '<C-c>',\n    type: 'keyToKey',\n    toKeys: '<Esc>'\n  }, {\n    keys: '<C-[>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: '<C-c>',\n    type: 'keyToKey',\n    toKeys: '<Esc>',\n    context: 'insert'\n  }, {\n    keys: 's',\n    type: 'keyToKey',\n    toKeys: 'cl',\n    context: 'normal'\n  }, {\n    keys: 's',\n    type: 'keyToKey',\n    toKeys: 'c',\n    context: 'visual'\n  }, {\n    keys: 'S',\n    type: 'keyToKey',\n    toKeys: 'cc',\n    context: 'normal'\n  }, {\n    keys: 'S',\n    type: 'keyToKey',\n    toKeys: 'VdO',\n    context: 'visual'\n  }, {\n    keys: '<Home>',\n    type: 'keyToKey',\n    toKeys: '0'\n  }, {\n    keys: '<End>',\n    type: 'keyToKey',\n    toKeys: '$'\n  }, {\n    keys: '<PageUp>',\n    type: 'keyToKey',\n    toKeys: '<C-b>'\n  }, {\n    keys: '<PageDown>',\n    type: 'keyToKey',\n    toKeys: '<C-f>'\n  }, {\n    keys: '<CR>',\n    type: 'keyToKey',\n    toKeys: 'j^',\n    context: 'normal'\n  }, {\n    keys: '<Ins>',\n    type: 'action',\n    action: 'toggleOverwrite',\n    context: 'insert'\n  },\n  // Motions\n  {\n    keys: 'H',\n    type: 'motion',\n    motion: 'moveToTopLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'M',\n    type: 'motion',\n    motion: 'moveToMiddleLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'L',\n    type: 'motion',\n    motion: 'moveToBottomLine',\n    motionArgs: {\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'h',\n    type: 'motion',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'l',\n    type: 'motion',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'j',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: 'k',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: 'gj',\n    type: 'motion',\n    motion: 'moveByDisplayLines',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: 'gk',\n    type: 'motion',\n    motion: 'moveByDisplayLines',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 'w',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: false\n    }\n  }, {\n    keys: 'W',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: false,\n      bigWord: true\n    }\n  }, {\n    keys: 'e',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'E',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: true,\n      wordEnd: true,\n      bigWord: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'b',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false\n    }\n  }, {\n    keys: 'B',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false,\n      bigWord: true\n    }\n  }, {\n    keys: 'ge',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'gE',\n    type: 'motion',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: true,\n      bigWord: true,\n      inclusive: true\n    }\n  }, {\n    keys: '{',\n    type: 'motion',\n    motion: 'moveByParagraph',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: '}',\n    type: 'motion',\n    motion: 'moveByParagraph',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '(',\n    type: 'motion',\n    motion: 'moveBySentence',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ')',\n    type: 'motion',\n    motion: 'moveBySentence',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-f>',\n    type: 'motion',\n    motion: 'moveByPage',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-b>',\n    type: 'motion',\n    motion: 'moveByPage',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '<C-d>',\n    type: 'motion',\n    motion: 'moveByScroll',\n    motionArgs: {\n      forward: true,\n      explicitRepeat: true\n    }\n  }, {\n    keys: '<C-u>',\n    type: 'motion',\n    motion: 'moveByScroll',\n    motionArgs: {\n      forward: false,\n      explicitRepeat: true\n    }\n  }, {\n    keys: 'gg',\n    type: 'motion',\n    motion: 'moveToLineOrEdgeOfDocument',\n    motionArgs: {\n      forward: false,\n      explicitRepeat: true,\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'G',\n    type: 'motion',\n    motion: 'moveToLineOrEdgeOfDocument',\n    motionArgs: {\n      forward: true,\n      explicitRepeat: true,\n      linewise: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '0',\n    type: 'motion',\n    motion: 'moveToStartOfLine'\n  }, {\n    keys: '^',\n    type: 'motion',\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: '+',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      toFirstChar: true\n    }\n  }, {\n    keys: '-',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: false,\n      toFirstChar: true\n    }\n  }, {\n    keys: '_',\n    type: 'motion',\n    motion: 'moveByLines',\n    motionArgs: {\n      forward: true,\n      toFirstChar: true,\n      repeatOffset: -1\n    }\n  }, {\n    keys: '$',\n    type: 'motion',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    }\n  }, {\n    keys: '%',\n    type: 'motion',\n    motion: 'moveToMatchedSymbol',\n    motionArgs: {\n      inclusive: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'f<character>',\n    type: 'motion',\n    motion: 'moveToCharacter',\n    motionArgs: {\n      forward: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'F<character>',\n    type: 'motion',\n    motion: 'moveToCharacter',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: 't<character>',\n    type: 'motion',\n    motion: 'moveTillCharacter',\n    motionArgs: {\n      forward: true,\n      inclusive: true\n    }\n  }, {\n    keys: 'T<character>',\n    type: 'motion',\n    motion: 'moveTillCharacter',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ';',\n    type: 'motion',\n    motion: 'repeatLastCharacterSearch',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: ',',\n    type: 'motion',\n    motion: 'repeatLastCharacterSearch',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '\\'<character>',\n    type: 'motion',\n    motion: 'goToMark',\n    motionArgs: {\n      toJumplist: true,\n      linewise: true\n    }\n  }, {\n    keys: '`<character>',\n    type: 'motion',\n    motion: 'goToMark',\n    motionArgs: {\n      toJumplist: true\n    }\n  }, {\n    keys: ']`',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '[`',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: false\n    }\n  }, {\n    keys: ']\\'',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: '[\\'',\n    type: 'motion',\n    motion: 'jumpToMark',\n    motionArgs: {\n      forward: false,\n      linewise: true\n    }\n  },\n  // the next two aren't motions but must come before more general motion declarations\n  {\n    keys: ']p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: true,\n      isEdit: true,\n      matchIndent: true\n    }\n  }, {\n    keys: '[p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: false,\n      isEdit: true,\n      matchIndent: true\n    }\n  }, {\n    keys: ']<character>',\n    type: 'motion',\n    motion: 'moveToSymbol',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '[<character>',\n    type: 'motion',\n    motion: 'moveToSymbol',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  }, {\n    keys: '|',\n    type: 'motion',\n    motion: 'moveToColumn'\n  }, {\n    keys: 'o',\n    type: 'motion',\n    motion: 'moveToOtherHighlightedEnd',\n    context: 'visual'\n  }, {\n    keys: 'O',\n    type: 'motion',\n    motion: 'moveToOtherHighlightedEnd',\n    motionArgs: {\n      sameLine: true\n    },\n    context: 'visual'\n  },\n  // Operators\n  {\n    keys: 'd',\n    type: 'operator',\n    operator: 'delete'\n  }, {\n    keys: 'y',\n    type: 'operator',\n    operator: 'yank'\n  }, {\n    keys: 'c',\n    type: 'operator',\n    operator: 'change'\n  }, {\n    keys: '>',\n    type: 'operator',\n    operator: 'indent',\n    operatorArgs: {\n      indentRight: true\n    }\n  }, {\n    keys: '<',\n    type: 'operator',\n    operator: 'indent',\n    operatorArgs: {\n      indentRight: false\n    }\n  }, {\n    keys: 'g~',\n    type: 'operator',\n    operator: 'changeCase'\n  }, {\n    keys: 'gu',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: true\n    },\n    isEdit: true\n  }, {\n    keys: 'gU',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: false\n    },\n    isEdit: true\n  }, {\n    keys: 'n',\n    type: 'motion',\n    motion: 'findNext',\n    motionArgs: {\n      forward: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'N',\n    type: 'motion',\n    motion: 'findNext',\n    motionArgs: {\n      forward: false,\n      toJumplist: true\n    }\n  },\n  // Operator-Motion dual commands\n  {\n    keys: 'x',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    },\n    operatorMotionArgs: {\n      visualLine: false\n    }\n  }, {\n    keys: 'X',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: false\n    },\n    operatorMotionArgs: {\n      visualLine: true\n    }\n  }, {\n    keys: 'D',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'D',\n    type: 'operator',\n    operator: 'delete',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'Y',\n    type: 'operatorMotion',\n    operator: 'yank',\n    motion: 'expandToLine',\n    motionArgs: {\n      linewise: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'Y',\n    type: 'operator',\n    operator: 'yank',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: 'C',\n    type: 'operatorMotion',\n    operator: 'change',\n    motion: 'moveToEol',\n    motionArgs: {\n      inclusive: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'C',\n    type: 'operator',\n    operator: 'change',\n    operatorArgs: {\n      linewise: true\n    },\n    context: 'visual'\n  }, {\n    keys: '~',\n    type: 'operatorMotion',\n    operator: 'changeCase',\n    motion: 'moveByCharacters',\n    motionArgs: {\n      forward: true\n    },\n    operatorArgs: {\n      shouldMoveCursor: true\n    },\n    context: 'normal'\n  }, {\n    keys: '~',\n    type: 'operator',\n    operator: 'changeCase',\n    context: 'visual'\n  }, {\n    keys: '<C-w>',\n    type: 'operatorMotion',\n    operator: 'delete',\n    motion: 'moveByWords',\n    motionArgs: {\n      forward: false,\n      wordEnd: false\n    },\n    context: 'insert'\n  },\n  // Actions\n  {\n    keys: '<C-i>',\n    type: 'action',\n    action: 'jumpListWalk',\n    actionArgs: {\n      forward: true\n    }\n  }, {\n    keys: '<C-o>',\n    type: 'action',\n    action: 'jumpListWalk',\n    actionArgs: {\n      forward: false\n    }\n  }, {\n    keys: '<C-e>',\n    type: 'action',\n    action: 'scroll',\n    actionArgs: {\n      forward: true,\n      linewise: true\n    }\n  }, {\n    keys: '<C-y>',\n    type: 'action',\n    action: 'scroll',\n    actionArgs: {\n      forward: false,\n      linewise: true\n    }\n  }, {\n    keys: 'a',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'charAfter'\n    },\n    context: 'normal'\n  }, {\n    keys: 'A',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'eol'\n    },\n    context: 'normal'\n  }, {\n    keys: 'A',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'endOfSelectedArea'\n    },\n    context: 'visual'\n  }, {\n    keys: 'i',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'inplace'\n    },\n    context: 'normal'\n  }, {\n    keys: 'I',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'firstNonBlank'\n    },\n    context: 'normal'\n  }, {\n    keys: 'I',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      insertAt: 'startOfSelectedArea'\n    },\n    context: 'visual'\n  }, {\n    keys: 'o',\n    type: 'action',\n    action: 'newLineAndEnterInsertMode',\n    isEdit: true,\n    interlaceInsertRepeat: true,\n    actionArgs: {\n      after: true\n    },\n    context: 'normal'\n  }, {\n    keys: 'O',\n    type: 'action',\n    action: 'newLineAndEnterInsertMode',\n    isEdit: true,\n    interlaceInsertRepeat: true,\n    actionArgs: {\n      after: false\n    },\n    context: 'normal'\n  }, {\n    keys: 'v',\n    type: 'action',\n    action: 'toggleVisualMode'\n  }, {\n    keys: 'V',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      linewise: true\n    }\n  }, {\n    keys: '<C-v>',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      blockwise: true\n    }\n  }, {\n    keys: '<C-q>',\n    type: 'action',\n    action: 'toggleVisualMode',\n    actionArgs: {\n      blockwise: true\n    }\n  }, {\n    keys: 'gv',\n    type: 'action',\n    action: 'reselectLastSelection'\n  }, {\n    keys: 'J',\n    type: 'action',\n    action: 'joinLines',\n    isEdit: true\n  }, {\n    keys: 'p',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: true,\n      isEdit: true\n    }\n  }, {\n    keys: 'P',\n    type: 'action',\n    action: 'paste',\n    isEdit: true,\n    actionArgs: {\n      after: false,\n      isEdit: true\n    }\n  }, {\n    keys: 'r<character>',\n    type: 'action',\n    action: 'replace',\n    isEdit: true\n  }, {\n    keys: '@<character>',\n    type: 'action',\n    action: 'replayMacro'\n  }, {\n    keys: 'q<character>',\n    type: 'action',\n    action: 'enterMacroRecordMode'\n  },\n  // Handle Replace-mode as a special case of insert mode.\n  {\n    keys: 'R',\n    type: 'action',\n    action: 'enterInsertMode',\n    isEdit: true,\n    actionArgs: {\n      replace: true\n    }\n  }, {\n    keys: 'u',\n    type: 'action',\n    action: 'undo',\n    context: 'normal'\n  }, {\n    keys: 'u',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: true\n    },\n    context: 'visual',\n    isEdit: true\n  }, {\n    keys: 'U',\n    type: 'operator',\n    operator: 'changeCase',\n    operatorArgs: {\n      toLower: false\n    },\n    context: 'visual',\n    isEdit: true\n  }, {\n    keys: '<C-r>',\n    type: 'action',\n    action: 'redo'\n  }, {\n    keys: 'm<character>',\n    type: 'action',\n    action: 'setMark'\n  }, {\n    keys: '\"<character>',\n    type: 'action',\n    action: 'setRegister'\n  }, {\n    keys: 'zz',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'center'\n    }\n  }, {\n    keys: 'z.',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'center'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: 'zt',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'top'\n    }\n  }, {\n    keys: 'z<CR>',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'top'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: 'z-',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'bottom'\n    }\n  }, {\n    keys: 'zb',\n    type: 'action',\n    action: 'scrollToCursor',\n    actionArgs: {\n      position: 'bottom'\n    },\n    motion: 'moveToFirstNonWhiteSpaceCharacter'\n  }, {\n    keys: '.',\n    type: 'action',\n    action: 'repeatLastEdit'\n  }, {\n    keys: '<C-a>',\n    type: 'action',\n    action: 'incrementNumberToken',\n    isEdit: true,\n    actionArgs: {\n      increase: true,\n      backtrack: false\n    }\n  }, {\n    keys: '<C-x>',\n    type: 'action',\n    action: 'incrementNumberToken',\n    isEdit: true,\n    actionArgs: {\n      increase: false,\n      backtrack: false\n    }\n  }, {\n    keys: '<C-t>',\n    type: 'action',\n    action: 'indent',\n    actionArgs: {\n      indentRight: true\n    },\n    context: 'insert'\n  }, {\n    keys: '<C-d>',\n    type: 'action',\n    action: 'indent',\n    actionArgs: {\n      indentRight: false\n    },\n    context: 'insert'\n  },\n  // Text object motions\n  {\n    keys: 'a<character>',\n    type: 'motion',\n    motion: 'textObjectManipulation'\n  }, {\n    keys: 'i<character>',\n    type: 'motion',\n    motion: 'textObjectManipulation',\n    motionArgs: {\n      textObjectInner: true\n    }\n  },\n  // Search\n  {\n    keys: '/',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'prompt',\n      toJumplist: true\n    }\n  }, {\n    keys: '?',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'prompt',\n      toJumplist: true\n    }\n  }, {\n    keys: '*',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'wordUnderCursor',\n      wholeWordOnly: true,\n      toJumplist: true\n    }\n  }, {\n    keys: '#',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'wordUnderCursor',\n      wholeWordOnly: true,\n      toJumplist: true\n    }\n  }, {\n    keys: 'g*',\n    type: 'search',\n    searchArgs: {\n      forward: true,\n      querySrc: 'wordUnderCursor',\n      toJumplist: true\n    }\n  }, {\n    keys: 'g#',\n    type: 'search',\n    searchArgs: {\n      forward: false,\n      querySrc: 'wordUnderCursor',\n      toJumplist: true\n    }\n  },\n  // Ex command\n  {\n    keys: ':',\n    type: 'ex'\n  }];\n\n  /**\n   * Ex commands\n   * Care must be taken when adding to the default Ex command map. For any\n   * pair of commands that have a shared prefix, at least one of their\n   * shortNames must not match the prefix of the other command.\n   */\n  var defaultExCommandMap = [{\n    name: 'colorscheme',\n    shortName: 'colo'\n  }, {\n    name: 'map'\n  }, {\n    name: 'imap',\n    shortName: 'im'\n  }, {\n    name: 'nmap',\n    shortName: 'nm'\n  }, {\n    name: 'vmap',\n    shortName: 'vm'\n  }, {\n    name: 'unmap'\n  }, {\n    name: 'write',\n    shortName: 'w'\n  }, {\n    name: 'undo',\n    shortName: 'u'\n  }, {\n    name: 'redo',\n    shortName: 'red'\n  }, {\n    name: 'set',\n    shortName: 'se'\n  }, {\n    name: 'set',\n    shortName: 'se'\n  }, {\n    name: 'setlocal',\n    shortName: 'setl'\n  }, {\n    name: 'setglobal',\n    shortName: 'setg'\n  }, {\n    name: 'sort',\n    shortName: 'sor'\n  }, {\n    name: 'substitute',\n    shortName: 's',\n    possiblyAsync: true\n  }, {\n    name: 'nohlsearch',\n    shortName: 'noh'\n  }, {\n    name: 'yank',\n    shortName: 'y'\n  }, {\n    name: 'delmarks',\n    shortName: 'delm'\n  }, {\n    name: 'registers',\n    shortName: 'reg',\n    excludeFromCommandHistory: true\n  }, {\n    name: 'global',\n    shortName: 'g'\n  }];\n  var Pos = CodeMirror.Pos;\n  var Vim = function () {\n    function enterVimMode(cm) {\n      cm.setOption('disableInput', true);\n      cm.setOption('showCursorWhenSelecting', false);\n      CodeMirror.signal(cm, \"vim-mode-change\", {\n        mode: \"normal\"\n      });\n      cm.on('cursorActivity', onCursorActivity);\n      maybeInitVimState(cm);\n      CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    }\n    function leaveVimMode(cm) {\n      cm.setOption('disableInput', false);\n      cm.off('cursorActivity', onCursorActivity);\n      CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n      cm.state.vim = null;\n    }\n    function detachVimMap(cm, next) {\n      if (this == CodeMirror.keyMap.vim) {\n        CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n        if (cm.getOption(\"inputStyle\") == \"contenteditable\" && document.body.style.caretColor != null) {\n          disableFatCursorMark(cm);\n          cm.getInputField().style.caretColor = \"\";\n        }\n      }\n      if (!next || next.attach != attachVimMap) leaveVimMode(cm);\n    }\n    function attachVimMap(cm, prev) {\n      if (this == CodeMirror.keyMap.vim) {\n        CodeMirror.addClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n        if (cm.getOption(\"inputStyle\") == \"contenteditable\" && document.body.style.caretColor != null) {\n          enableFatCursorMark(cm);\n          cm.getInputField().style.caretColor = \"transparent\";\n        }\n      }\n      if (!prev || prev.attach != attachVimMap) enterVimMode(cm);\n    }\n    function fatCursorMarks(cm) {\n      var ranges = cm.listSelections(),\n        result = [];\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (range.empty()) {\n          if (range.anchor.ch < cm.getLine(range.anchor.line).length) {\n            result.push(cm.markText(range.anchor, Pos(range.anchor.line, range.anchor.ch + 1), {\n              className: \"cm-fat-cursor-mark\"\n            }));\n          } else {\n            var widget = document.createElement(\"span\");\n            widget.textContent = \"\\u00a0\";\n            widget.className = \"cm-fat-cursor-mark\";\n            result.push(cm.setBookmark(range.anchor, {\n              widget: widget\n            }));\n          }\n        }\n      }\n      return result;\n    }\n    function updateFatCursorMark(cm) {\n      var marks = cm.state.fatCursorMarks;\n      if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();\n      cm.state.fatCursorMarks = fatCursorMarks(cm);\n    }\n    function enableFatCursorMark(cm) {\n      cm.state.fatCursorMarks = fatCursorMarks(cm);\n      cm.on(\"cursorActivity\", updateFatCursorMark);\n    }\n    function disableFatCursorMark(cm) {\n      var marks = cm.state.fatCursorMarks;\n      if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();\n      cm.state.fatCursorMarks = null;\n      cm.off(\"cursorActivity\", updateFatCursorMark);\n    }\n\n    // Deprecated, simply setting the keymap works again.\n    CodeMirror.defineOption('vimMode', false, function (cm, val, prev) {\n      if (val && cm.getOption(\"keyMap\") != \"vim\") cm.setOption(\"keyMap\", \"vim\");else if (!val && prev != CodeMirror.Init && /^vim/.test(cm.getOption(\"keyMap\"))) cm.setOption(\"keyMap\", \"default\");\n    });\n    function cmKey(key, cm) {\n      if (!cm) {\n        return undefined;\n      }\n      if (this[key]) {\n        return this[key];\n      }\n      var vimKey = cmKeyToVimKey(key);\n      if (!vimKey) {\n        return false;\n      }\n      var cmd = CodeMirror.Vim.findKey(cm, vimKey);\n      if (typeof cmd == 'function') {\n        CodeMirror.signal(cm, 'vim-keypress', vimKey);\n      }\n      return cmd;\n    }\n    var modifiers = {\n      'Shift': 'S',\n      'Ctrl': 'C',\n      'Alt': 'A',\n      'Cmd': 'D',\n      'Mod': 'A'\n    };\n    var specialKeys = {\n      Enter: 'CR',\n      Backspace: 'BS',\n      Delete: 'Del',\n      Insert: 'Ins'\n    };\n    function cmKeyToVimKey(key) {\n      if (key.charAt(0) == '\\'') {\n        // Keypress character binding of format \"'a'\"\n        return key.charAt(1);\n      }\n      var pieces = key.split(/-(?!$)/);\n      var lastPiece = pieces[pieces.length - 1];\n      if (pieces.length == 1 && pieces[0].length == 1) {\n        // No-modifier bindings use literal character bindings above. Skip.\n        return false;\n      } else if (pieces.length == 2 && pieces[0] == 'Shift' && lastPiece.length == 1) {\n        // Ignore Shift+char bindings as they should be handled by literal character.\n        return false;\n      }\n      var hasCharacter = false;\n      for (var i = 0; i < pieces.length; i++) {\n        var piece = pieces[i];\n        if (piece in modifiers) {\n          pieces[i] = modifiers[piece];\n        } else {\n          hasCharacter = true;\n        }\n        if (piece in specialKeys) {\n          pieces[i] = specialKeys[piece];\n        }\n      }\n      if (!hasCharacter) {\n        // Vim does not support modifier only keys.\n        return false;\n      }\n      // TODO: Current bindings expect the character to be lower case, but\n      // it looks like vim key notation uses upper case.\n      if (isUpperCase(lastPiece)) {\n        pieces[pieces.length - 1] = lastPiece.toLowerCase();\n      }\n      return '<' + pieces.join('-') + '>';\n    }\n    function getOnPasteFn(cm) {\n      var vim = cm.state.vim;\n      if (!vim.onPasteFn) {\n        vim.onPasteFn = function () {\n          if (!vim.insertMode) {\n            cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n            actions.enterInsertMode(cm, {}, vim);\n          }\n        };\n      }\n      return vim.onPasteFn;\n    }\n    var numberRegex = /[\\d]/;\n    var wordCharTest = [CodeMirror.isWordChar, function (ch) {\n        return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n      }],\n      bigWordCharTest = [function (ch) {\n        return /\\S/.test(ch);\n      }];\n    function makeKeyRange(start, size) {\n      var keys = [];\n      for (var i = start; i < start + size; i++) {\n        keys.push(String.fromCharCode(i));\n      }\n      return keys;\n    }\n    var upperCaseAlphabet = makeKeyRange(65, 26);\n    var lowerCaseAlphabet = makeKeyRange(97, 26);\n    var numbers = makeKeyRange(48, 10);\n    var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['<', '>']);\n    var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ['-', '\"', '.', ':', '/']);\n    function isLine(cm, line) {\n      return line >= cm.firstLine() && line <= cm.lastLine();\n    }\n    function isLowerCase(k) {\n      return /^[a-z]$/.test(k);\n    }\n    function isMatchableSymbol(k) {\n      return '()[]{}'.indexOf(k) != -1;\n    }\n    function isNumber(k) {\n      return numberRegex.test(k);\n    }\n    function isUpperCase(k) {\n      return /^[A-Z]$/.test(k);\n    }\n    function isWhiteSpaceString(k) {\n      return /^\\s*$/.test(k);\n    }\n    function isEndOfSentenceSymbol(k) {\n      return '.?!'.indexOf(k) != -1;\n    }\n    function inArray(val, arr) {\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == val) {\n          return true;\n        }\n      }\n      return false;\n    }\n    var options = {};\n    function defineOption(name, defaultValue, type, aliases, callback) {\n      if (defaultValue === undefined && !callback) {\n        throw Error('defaultValue is required unless callback is provided');\n      }\n      if (!type) {\n        type = 'string';\n      }\n      options[name] = {\n        type: type,\n        defaultValue: defaultValue,\n        callback: callback\n      };\n      if (aliases) {\n        for (var i = 0; i < aliases.length; i++) {\n          options[aliases[i]] = options[name];\n        }\n      }\n      if (defaultValue) {\n        setOption(name, defaultValue);\n      }\n    }\n    function setOption(name, value, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.type == 'boolean') {\n        if (value && value !== true) {\n          return new Error('Invalid argument: ' + name + '=' + value);\n        } else if (value !== false) {\n          // Boolean options are set to true if value is not defined.\n          value = true;\n        }\n      }\n      if (option.callback) {\n        if (scope !== 'local') {\n          option.callback(value, undefined);\n        }\n        if (scope !== 'global' && cm) {\n          option.callback(value, cm);\n        }\n      } else {\n        if (scope !== 'local') {\n          option.value = option.type == 'boolean' ? !!value : value;\n        }\n        if (scope !== 'global' && cm) {\n          cm.state.vim.options[name] = {\n            value: value\n          };\n        }\n      }\n    }\n    function getOption(name, cm, cfg) {\n      var option = options[name];\n      cfg = cfg || {};\n      var scope = cfg.scope;\n      if (!option) {\n        return new Error('Unknown option: ' + name);\n      }\n      if (option.callback) {\n        var local = cm && option.callback(undefined, cm);\n        if (scope !== 'global' && local !== undefined) {\n          return local;\n        }\n        if (scope !== 'local') {\n          return option.callback();\n        }\n        return;\n      } else {\n        var local = scope !== 'global' && cm && cm.state.vim.options[name];\n        return (local || scope !== 'local' && option || {}).value;\n      }\n    }\n    defineOption('filetype', undefined, 'string', ['ft'], function (name, cm) {\n      // Option is local. Do nothing for global.\n      if (cm === undefined) {\n        return;\n      }\n      // The 'filetype' option proxies to the CodeMirror 'mode' option.\n      if (name === undefined) {\n        var mode = cm.getOption('mode');\n        return mode == 'null' ? '' : mode;\n      } else {\n        var mode = name == '' ? 'null' : name;\n        cm.setOption('mode', mode);\n      }\n    });\n    var createCircularJumpList = function () {\n      var size = 100;\n      var pointer = -1;\n      var head = 0;\n      var tail = 0;\n      var buffer = new Array(size);\n      function add(cm, oldCur, newCur) {\n        var current = pointer % size;\n        var curMark = buffer[current];\n        function useNextSlot(cursor) {\n          var next = ++pointer % size;\n          var trashMark = buffer[next];\n          if (trashMark) {\n            trashMark.clear();\n          }\n          buffer[next] = cm.setBookmark(cursor);\n        }\n        if (curMark) {\n          var markPos = curMark.find();\n          // avoid recording redundant cursor position\n          if (markPos && !cursorEqual(markPos, oldCur)) {\n            useNextSlot(oldCur);\n          }\n        } else {\n          useNextSlot(oldCur);\n        }\n        useNextSlot(newCur);\n        head = pointer;\n        tail = pointer - size + 1;\n        if (tail < 0) {\n          tail = 0;\n        }\n      }\n      function move(cm, offset) {\n        pointer += offset;\n        if (pointer > head) {\n          pointer = head;\n        } else if (pointer < tail) {\n          pointer = tail;\n        }\n        var mark = buffer[(size + pointer) % size];\n        // skip marks that are temporarily removed from text buffer\n        if (mark && !mark.find()) {\n          var inc = offset > 0 ? 1 : -1;\n          var newCur;\n          var oldCur = cm.getCursor();\n          do {\n            pointer += inc;\n            mark = buffer[(size + pointer) % size];\n            // skip marks that are the same as current position\n            if (mark && (newCur = mark.find()) && !cursorEqual(oldCur, newCur)) {\n              break;\n            }\n          } while (pointer < head && pointer > tail);\n        }\n        return mark;\n      }\n      return {\n        cachedCursor: undefined,\n        //used for # and * jumps\n        add: add,\n        move: move\n      };\n    };\n\n    // Returns an object to track the changes associated insert mode.  It\n    // clones the object that is passed in, or creates an empty object one if\n    // none is provided.\n    var createInsertModeChanges = function (c) {\n      if (c) {\n        // Copy construction\n        return {\n          changes: c.changes,\n          expectCursorActivityForChange: c.expectCursorActivityForChange\n        };\n      }\n      return {\n        // Change list\n        changes: [],\n        // Set to true on change, false on cursorActivity.\n        expectCursorActivityForChange: false\n      };\n    };\n    function MacroModeState() {\n      this.latestRegister = undefined;\n      this.isPlaying = false;\n      this.isRecording = false;\n      this.replaySearchQueries = [];\n      this.onRecordingDone = undefined;\n      this.lastInsertModeChanges = createInsertModeChanges();\n    }\n    MacroModeState.prototype = {\n      exitMacroRecordMode: function () {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.onRecordingDone) {\n          macroModeState.onRecordingDone(); // close dialog\n        }\n        macroModeState.onRecordingDone = undefined;\n        macroModeState.isRecording = false;\n      },\n      enterMacroRecordMode: function (cm, registerName) {\n        var register = vimGlobalState.registerController.getRegister(registerName);\n        if (register) {\n          register.clear();\n          this.latestRegister = registerName;\n          if (cm.openDialog) {\n            this.onRecordingDone = cm.openDialog('(recording)[' + registerName + ']', null, {\n              bottom: true\n            });\n          }\n          this.isRecording = true;\n        }\n      }\n    };\n    function maybeInitVimState(cm) {\n      if (!cm.state.vim) {\n        // Store instance state in the CodeMirror object.\n        cm.state.vim = {\n          inputState: new InputState(),\n          // Vim's input state that triggered the last edit, used to repeat\n          // motions and operators with '.'.\n          lastEditInputState: undefined,\n          // Vim's action command before the last edit, used to repeat actions\n          // with '.' and insert mode repeat.\n          lastEditActionCommand: undefined,\n          // When using jk for navigation, if you move from a longer line to a\n          // shorter line, the cursor may clip to the end of the shorter line.\n          // If j is pressed again and cursor goes to the next line, the\n          // cursor should go back to its horizontal position on the longer\n          // line if it can. This is to keep track of the horizontal position.\n          lastHPos: -1,\n          // Doing the same with screen-position for gj/gk\n          lastHSPos: -1,\n          // The last motion command run. Cleared if a non-motion command gets\n          // executed in between.\n          lastMotion: null,\n          marks: {},\n          // Mark for rendering fake cursor for visual mode.\n          fakeCursor: null,\n          insertMode: false,\n          // Repeat count for changes made in insert mode, triggered by key\n          // sequences like 3,i. Only exists when insertMode is true.\n          insertModeRepeat: undefined,\n          visualMode: false,\n          // If we are in visual line mode. No effect if visualMode is false.\n          visualLine: false,\n          visualBlock: false,\n          lastSelection: null,\n          lastPastedText: null,\n          sel: {},\n          // Buffer-local/window-local values of vim options.\n          options: {}\n        };\n      }\n      return cm.state.vim;\n    }\n    var vimGlobalState;\n    function resetVimGlobalState() {\n      vimGlobalState = {\n        // The current search query.\n        searchQuery: null,\n        // Whether we are searching backwards.\n        searchIsReversed: false,\n        // Replace part of the last substituted pattern\n        lastSubstituteReplacePart: undefined,\n        jumpList: createCircularJumpList(),\n        macroModeState: new MacroModeState(),\n        // Recording latest f, t, F or T motion command.\n        lastCharacterSearch: {\n          increment: 0,\n          forward: true,\n          selectedCharacter: ''\n        },\n        registerController: new RegisterController({}),\n        // search history buffer\n        searchHistoryController: new HistoryController(),\n        // ex Command history buffer\n        exCommandHistoryController: new HistoryController()\n      };\n      for (var optionName in options) {\n        var option = options[optionName];\n        option.value = option.defaultValue;\n      }\n    }\n    var lastInsertModeKeyTimer;\n    var vimApi = {\n      buildKeyMap: function () {\n        // TODO: Convert keymap into dictionary format for fast lookup.\n      },\n      // Testing hook, though it might be useful to expose the register\n      // controller anyways.\n      getRegisterController: function () {\n        return vimGlobalState.registerController;\n      },\n      // Testing hook.\n      resetVimGlobalState_: resetVimGlobalState,\n      // Testing hook.\n      getVimGlobalState_: function () {\n        return vimGlobalState;\n      },\n      // Testing hook.\n      maybeInitVimState_: maybeInitVimState,\n      suppressErrorLogging: false,\n      InsertModeKey: InsertModeKey,\n      map: function (lhs, rhs, ctx) {\n        // Add user defined key bindings.\n        exCommandDispatcher.map(lhs, rhs, ctx);\n      },\n      unmap: function (lhs, ctx) {\n        exCommandDispatcher.unmap(lhs, ctx);\n      },\n      // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n      // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n      setOption: setOption,\n      getOption: getOption,\n      defineOption: defineOption,\n      defineEx: function (name, prefix, func) {\n        if (!prefix) {\n          prefix = name;\n        } else if (name.indexOf(prefix) !== 0) {\n          throw new Error('(Vim.defineEx) \"' + prefix + '\" is not a prefix of \"' + name + '\", command not registered');\n        }\n        exCommands[name] = func;\n        exCommandDispatcher.commandMap_[prefix] = {\n          name: name,\n          shortName: prefix,\n          type: 'api'\n        };\n      },\n      handleKey: function (cm, key, origin) {\n        var command = this.findKey(cm, key, origin);\n        if (typeof command === 'function') {\n          return command();\n        }\n      },\n      /**\n       * This is the outermost function called by CodeMirror, after keys have\n       * been mapped to their Vim equivalents.\n       *\n       * Finds a command based on the key (and cached keys if there is a\n       * multi-key sequence). Returns `undefined` if no key is matched, a noop\n       * function if a partial match is found (multi-key), and a function to\n       * execute the bound command if a a key is matched. The function always\n       * returns true.\n       */\n      findKey: function (cm, key, origin) {\n        var vim = maybeInitVimState(cm);\n        function handleMacroRecording() {\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            if (key == 'q') {\n              macroModeState.exitMacroRecordMode();\n              clearInputState(cm);\n              return true;\n            }\n            if (origin != 'mapping') {\n              logKey(macroModeState, key);\n            }\n          }\n        }\n        function handleEsc() {\n          if (key == '<Esc>') {\n            // Clear input state and get back to normal mode.\n            clearInputState(cm);\n            if (vim.visualMode) {\n              exitVisualMode(cm);\n            } else if (vim.insertMode) {\n              exitInsertMode(cm);\n            }\n            return true;\n          }\n        }\n        function doKeyToKey(keys) {\n          // TODO: prevent infinite recursion.\n          var match;\n          while (keys) {\n            // Pull off one command key, which is either a single character\n            // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n            match = /<\\w+-.+?>|<\\w+>|./.exec(keys);\n            key = match[0];\n            keys = keys.substring(match.index + key.length);\n            CodeMirror.Vim.handleKey(cm, key, 'mapping');\n          }\n        }\n        function handleKeyInsertMode() {\n          if (handleEsc()) {\n            return true;\n          }\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          var keysAreChars = key.length == 1;\n          var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n          // Need to check all key substrings in insert mode.\n          while (keys.length > 1 && match.type != 'full') {\n            var keys = vim.inputState.keyBuffer = keys.slice(1);\n            var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, 'insert');\n            if (thisMatch.type != 'none') {\n              match = thisMatch;\n            }\n          }\n          if (match.type == 'none') {\n            clearInputState(cm);\n            return false;\n          } else if (match.type == 'partial') {\n            if (lastInsertModeKeyTimer) {\n              window.clearTimeout(lastInsertModeKeyTimer);\n            }\n            lastInsertModeKeyTimer = window.setTimeout(function () {\n              if (vim.insertMode && vim.inputState.keyBuffer) {\n                clearInputState(cm);\n              }\n            }, getOption('insertModeEscKeysTimeout'));\n            return !keysAreChars;\n          }\n          if (lastInsertModeKeyTimer) {\n            window.clearTimeout(lastInsertModeKeyTimer);\n          }\n          if (keysAreChars) {\n            var selections = cm.listSelections();\n            for (var i = 0; i < selections.length; i++) {\n              var here = selections[i].head;\n              cm.replaceRange('', offsetCursor(here, 0, -(keys.length - 1)), here, '+input');\n            }\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n          }\n          clearInputState(cm);\n          return match.command;\n        }\n        function handleKeyNonInsertMode() {\n          if (handleMacroRecording() || handleEsc()) {\n            return true;\n          }\n          var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;\n          if (/^[1-9]\\d*$/.test(keys)) {\n            return true;\n          }\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (!keysMatcher) {\n            clearInputState(cm);\n            return false;\n          }\n          var context = vim.visualMode ? 'visual' : 'normal';\n          var match = commandDispatcher.matchCommand(keysMatcher[2] || keysMatcher[1], defaultKeymap, vim.inputState, context);\n          if (match.type == 'none') {\n            clearInputState(cm);\n            return false;\n          } else if (match.type == 'partial') {\n            return true;\n          }\n          vim.inputState.keyBuffer = '';\n          var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n          if (keysMatcher[1] && keysMatcher[1] != '0') {\n            vim.inputState.pushRepeatDigit(keysMatcher[1]);\n          }\n          return match.command;\n        }\n        var command;\n        if (vim.insertMode) {\n          command = handleKeyInsertMode();\n        } else {\n          command = handleKeyNonInsertMode();\n        }\n        if (command === false) {\n          return !vim.insertMode && key.length === 1 ? function () {\n            return true;\n          } : undefined;\n        } else if (command === true) {\n          // TODO: Look into using CodeMirror's multi-key handling.\n          // Return no-op since we are caching the key. Counts as handled, but\n          // don't want act on it just yet.\n          return function () {\n            return true;\n          };\n        } else {\n          return function () {\n            return cm.operation(function () {\n              cm.curOp.isVimOp = true;\n              try {\n                if (command.type == 'keyToKey') {\n                  doKeyToKey(command.toKeys);\n                } else {\n                  commandDispatcher.processCommand(cm, vim, command);\n                }\n              } catch (e) {\n                // clear VIM state in case it's in a bad state.\n                cm.state.vim = undefined;\n                maybeInitVimState(cm);\n                if (!CodeMirror.Vim.suppressErrorLogging) {\n                  console['log'](e);\n                }\n                throw e;\n              }\n              return true;\n            });\n          };\n        }\n      },\n      handleEx: function (cm, input) {\n        exCommandDispatcher.processCommand(cm, input);\n      },\n      defineMotion: defineMotion,\n      defineAction: defineAction,\n      defineOperator: defineOperator,\n      mapCommand: mapCommand,\n      _mapCommand: _mapCommand,\n      defineRegister: defineRegister,\n      exitVisualMode: exitVisualMode,\n      exitInsertMode: exitInsertMode\n    };\n\n    // Represents the current input state.\n    function InputState() {\n      this.prefixRepeat = [];\n      this.motionRepeat = [];\n      this.operator = null;\n      this.operatorArgs = null;\n      this.motion = null;\n      this.motionArgs = null;\n      this.keyBuffer = []; // For matching multi-key commands.\n      this.registerName = null; // Defaults to the unnamed register.\n    }\n    InputState.prototype.pushRepeatDigit = function (n) {\n      if (!this.operator) {\n        this.prefixRepeat = this.prefixRepeat.concat(n);\n      } else {\n        this.motionRepeat = this.motionRepeat.concat(n);\n      }\n    };\n    InputState.prototype.getRepeat = function () {\n      var repeat = 0;\n      if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n        repeat = 1;\n        if (this.prefixRepeat.length > 0) {\n          repeat *= parseInt(this.prefixRepeat.join(''), 10);\n        }\n        if (this.motionRepeat.length > 0) {\n          repeat *= parseInt(this.motionRepeat.join(''), 10);\n        }\n      }\n      return repeat;\n    };\n    function clearInputState(cm, reason) {\n      cm.state.vim.inputState = new InputState();\n      CodeMirror.signal(cm, 'vim-command-done', reason);\n    }\n\n    /*\n     * Register stores information about copy and paste registers.  Besides\n     * text, a register must store whether it is linewise (i.e., when it is\n     * pasted, should it insert itself into a new line, or should the text be\n     * inserted at the cursor position.)\n     */\n    function Register(text, linewise, blockwise) {\n      this.clear();\n      this.keyBuffer = [text || ''];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    }\n    Register.prototype = {\n      setText: function (text, linewise, blockwise) {\n        this.keyBuffer = [text || ''];\n        this.linewise = !!linewise;\n        this.blockwise = !!blockwise;\n      },\n      pushText: function (text, linewise) {\n        // if this register has ever been set to linewise, use linewise.\n        if (linewise) {\n          if (!this.linewise) {\n            this.keyBuffer.push('\\n');\n          }\n          this.linewise = true;\n        }\n        this.keyBuffer.push(text);\n      },\n      pushInsertModeChanges: function (changes) {\n        this.insertModeChanges.push(createInsertModeChanges(changes));\n      },\n      pushSearchQuery: function (query) {\n        this.searchQueries.push(query);\n      },\n      clear: function () {\n        this.keyBuffer = [];\n        this.insertModeChanges = [];\n        this.searchQueries = [];\n        this.linewise = false;\n      },\n      toString: function () {\n        return this.keyBuffer.join('');\n      }\n    };\n\n    /**\n     * Defines an external register.\n     *\n     * The name should be a single character that will be used to reference the register.\n     * The register should support setText, pushText, clear, and toString(). See Register\n     * for a reference implementation.\n     */\n    function defineRegister(name, register) {\n      var registers = vimGlobalState.registerController.registers;\n      if (!name || name.length != 1) {\n        throw Error('Register name must be 1 character');\n      }\n      if (registers[name]) {\n        throw Error('Register already defined ' + name);\n      }\n      registers[name] = register;\n      validRegisters.push(name);\n    }\n\n    /*\n     * vim registers allow you to keep many independent copy and paste buffers.\n     * See http://usevim.com/2012/04/13/registers/ for an introduction.\n     *\n     * RegisterController keeps the state of all the registers.  An initial\n     * state may be passed in.  The unnamed register '\"' will always be\n     * overridden.\n     */\n    function RegisterController(registers) {\n      this.registers = registers;\n      this.unnamedRegister = registers['\"'] = new Register();\n      registers['.'] = new Register();\n      registers[':'] = new Register();\n      registers['/'] = new Register();\n    }\n    RegisterController.prototype = {\n      pushText: function (registerName, operator, text, linewise, blockwise) {\n        if (linewise && text.charAt(text.length - 1) !== '\\n') {\n          text += '\\n';\n        }\n        // Lowercase and uppercase registers refer to the same register.\n        // Uppercase just means append.\n        var register = this.isValidRegister(registerName) ? this.getRegister(registerName) : null;\n        // if no register/an invalid register was specified, things go to the\n        // default registers\n        if (!register) {\n          switch (operator) {\n            case 'yank':\n              // The 0 register contains the text from the most recent yank.\n              this.registers['0'] = new Register(text, linewise, blockwise);\n              break;\n            case 'delete':\n            case 'change':\n              if (text.indexOf('\\n') == -1) {\n                // Delete less than 1 line. Update the small delete register.\n                this.registers['-'] = new Register(text, linewise);\n              } else {\n                // Shift down the contents of the numbered registers and put the\n                // deleted text into register 1.\n                this.shiftNumericRegisters_();\n                this.registers['1'] = new Register(text, linewise);\n              }\n              break;\n          }\n          // Make sure the unnamed register is set to what just happened\n          this.unnamedRegister.setText(text, linewise, blockwise);\n          return;\n        }\n\n        // If we've gotten to this point, we've actually specified a register\n        var append = isUpperCase(registerName);\n        if (append) {\n          register.pushText(text, linewise);\n        } else {\n          register.setText(text, linewise, blockwise);\n        }\n        // The unnamed register always has the same value as the last used\n        // register.\n        this.unnamedRegister.setText(register.toString(), linewise);\n      },\n      // Gets the register named @name.  If one of @name doesn't already exist,\n      // create it.  If @name is invalid, return the unnamedRegister.\n      getRegister: function (name) {\n        if (!this.isValidRegister(name)) {\n          return this.unnamedRegister;\n        }\n        name = name.toLowerCase();\n        if (!this.registers[name]) {\n          this.registers[name] = new Register();\n        }\n        return this.registers[name];\n      },\n      isValidRegister: function (name) {\n        return name && inArray(name, validRegisters);\n      },\n      shiftNumericRegisters_: function () {\n        for (var i = 9; i >= 2; i--) {\n          this.registers[i] = this.getRegister('' + (i - 1));\n        }\n      }\n    };\n    function HistoryController() {\n      this.historyBuffer = [];\n      this.iterator = 0;\n      this.initialPrefix = null;\n    }\n    HistoryController.prototype = {\n      // the input argument here acts a user entered prefix for a small time\n      // until we start autocompletion in which case it is the autocompleted.\n      nextMatch: function (input, up) {\n        var historyBuffer = this.historyBuffer;\n        var dir = up ? -1 : 1;\n        if (this.initialPrefix === null) this.initialPrefix = input;\n        for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i += dir) {\n          var element = historyBuffer[i];\n          for (var j = 0; j <= element.length; j++) {\n            if (this.initialPrefix == element.substring(0, j)) {\n              this.iterator = i;\n              return element;\n            }\n          }\n        }\n        // should return the user input in case we reach the end of buffer.\n        if (i >= historyBuffer.length) {\n          this.iterator = historyBuffer.length;\n          return this.initialPrefix;\n        }\n        // return the last autocompleted query or exCommand as it is.\n        if (i < 0) return input;\n      },\n      pushInput: function (input) {\n        var index = this.historyBuffer.indexOf(input);\n        if (index > -1) this.historyBuffer.splice(index, 1);\n        if (input.length) this.historyBuffer.push(input);\n      },\n      reset: function () {\n        this.initialPrefix = null;\n        this.iterator = this.historyBuffer.length;\n      }\n    };\n    var commandDispatcher = {\n      matchCommand: function (keys, keyMap, inputState, context) {\n        var matches = commandMatches(keys, keyMap, context, inputState);\n        if (!matches.full && !matches.partial) {\n          return {\n            type: 'none'\n          };\n        } else if (!matches.full && matches.partial) {\n          return {\n            type: 'partial'\n          };\n        }\n        var bestMatch;\n        for (var i = 0; i < matches.full.length; i++) {\n          var match = matches.full[i];\n          if (!bestMatch) {\n            bestMatch = match;\n          }\n        }\n        if (bestMatch.keys.slice(-11) == '<character>') {\n          var character = lastChar(keys);\n          if (!character) return {\n            type: 'none'\n          };\n          inputState.selectedCharacter = character;\n        }\n        return {\n          type: 'full',\n          command: bestMatch\n        };\n      },\n      processCommand: function (cm, vim, command) {\n        vim.inputState.repeatOverride = command.repeatOverride;\n        switch (command.type) {\n          case 'motion':\n            this.processMotion(cm, vim, command);\n            break;\n          case 'operator':\n            this.processOperator(cm, vim, command);\n            break;\n          case 'operatorMotion':\n            this.processOperatorMotion(cm, vim, command);\n            break;\n          case 'action':\n            this.processAction(cm, vim, command);\n            break;\n          case 'search':\n            this.processSearch(cm, vim, command);\n            break;\n          case 'ex':\n          case 'keyToEx':\n            this.processEx(cm, vim, command);\n            break;\n          default:\n            break;\n        }\n      },\n      processMotion: function (cm, vim, command) {\n        vim.inputState.motion = command.motion;\n        vim.inputState.motionArgs = copyArgs(command.motionArgs);\n        this.evalInput(cm, vim);\n      },\n      processOperator: function (cm, vim, command) {\n        var inputState = vim.inputState;\n        if (inputState.operator) {\n          if (inputState.operator == command.operator) {\n            // Typing an operator twice like 'dd' makes the operator operate\n            // linewise\n            inputState.motion = 'expandToLine';\n            inputState.motionArgs = {\n              linewise: true\n            };\n            this.evalInput(cm, vim);\n            return;\n          } else {\n            // 2 different operators in a row doesn't make sense.\n            clearInputState(cm);\n          }\n        }\n        inputState.operator = command.operator;\n        inputState.operatorArgs = copyArgs(command.operatorArgs);\n        if (vim.visualMode) {\n          // Operating on a selection in visual mode. We don't need a motion.\n          this.evalInput(cm, vim);\n        }\n      },\n      processOperatorMotion: function (cm, vim, command) {\n        var visualMode = vim.visualMode;\n        var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n        if (operatorMotionArgs) {\n          // Operator motions may have special behavior in visual mode.\n          if (visualMode && operatorMotionArgs.visualLine) {\n            vim.visualLine = true;\n          }\n        }\n        this.processOperator(cm, vim, command);\n        if (!visualMode) {\n          this.processMotion(cm, vim, command);\n        }\n      },\n      processAction: function (cm, vim, command) {\n        var inputState = vim.inputState;\n        var repeat = inputState.getRepeat();\n        var repeatIsExplicit = !!repeat;\n        var actionArgs = copyArgs(command.actionArgs) || {};\n        if (inputState.selectedCharacter) {\n          actionArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        // Actions may or may not have motions and operators. Do these first.\n        if (command.operator) {\n          this.processOperator(cm, vim, command);\n        }\n        if (command.motion) {\n          this.processMotion(cm, vim, command);\n        }\n        if (command.motion || command.operator) {\n          this.evalInput(cm, vim);\n        }\n        actionArgs.repeat = repeat || 1;\n        actionArgs.repeatIsExplicit = repeatIsExplicit;\n        actionArgs.registerName = inputState.registerName;\n        clearInputState(cm);\n        vim.lastMotion = null;\n        if (command.isEdit) {\n          this.recordLastEdit(vim, inputState, command);\n        }\n        actions[command.action](cm, actionArgs, vim);\n      },\n      processSearch: function (cm, vim, command) {\n        if (!cm.getSearchCursor) {\n          // Search depends on SearchCursor.\n          return;\n        }\n        var forward = command.searchArgs.forward;\n        var wholeWordOnly = command.searchArgs.wholeWordOnly;\n        getSearchState(cm).setReversed(!forward);\n        var promptPrefix = forward ? '/' : '?';\n        var originalQuery = getSearchState(cm).getQuery();\n        var originalScrollPos = cm.getScrollInfo();\n        function handleQuery(query, ignoreCase, smartCase) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          try {\n            updateSearchQuery(cm, query, ignoreCase, smartCase);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + query);\n            clearInputState(cm);\n            return;\n          }\n          commandDispatcher.processMotion(cm, vim, {\n            type: 'motion',\n            motion: 'findNext',\n            motionArgs: {\n              forward: true,\n              toJumplist: command.searchArgs.toJumplist\n            }\n          });\n        }\n        function onPromptClose(query) {\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isRecording) {\n            logSearchQuery(macroModeState, query);\n          }\n        }\n        function onPromptKeyUp(e, query, close) {\n          var keyName = CodeMirror.keyName(e),\n            up,\n            offset;\n          if (keyName == 'Up' || keyName == 'Down') {\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            query = vimGlobalState.searchHistoryController.nextMatch(query, up) || '';\n            close(query);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else {\n            if (keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift') vimGlobalState.searchHistoryController.reset();\n          }\n          var parsedQuery;\n          try {\n            parsedQuery = updateSearchQuery(cm, query, true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n            // Swallow bad regexes for incremental search.\n          }\n          if (parsedQuery) {\n            cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n          } else {\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          }\n        }\n        function onPromptKeyDown(e, query, close) {\n          var keyName = CodeMirror.keyName(e);\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' || keyName == 'Backspace' && query == '') {\n            vimGlobalState.searchHistoryController.pushInput(query);\n            vimGlobalState.searchHistoryController.reset();\n            updateSearchQuery(cm, originalQuery);\n            clearSearchHighlight(cm);\n            cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          } else if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          }\n        }\n        switch (command.searchArgs.querySrc) {\n          case 'prompt':\n            var macroModeState = vimGlobalState.macroModeState;\n            if (macroModeState.isPlaying) {\n              var query = macroModeState.replaySearchQueries.shift();\n              handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            } else {\n              showPrompt(cm, {\n                onClose: onPromptClose,\n                prefix: promptPrefix,\n                desc: searchPromptDesc,\n                onKeyUp: onPromptKeyUp,\n                onKeyDown: onPromptKeyDown\n              });\n            }\n            break;\n          case 'wordUnderCursor':\n            var word = expandWordUnderCursor(cm, false /** inclusive */, true /** forward */, false /** bigWord */, true /** noSymbol */);\n            var isKeyword = true;\n            if (!word) {\n              word = expandWordUnderCursor(cm, false /** inclusive */, true /** forward */, false /** bigWord */, false /** noSymbol */);\n              isKeyword = false;\n            }\n            if (!word) {\n              return;\n            }\n            var query = cm.getLine(word.start.line).substring(word.start.ch, word.end.ch);\n            if (isKeyword && wholeWordOnly) {\n              query = '\\\\b' + query + '\\\\b';\n            } else {\n              query = escapeRegex(query);\n            }\n\n            // cachedCursor is used to save the old position of the cursor\n            // when * or # causes vim to seek for the nearest word and shift\n            // the cursor before entering the motion.\n            vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n            cm.setCursor(word.start);\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n            break;\n        }\n      },\n      processEx: function (cm, vim, command) {\n        function onPromptClose(input) {\n          // Give the prompt some time to close so that if processCommand shows\n          // an error, the elements don't overlap.\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          exCommandDispatcher.processCommand(cm, input);\n        }\n        function onPromptKeyDown(e, input, close) {\n          var keyName = CodeMirror.keyName(e),\n            up,\n            offset;\n          if (keyName == 'Esc' || keyName == 'Ctrl-C' || keyName == 'Ctrl-[' || keyName == 'Backspace' && input == '') {\n            vimGlobalState.exCommandHistoryController.pushInput(input);\n            vimGlobalState.exCommandHistoryController.reset();\n            CodeMirror.e_stop(e);\n            clearInputState(cm);\n            close();\n            cm.focus();\n          }\n          if (keyName == 'Up' || keyName == 'Down') {\n            CodeMirror.e_stop(e);\n            up = keyName == 'Up' ? true : false;\n            offset = e.target ? e.target.selectionEnd : 0;\n            input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || '';\n            close(input);\n            if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);\n          } else if (keyName == 'Ctrl-U') {\n            // Ctrl-U clears input.\n            CodeMirror.e_stop(e);\n            close('');\n          } else {\n            if (keyName != 'Left' && keyName != 'Right' && keyName != 'Ctrl' && keyName != 'Alt' && keyName != 'Shift') vimGlobalState.exCommandHistoryController.reset();\n          }\n        }\n        if (command.type == 'keyToEx') {\n          // Handle user defined Ex to Ex mappings\n          exCommandDispatcher.processCommand(cm, command.exArgs.input);\n        } else {\n          if (vim.visualMode) {\n            showPrompt(cm, {\n              onClose: onPromptClose,\n              prefix: ':',\n              value: '\\'<,\\'>',\n              onKeyDown: onPromptKeyDown,\n              selectValueOnOpen: false\n            });\n          } else {\n            showPrompt(cm, {\n              onClose: onPromptClose,\n              prefix: ':',\n              onKeyDown: onPromptKeyDown\n            });\n          }\n        }\n      },\n      evalInput: function (cm, vim) {\n        // If the motion command is set, execute both the operator and motion.\n        // Otherwise return.\n        var inputState = vim.inputState;\n        var motion = inputState.motion;\n        var motionArgs = inputState.motionArgs || {};\n        var operator = inputState.operator;\n        var operatorArgs = inputState.operatorArgs || {};\n        var registerName = inputState.registerName;\n        var sel = vim.sel;\n        // TODO: Make sure cm and vim selections are identical outside visual mode.\n        var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head) : cm.getCursor('head'));\n        var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor('anchor'));\n        var oldHead = copyCursor(origHead);\n        var oldAnchor = copyCursor(origAnchor);\n        var newHead, newAnchor;\n        var repeat;\n        if (operator) {\n          this.recordLastEdit(vim, inputState);\n        }\n        if (inputState.repeatOverride !== undefined) {\n          // If repeatOverride is specified, that takes precedence over the\n          // input state's repeat. Used by Ex mode and can be user defined.\n          repeat = inputState.repeatOverride;\n        } else {\n          repeat = inputState.getRepeat();\n        }\n        if (repeat > 0 && motionArgs.explicitRepeat) {\n          motionArgs.repeatIsExplicit = true;\n        } else if (motionArgs.noRepeat || !motionArgs.explicitRepeat && repeat === 0) {\n          repeat = 1;\n          motionArgs.repeatIsExplicit = false;\n        }\n        if (inputState.selectedCharacter) {\n          // If there is a character input, stick it in all of the arg arrays.\n          motionArgs.selectedCharacter = operatorArgs.selectedCharacter = inputState.selectedCharacter;\n        }\n        motionArgs.repeat = repeat;\n        clearInputState(cm);\n        if (motion) {\n          var motionResult = motions[motion](cm, origHead, motionArgs, vim);\n          vim.lastMotion = motions[motion];\n          if (!motionResult) {\n            return;\n          }\n          if (motionArgs.toJumplist) {\n            var jumpList = vimGlobalState.jumpList;\n            // if the current motion is # or *, use cachedCursor\n            var cachedCursor = jumpList.cachedCursor;\n            if (cachedCursor) {\n              recordJumpPosition(cm, cachedCursor, motionResult);\n              delete jumpList.cachedCursor;\n            } else {\n              recordJumpPosition(cm, origHead, motionResult);\n            }\n          }\n          if (motionResult instanceof Array) {\n            newAnchor = motionResult[0];\n            newHead = motionResult[1];\n          } else {\n            newHead = motionResult;\n          }\n          // TODO: Handle null returns from motion commands better.\n          if (!newHead) {\n            newHead = copyCursor(origHead);\n          }\n          if (vim.visualMode) {\n            if (!(vim.visualBlock && newHead.ch === Infinity)) {\n              newHead = clipCursorToContent(cm, newHead, vim.visualBlock);\n            }\n            if (newAnchor) {\n              newAnchor = clipCursorToContent(cm, newAnchor, true);\n            }\n            newAnchor = newAnchor || oldAnchor;\n            sel.anchor = newAnchor;\n            sel.head = newHead;\n            updateCmSelection(cm);\n            updateMark(cm, vim, '<', cursorIsBefore(newAnchor, newHead) ? newAnchor : newHead);\n            updateMark(cm, vim, '>', cursorIsBefore(newAnchor, newHead) ? newHead : newAnchor);\n          } else if (!operator) {\n            newHead = clipCursorToContent(cm, newHead);\n            cm.setCursor(newHead.line, newHead.ch);\n          }\n        }\n        if (operator) {\n          if (operatorArgs.lastSel) {\n            // Replaying a visual mode operation\n            newAnchor = oldAnchor;\n            var lastSel = operatorArgs.lastSel;\n            var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n            var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n            if (lastSel.visualLine) {\n              // Linewise Visual mode: The same number of lines.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            } else if (lastSel.visualBlock) {\n              // Blockwise Visual mode: The same number of lines and columns.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);\n            } else if (lastSel.head.line == lastSel.anchor.line) {\n              // Normal Visual mode within one line: The same number of characters.\n              newHead = Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n            } else {\n              // Normal Visual mode with several lines: The same number of lines, in the\n              // last line the same number of characters as in the last line the last time.\n              newHead = Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n            }\n            vim.visualMode = true;\n            vim.visualLine = lastSel.visualLine;\n            vim.visualBlock = lastSel.visualBlock;\n            sel = vim.sel = {\n              anchor: newAnchor,\n              head: newHead\n            };\n            updateCmSelection(cm);\n          } else if (vim.visualMode) {\n            operatorArgs.lastSel = {\n              anchor: copyCursor(sel.anchor),\n              head: copyCursor(sel.head),\n              visualBlock: vim.visualBlock,\n              visualLine: vim.visualLine\n            };\n          }\n          var curStart, curEnd, linewise, mode;\n          var cmSel;\n          if (vim.visualMode) {\n            // Init visual op\n            curStart = cursorMin(sel.head, sel.anchor);\n            curEnd = cursorMax(sel.head, sel.anchor);\n            linewise = vim.visualLine || operatorArgs.linewise;\n            mode = vim.visualBlock ? 'block' : linewise ? 'line' : 'char';\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode);\n            if (linewise) {\n              var ranges = cmSel.ranges;\n              if (mode == 'block') {\n                // Linewise operators in visual block mode extend to end of line\n                for (var i = 0; i < ranges.length; i++) {\n                  ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n                }\n              } else if (mode == 'line') {\n                ranges[0].head = Pos(ranges[0].head.line + 1, 0);\n              }\n            }\n          } else {\n            // Init motion op\n            curStart = copyCursor(newAnchor || oldAnchor);\n            curEnd = copyCursor(newHead || oldHead);\n            if (cursorIsBefore(curEnd, curStart)) {\n              var tmp = curStart;\n              curStart = curEnd;\n              curEnd = tmp;\n            }\n            linewise = motionArgs.linewise || operatorArgs.linewise;\n            if (linewise) {\n              // Expand selection to entire line.\n              expandSelectionToLine(cm, curStart, curEnd);\n            } else if (motionArgs.forward) {\n              // Clip to trailing newlines only if the motion goes forward.\n              clipToLine(cm, curStart, curEnd);\n            }\n            mode = 'char';\n            var exclusive = !motionArgs.inclusive || linewise;\n            cmSel = makeCmSelection(cm, {\n              anchor: curStart,\n              head: curEnd\n            }, mode, exclusive);\n          }\n          cm.setSelections(cmSel.ranges, cmSel.primary);\n          vim.lastMotion = null;\n          operatorArgs.repeat = repeat; // For indent in visual mode.\n          operatorArgs.registerName = registerName;\n          // Keep track of linewise as it affects how paste and change behave.\n          operatorArgs.linewise = linewise;\n          var operatorMoveTo = operators[operator](cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);\n          if (vim.visualMode) {\n            exitVisualMode(cm, operatorMoveTo != null);\n          }\n          if (operatorMoveTo) {\n            cm.setCursor(operatorMoveTo);\n          }\n        }\n      },\n      recordLastEdit: function (vim, inputState, actionCommand) {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) {\n          return;\n        }\n        vim.lastEditInputState = inputState;\n        vim.lastEditActionCommand = actionCommand;\n        macroModeState.lastInsertModeChanges.changes = [];\n        macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n      }\n    };\n\n    /**\n     * typedef {Object{line:number,ch:number}} Cursor An object containing the\n     *     position of the cursor.\n     */\n    // All of the functions below return Cursor objects.\n    var motions = {\n      moveToTopLine: function (cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).top + motionArgs.repeat - 1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToMiddleLine: function (cm) {\n        var range = getUserVisibleLines(cm);\n        var line = Math.floor((range.top + range.bottom) * 0.5);\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      moveToBottomLine: function (cm, _head, motionArgs) {\n        var line = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1;\n        return Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n      },\n      expandToLine: function (_cm, head, motionArgs) {\n        // Expands forward to end of line, and then to next line if repeat is\n        // >1. Does not handle backward motion!\n        var cur = head;\n        return Pos(cur.line + motionArgs.repeat - 1, Infinity);\n      },\n      findNext: function (cm, _head, motionArgs) {\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        if (!query) {\n          return;\n        }\n        var prev = !motionArgs.forward;\n        // If search is initiated with ? instead of /, negate direction.\n        prev = state.isReversed() ? !prev : prev;\n        highlightSearchMatches(cm, query);\n        return findNext(cm, prev /** prev */, query, motionArgs.repeat);\n      },\n      goToMark: function (cm, _head, motionArgs, vim) {\n        var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n        if (pos) {\n          return motionArgs.linewise ? {\n            line: pos.line,\n            ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line))\n          } : pos;\n        }\n        return null;\n      },\n      moveToOtherHighlightedEnd: function (cm, _head, motionArgs, vim) {\n        if (vim.visualBlock && motionArgs.sameLine) {\n          var sel = vim.sel;\n          return [clipCursorToContent(cm, Pos(sel.anchor.line, sel.head.ch)), clipCursorToContent(cm, Pos(sel.head.line, sel.anchor.ch))];\n        } else {\n          return [vim.sel.head, vim.sel.anchor];\n        }\n      },\n      jumpToMark: function (cm, head, motionArgs, vim) {\n        var best = head;\n        for (var i = 0; i < motionArgs.repeat; i++) {\n          var cursor = best;\n          for (var key in vim.marks) {\n            if (!isLowerCase(key)) {\n              continue;\n            }\n            var mark = vim.marks[key].find();\n            var isWrongDirection = motionArgs.forward ? cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark);\n            if (isWrongDirection) {\n              continue;\n            }\n            if (motionArgs.linewise && mark.line == cursor.line) {\n              continue;\n            }\n            var equal = cursorEqual(cursor, best);\n            var between = motionArgs.forward ? cursorIsBetween(cursor, mark, best) : cursorIsBetween(best, mark, cursor);\n            if (equal || between) {\n              best = mark;\n            }\n          }\n        }\n        if (motionArgs.linewise) {\n          // Vim places the cursor on the first non-whitespace character of\n          // the line if there is one, else it places the cursor at the end\n          // of the line, regardless of whether a mark was found.\n          best = Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));\n        }\n        return best;\n      },\n      moveByCharacters: function (_cm, head, motionArgs) {\n        var cur = head;\n        var repeat = motionArgs.repeat;\n        var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n        return Pos(cur.line, ch);\n      },\n      moveByLines: function (cm, head, motionArgs, vim) {\n        var cur = head;\n        var endCh = cur.ch;\n        // Depending what our last motion was, we may want to do different\n        // things. If our last motion was moving vertically, we want to\n        // preserve the HPos from our last horizontal move.  If our last motion\n        // was going to the end of a line, moving vertically we should go to\n        // the end of the line, etc.\n        switch (vim.lastMotion) {\n          case this.moveByLines:\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveToColumn:\n          case this.moveToEol:\n            endCh = vim.lastHPos;\n            break;\n          default:\n            vim.lastHPos = endCh;\n        }\n        var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);\n        var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n        var first = cm.firstLine();\n        var last = cm.lastLine();\n        // Vim go to line begin or line end when cursor at first/last line and\n        // move to previous/next line is triggered.\n        if (line < first && cur.line == first) {\n          return this.moveToStartOfLine(cm, head, motionArgs, vim);\n        } else if (line > last && cur.line == last) {\n          return this.moveToEol(cm, head, motionArgs, vim);\n        }\n        if (motionArgs.toFirstChar) {\n          endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n          vim.lastHPos = endCh;\n        }\n        vim.lastHSPos = cm.charCoords(Pos(line, endCh), 'div').left;\n        return Pos(line, endCh);\n      },\n      moveByDisplayLines: function (cm, head, motionArgs, vim) {\n        var cur = head;\n        switch (vim.lastMotion) {\n          case this.moveByDisplayLines:\n          case this.moveByScroll:\n          case this.moveByLines:\n          case this.moveToColumn:\n          case this.moveToEol:\n            break;\n          default:\n            vim.lastHSPos = cm.charCoords(cur, 'div').left;\n        }\n        var repeat = motionArgs.repeat;\n        var res = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, 'line', vim.lastHSPos);\n        if (res.hitSide) {\n          if (motionArgs.forward) {\n            var lastCharCoords = cm.charCoords(res, 'div');\n            var goalCoords = {\n              top: lastCharCoords.top + 8,\n              left: vim.lastHSPos\n            };\n            var res = cm.coordsChar(goalCoords, 'div');\n          } else {\n            var resCoords = cm.charCoords(Pos(cm.firstLine(), 0), 'div');\n            resCoords.left = vim.lastHSPos;\n            res = cm.coordsChar(resCoords, 'div');\n          }\n        }\n        vim.lastHPos = res.ch;\n        return res;\n      },\n      moveByPage: function (cm, head, motionArgs) {\n        // CodeMirror only exposes functions that move the cursor page down, so\n        // doing this bad hack to move the cursor and move it back. evalInput\n        // will move the cursor to where it should be in the end.\n        var curStart = head;\n        var repeat = motionArgs.repeat;\n        return cm.findPosV(curStart, motionArgs.forward ? repeat : -repeat, 'page');\n      },\n      moveByParagraph: function (cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findParagraph(cm, head, motionArgs.repeat, dir);\n      },\n      moveBySentence: function (cm, head, motionArgs) {\n        var dir = motionArgs.forward ? 1 : -1;\n        return findSentence(cm, head, motionArgs.repeat, dir);\n      },\n      moveByScroll: function (cm, head, motionArgs, vim) {\n        var scrollbox = cm.getScrollInfo();\n        var curEnd = null;\n        var repeat = motionArgs.repeat;\n        if (!repeat) {\n          repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n        }\n        var orig = cm.charCoords(head, 'local');\n        motionArgs.repeat = repeat;\n        var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n        if (!curEnd) {\n          return null;\n        }\n        var dest = cm.charCoords(curEnd, 'local');\n        cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n        return curEnd;\n      },\n      moveByWords: function (cm, head, motionArgs) {\n        return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward, !!motionArgs.wordEnd, !!motionArgs.bigWord);\n      },\n      moveTillCharacter: function (cm, _head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        var curEnd = moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter);\n        var increment = motionArgs.forward ? -1 : 1;\n        recordLastCharacterSearch(increment, motionArgs);\n        if (!curEnd) return null;\n        curEnd.ch += increment;\n        return curEnd;\n      },\n      moveToCharacter: function (cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        recordLastCharacterSearch(0, motionArgs);\n        return moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n      },\n      moveToSymbol: function (cm, head, motionArgs) {\n        var repeat = motionArgs.repeat;\n        return findSymbol(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;\n      },\n      moveToColumn: function (cm, head, motionArgs, vim) {\n        var repeat = motionArgs.repeat;\n        // repeat is equivalent to which column we want to move to!\n        vim.lastHPos = repeat - 1;\n        vim.lastHSPos = cm.charCoords(head, 'div').left;\n        return moveToColumn(cm, repeat);\n      },\n      moveToEol: function (cm, head, motionArgs, vim) {\n        var cur = head;\n        vim.lastHPos = Infinity;\n        var retval = Pos(cur.line + motionArgs.repeat - 1, Infinity);\n        var end = cm.clipPos(retval);\n        end.ch--;\n        vim.lastHSPos = cm.charCoords(end, 'div').left;\n        return retval;\n      },\n      moveToFirstNonWhiteSpaceCharacter: function (cm, head) {\n        // Go to the start of the line where the text begins, or the end for\n        // whitespace-only lines\n        var cursor = head;\n        return Pos(cursor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));\n      },\n      moveToMatchedSymbol: function (cm, head) {\n        var cursor = head;\n        var line = cursor.line;\n        var ch = cursor.ch;\n        var lineText = cm.getLine(line);\n        var symbol;\n        for (; ch < lineText.length; ch++) {\n          symbol = lineText.charAt(ch);\n          if (symbol && isMatchableSymbol(symbol)) {\n            var style = cm.getTokenTypeAt(Pos(line, ch + 1));\n            if (style !== \"string\" && style !== \"comment\") {\n              break;\n            }\n          }\n        }\n        if (ch < lineText.length) {\n          var matched = cm.findMatchingBracket(Pos(line, ch));\n          return matched.to;\n        } else {\n          return cursor;\n        }\n      },\n      moveToStartOfLine: function (_cm, head) {\n        return Pos(head.line, 0);\n      },\n      moveToLineOrEdgeOfDocument: function (cm, _head, motionArgs) {\n        var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n        if (motionArgs.repeatIsExplicit) {\n          lineNum = motionArgs.repeat - cm.getOption('firstLineNumber');\n        }\n        return Pos(lineNum, findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));\n      },\n      textObjectManipulation: function (cm, head, motionArgs, vim) {\n        // TODO: lots of possible exceptions that can be thrown here. Try da(\n        //     outside of a () block.\n\n        // TODO: adding <> >< to this map doesn't work, presumably because\n        // they're operators\n        var mirroredPairs = {\n          '(': ')',\n          ')': '(',\n          '{': '}',\n          '}': '{',\n          '[': ']',\n          ']': '['\n        };\n        var selfPaired = {\n          '\\'': true,\n          '\"': true\n        };\n        var character = motionArgs.selectedCharacter;\n        // 'b' refers to  '()' block.\n        // 'B' refers to  '{}' block.\n        if (character == 'b') {\n          character = '(';\n        } else if (character == 'B') {\n          character = '{';\n        }\n\n        // Inclusive is the difference between a and i\n        // TODO: Instead of using the additional text object map to perform text\n        //     object operations, merge the map into the defaultKeyMap and use\n        //     motionArgs to define behavior. Define separate entries for 'aw',\n        //     'iw', 'a[', 'i[', etc.\n        var inclusive = !motionArgs.textObjectInner;\n        var tmp;\n        if (mirroredPairs[character]) {\n          tmp = selectCompanionObject(cm, head, character, inclusive);\n        } else if (selfPaired[character]) {\n          tmp = findBeginningAndEnd(cm, head, character, inclusive);\n        } else if (character === 'W') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */, true /** bigWord */);\n        } else if (character === 'w') {\n          tmp = expandWordUnderCursor(cm, inclusive, true /** forward */, false /** bigWord */);\n        } else if (character === 'p') {\n          tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n          motionArgs.linewise = true;\n          if (vim.visualMode) {\n            if (!vim.visualLine) {\n              vim.visualLine = true;\n            }\n          } else {\n            var operatorArgs = vim.inputState.operatorArgs;\n            if (operatorArgs) {\n              operatorArgs.linewise = true;\n            }\n            tmp.end.line--;\n          }\n        } else {\n          // No text object defined for this, don't move.\n          return null;\n        }\n        if (!cm.state.vim.visualMode) {\n          return [tmp.start, tmp.end];\n        } else {\n          return expandSelection(cm, tmp.start, tmp.end);\n        }\n      },\n      repeatLastCharacterSearch: function (cm, head, motionArgs) {\n        var lastSearch = vimGlobalState.lastCharacterSearch;\n        var repeat = motionArgs.repeat;\n        var forward = motionArgs.forward === lastSearch.forward;\n        var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n        cm.moveH(-increment, 'char');\n        motionArgs.inclusive = forward ? true : false;\n        var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);\n        if (!curEnd) {\n          cm.moveH(increment, 'char');\n          return head;\n        }\n        curEnd.ch += increment;\n        return curEnd;\n      }\n    };\n    function defineMotion(name, fn) {\n      motions[name] = fn;\n    }\n    function fillArray(val, times) {\n      var arr = [];\n      for (var i = 0; i < times; i++) {\n        arr.push(val);\n      }\n      return arr;\n    }\n    /**\n     * An operator acts on a text selection. It receives the list of selections\n     * as input. The corresponding CodeMirror selection is guaranteed to\n    * match the input selection.\n     */\n    var operators = {\n      change: function (cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock = vim.visualBlock;\n        if (!vim.visualMode) {\n          var anchor = ranges[0].anchor,\n            head = ranges[0].head;\n          text = cm.getRange(anchor, head);\n          var lastState = vim.lastEditInputState || {};\n          if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n            // Exclude trailing whitespace if the range is not all whitespace.\n            var match = /\\s+$/.exec(text);\n            if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n              head = offsetCursor(head, 0, -match[0].length);\n              text = text.slice(0, -match[0].length);\n            }\n          }\n          var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n          var wasLastLine = cm.firstLine() == cm.lastLine();\n          if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n            cm.replaceRange('', prevLineEnd, head);\n          } else {\n            cm.replaceRange('', anchor, head);\n          }\n          if (args.linewise) {\n            // Push the next line back down, if there is a next line.\n            if (!wasLastLine) {\n              cm.setCursor(prevLineEnd);\n              CodeMirror.commands.newlineAndIndent(cm);\n            }\n            // make sure cursor ends up at the end of the line.\n            anchor.ch = Number.MAX_VALUE;\n          }\n          finalHead = anchor;\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n        }\n        vimGlobalState.registerController.pushText(args.registerName, 'change', text, args.linewise, ranges.length > 1);\n        actions.enterInsertMode(cm, {\n          head: finalHead\n        }, cm.state.vim);\n      },\n      // delete is a javascript keyword.\n      'delete': function (cm, args, ranges) {\n        var finalHead, text;\n        var vim = cm.state.vim;\n        if (!vim.visualBlock) {\n          var anchor = ranges[0].anchor,\n            head = ranges[0].head;\n          if (args.linewise && head.line != cm.firstLine() && anchor.line == cm.lastLine() && anchor.line == head.line - 1) {\n            // Special case for dd on last line (and first line).\n            if (anchor.line == cm.firstLine()) {\n              anchor.ch = 0;\n            } else {\n              anchor = Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n            }\n          }\n          text = cm.getRange(anchor, head);\n          cm.replaceRange('', anchor, head);\n          finalHead = anchor;\n          if (args.linewise) {\n            finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n          }\n        } else {\n          text = cm.getSelection();\n          var replacement = fillArray('', ranges.length);\n          cm.replaceSelections(replacement);\n          finalHead = ranges[0].anchor;\n        }\n        vimGlobalState.registerController.pushText(args.registerName, 'delete', text, args.linewise, vim.visualBlock);\n        var includeLineBreak = vim.insertMode;\n        return clipCursorToContent(cm, finalHead, includeLineBreak);\n      },\n      indent: function (cm, args, ranges) {\n        var vim = cm.state.vim;\n        var startLine = ranges[0].anchor.line;\n        var endLine = vim.visualBlock ? ranges[ranges.length - 1].anchor.line : ranges[0].head.line;\n        // In visual mode, n> shifts the selection right n times, instead of\n        // shifting n lines right once.\n        var repeat = vim.visualMode ? args.repeat : 1;\n        if (args.linewise) {\n          // The only way to delete a newline is to delete until the start of\n          // the next line, so in linewise mode evalInput will include the next\n          // line. We don't want this in indent, so we go back a line.\n          endLine--;\n        }\n        for (var i = startLine; i <= endLine; i++) {\n          for (var j = 0; j < repeat; j++) {\n            cm.indentLine(i, args.indentRight);\n          }\n        }\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n      },\n      changeCase: function (cm, args, ranges, oldAnchor, newHead) {\n        var selections = cm.getSelections();\n        var swapped = [];\n        var toLower = args.toLower;\n        for (var j = 0; j < selections.length; j++) {\n          var toSwap = selections[j];\n          var text = '';\n          if (toLower === true) {\n            text = toSwap.toLowerCase();\n          } else if (toLower === false) {\n            text = toSwap.toUpperCase();\n          } else {\n            for (var i = 0; i < toSwap.length; i++) {\n              var character = toSwap.charAt(i);\n              text += isUpperCase(character) ? character.toLowerCase() : character.toUpperCase();\n            }\n          }\n          swapped.push(text);\n        }\n        cm.replaceSelections(swapped);\n        if (args.shouldMoveCursor) {\n          return newHead;\n        } else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) {\n          return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n        } else if (args.linewise) {\n          return oldAnchor;\n        } else {\n          return cursorMin(ranges[0].anchor, ranges[0].head);\n        }\n      },\n      yank: function (cm, args, ranges, oldAnchor) {\n        var vim = cm.state.vim;\n        var text = cm.getSelection();\n        var endPos = vim.visualMode ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor) : oldAnchor;\n        vimGlobalState.registerController.pushText(args.registerName, 'yank', text, args.linewise, vim.visualBlock);\n        return endPos;\n      }\n    };\n    function defineOperator(name, fn) {\n      operators[name] = fn;\n    }\n    var actions = {\n      jumpListWalk: function (cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat;\n        var forward = actionArgs.forward;\n        var jumpList = vimGlobalState.jumpList;\n        var mark = jumpList.move(cm, forward ? repeat : -repeat);\n        var markPos = mark ? mark.find() : undefined;\n        markPos = markPos ? markPos : cm.getCursor();\n        cm.setCursor(markPos);\n      },\n      scroll: function (cm, actionArgs, vim) {\n        if (vim.visualMode) {\n          return;\n        }\n        var repeat = actionArgs.repeat || 1;\n        var lineHeight = cm.defaultTextHeight();\n        var top = cm.getScrollInfo().top;\n        var delta = lineHeight * repeat;\n        var newPos = actionArgs.forward ? top + delta : top - delta;\n        var cursor = copyCursor(cm.getCursor());\n        var cursorCoords = cm.charCoords(cursor, 'local');\n        if (actionArgs.forward) {\n          if (newPos > cursorCoords.top) {\n            cursor.line += (newPos - cursorCoords.top) / lineHeight;\n            cursor.line = Math.ceil(cursor.line);\n            cm.setCursor(cursor);\n            cursorCoords = cm.charCoords(cursor, 'local');\n            cm.scrollTo(null, cursorCoords.top);\n          } else {\n            // Cursor stays within bounds.  Just reposition the scroll window.\n            cm.scrollTo(null, newPos);\n          }\n        } else {\n          var newBottom = newPos + cm.getScrollInfo().clientHeight;\n          if (newBottom < cursorCoords.bottom) {\n            cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n            cursor.line = Math.floor(cursor.line);\n            cm.setCursor(cursor);\n            cursorCoords = cm.charCoords(cursor, 'local');\n            cm.scrollTo(null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);\n          } else {\n            // Cursor stays within bounds.  Just reposition the scroll window.\n            cm.scrollTo(null, newPos);\n          }\n        }\n      },\n      scrollToCursor: function (cm, actionArgs) {\n        var lineNum = cm.getCursor().line;\n        var charCoords = cm.charCoords(Pos(lineNum, 0), 'local');\n        var height = cm.getScrollInfo().clientHeight;\n        var y = charCoords.top;\n        var lineHeight = charCoords.bottom - y;\n        switch (actionArgs.position) {\n          case 'center':\n            y = y - height / 2 + lineHeight;\n            break;\n          case 'bottom':\n            y = y - height + lineHeight;\n            break;\n        }\n        cm.scrollTo(null, y);\n      },\n      replayMacro: function (cm, actionArgs, vim) {\n        var registerName = actionArgs.selectedCharacter;\n        var repeat = actionArgs.repeat;\n        var macroModeState = vimGlobalState.macroModeState;\n        if (registerName == '@') {\n          registerName = macroModeState.latestRegister;\n        }\n        while (repeat--) {\n          executeMacroRegister(cm, vim, macroModeState, registerName);\n        }\n      },\n      enterMacroRecordMode: function (cm, actionArgs) {\n        var macroModeState = vimGlobalState.macroModeState;\n        var registerName = actionArgs.selectedCharacter;\n        if (vimGlobalState.registerController.isValidRegister(registerName)) {\n          macroModeState.enterMacroRecordMode(cm, registerName);\n        }\n      },\n      toggleOverwrite: function (cm) {\n        if (!cm.state.overwrite) {\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"replace\"\n          });\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"insert\"\n          });\n        }\n      },\n      enterInsertMode: function (cm, actionArgs, vim) {\n        if (cm.getOption('readOnly')) {\n          return;\n        }\n        vim.insertMode = true;\n        vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;\n        var insertAt = actionArgs ? actionArgs.insertAt : null;\n        var sel = vim.sel;\n        var head = actionArgs.head || cm.getCursor('head');\n        var height = cm.listSelections().length;\n        if (insertAt == 'eol') {\n          head = Pos(head.line, lineLength(cm, head.line));\n        } else if (insertAt == 'charAfter') {\n          head = offsetCursor(head, 0, 1);\n        } else if (insertAt == 'firstNonBlank') {\n          head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n        } else if (insertAt == 'startOfSelectedArea') {\n          if (!vim.visualBlock) {\n            if (sel.head.line < sel.anchor.line) {\n              head = sel.head;\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(Math.min(sel.head.line, sel.anchor.line), Math.min(sel.head.ch, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'endOfSelectedArea') {\n          if (!vim.visualBlock) {\n            if (sel.head.line >= sel.anchor.line) {\n              head = offsetCursor(sel.head, 0, 1);\n            } else {\n              head = Pos(sel.anchor.line, 0);\n            }\n          } else {\n            head = Pos(Math.min(sel.head.line, sel.anchor.line), Math.max(sel.head.ch + 1, sel.anchor.ch));\n            height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n          }\n        } else if (insertAt == 'inplace') {\n          if (vim.visualMode) {\n            return;\n          }\n        }\n        cm.setOption('disableInput', false);\n        if (actionArgs && actionArgs.replace) {\n          // Handle Replace-mode as a special case of insert mode.\n          cm.toggleOverwrite(true);\n          cm.setOption('keyMap', 'vim-replace');\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"replace\"\n          });\n        } else {\n          cm.toggleOverwrite(false);\n          cm.setOption('keyMap', 'vim-insert');\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"insert\"\n          });\n        }\n        if (!vimGlobalState.macroModeState.isPlaying) {\n          // Only record if not replaying.\n          cm.on('change', onChange);\n          CodeMirror.on(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        selectForInsert(cm, head, height);\n      },\n      toggleVisualMode: function (cm, actionArgs, vim) {\n        var repeat = actionArgs.repeat;\n        var anchor = cm.getCursor();\n        var head;\n        // TODO: The repeat should actually select number of characters/lines\n        //     equal to the repeat times the size of the previous visual\n        //     operation.\n        if (!vim.visualMode) {\n          // Entering visual mode\n          vim.visualMode = true;\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          head = clipCursorToContent(cm, Pos(anchor.line, anchor.ch + repeat - 1), true /** includeLineBreak */);\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"visual\",\n            subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n          });\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n        } else if (vim.visualLine ^ actionArgs.linewise || vim.visualBlock ^ actionArgs.blockwise) {\n          // Toggling between modes\n          vim.visualLine = !!actionArgs.linewise;\n          vim.visualBlock = !!actionArgs.blockwise;\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"visual\",\n            subMode: vim.visualLine ? \"linewise\" : vim.visualBlock ? \"blockwise\" : \"\"\n          });\n          updateCmSelection(cm);\n        } else {\n          exitVisualMode(cm);\n        }\n      },\n      reselectLastSelection: function (cm, _actionArgs, vim) {\n        var lastSelection = vim.lastSelection;\n        if (vim.visualMode) {\n          updateLastSelection(cm, vim);\n        }\n        if (lastSelection) {\n          var anchor = lastSelection.anchorMark.find();\n          var head = lastSelection.headMark.find();\n          if (!anchor || !head) {\n            // If the marks have been destroyed due to edits, do nothing.\n            return;\n          }\n          vim.sel = {\n            anchor: anchor,\n            head: head\n          };\n          vim.visualMode = true;\n          vim.visualLine = lastSelection.visualLine;\n          vim.visualBlock = lastSelection.visualBlock;\n          updateCmSelection(cm);\n          updateMark(cm, vim, '<', cursorMin(anchor, head));\n          updateMark(cm, vim, '>', cursorMax(anchor, head));\n          CodeMirror.signal(cm, 'vim-mode-change', {\n            mode: 'visual',\n            subMode: vim.visualLine ? 'linewise' : vim.visualBlock ? 'blockwise' : ''\n          });\n        }\n      },\n      joinLines: function (cm, actionArgs, vim) {\n        var curStart, curEnd;\n        if (vim.visualMode) {\n          curStart = cm.getCursor('anchor');\n          curEnd = cm.getCursor('head');\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curEnd;\n            curEnd = curStart;\n            curStart = tmp;\n          }\n          curEnd.ch = lineLength(cm, curEnd.line) - 1;\n        } else {\n          // Repeat is the number of lines to join. Minimum 2 lines.\n          var repeat = Math.max(actionArgs.repeat, 2);\n          curStart = cm.getCursor();\n          curEnd = clipCursorToContent(cm, Pos(curStart.line + repeat - 1, Infinity));\n        }\n        var finalCh = 0;\n        for (var i = curStart.line; i < curEnd.line; i++) {\n          finalCh = lineLength(cm, curStart.line);\n          var tmp = Pos(curStart.line + 1, lineLength(cm, curStart.line + 1));\n          var text = cm.getRange(curStart, tmp);\n          text = text.replace(/\\n\\s*/g, ' ');\n          cm.replaceRange(text, curStart, tmp);\n        }\n        var curFinalPos = Pos(curStart.line, finalCh);\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curFinalPos);\n      },\n      newLineAndEnterInsertMode: function (cm, actionArgs, vim) {\n        vim.insertMode = true;\n        var insertAt = copyCursor(cm.getCursor());\n        if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n          // Special case for inserting newline before start of document.\n          cm.replaceRange('\\n', Pos(cm.firstLine(), 0));\n          cm.setCursor(cm.firstLine(), 0);\n        } else {\n          insertAt.line = actionArgs.after ? insertAt.line : insertAt.line - 1;\n          insertAt.ch = lineLength(cm, insertAt.line);\n          cm.setCursor(insertAt);\n          var newlineFn = CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent;\n          newlineFn(cm);\n        }\n        this.enterInsertMode(cm, {\n          repeat: actionArgs.repeat\n        }, vim);\n      },\n      paste: function (cm, actionArgs, vim) {\n        var cur = copyCursor(cm.getCursor());\n        var register = vimGlobalState.registerController.getRegister(actionArgs.registerName);\n        var text = register.toString();\n        if (!text) {\n          return;\n        }\n        if (actionArgs.matchIndent) {\n          var tabSize = cm.getOption(\"tabSize\");\n          // length that considers tabs and tabSize\n          var whitespaceLength = function (str) {\n            var tabs = str.split(\"\\t\").length - 1;\n            var spaces = str.split(\" \").length - 1;\n            return tabs * tabSize + spaces * 1;\n          };\n          var currentLine = cm.getLine(cm.getCursor().line);\n          var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n          // chomp last newline b/c don't want it to match /^\\s*/gm\n          var chompedText = text.replace(/\\n$/, '');\n          var wasChomped = text !== chompedText;\n          var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n          var text = chompedText.replace(/^\\s*/gm, function (wspace) {\n            var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n            if (newIndent < 0) {\n              return \"\";\n            } else if (cm.getOption(\"indentWithTabs\")) {\n              var quotient = Math.floor(newIndent / tabSize);\n              return Array(quotient + 1).join('\\t');\n            } else {\n              return Array(newIndent + 1).join(' ');\n            }\n          });\n          text += wasChomped ? \"\\n\" : \"\";\n        }\n        if (actionArgs.repeat > 1) {\n          var text = Array(actionArgs.repeat + 1).join(text);\n        }\n        var linewise = register.linewise;\n        var blockwise = register.blockwise;\n        if (linewise) {\n          if (vim.visualMode) {\n            text = vim.visualLine ? text.slice(0, -1) : '\\n' + text.slice(0, text.length - 1) + '\\n';\n          } else if (actionArgs.after) {\n            // Move the newline at the end to the start instead, and paste just\n            // before the newline character of the line we are on right now.\n            text = '\\n' + text.slice(0, text.length - 1);\n            cur.ch = lineLength(cm, cur.line);\n          } else {\n            cur.ch = 0;\n          }\n        } else {\n          if (blockwise) {\n            text = text.split('\\n');\n            for (var i = 0; i < text.length; i++) {\n              text[i] = text[i] == '' ? ' ' : text[i];\n            }\n          }\n          cur.ch += actionArgs.after ? 1 : 0;\n        }\n        var curPosFinal;\n        var idx;\n        if (vim.visualMode) {\n          //  save the pasted text for reselection if the need arises\n          vim.lastPastedText = text;\n          var lastSelectionCurEnd;\n          var selectedArea = getSelectedAreaRange(cm, vim);\n          var selectionStart = selectedArea[0];\n          var selectionEnd = selectedArea[1];\n          var selectedText = cm.getSelection();\n          var selections = cm.listSelections();\n          var emptyStrings = new Array(selections.length).join('1').split('1');\n          // save the curEnd marker before it get cleared due to cm.replaceRange.\n          if (vim.lastSelection) {\n            lastSelectionCurEnd = vim.lastSelection.headMark.find();\n          }\n          // push the previously selected text to unnamed register\n          vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n          if (blockwise) {\n            // first delete the selected text\n            cm.replaceSelections(emptyStrings);\n            // Set new selections as per the block length of the yanked text\n            selectionEnd = Pos(selectionStart.line + text.length - 1, selectionStart.ch);\n            cm.setCursor(selectionStart);\n            selectBlock(cm, selectionEnd);\n            cm.replaceSelections(text);\n            curPosFinal = selectionStart;\n          } else if (vim.visualBlock) {\n            cm.replaceSelections(emptyStrings);\n            cm.setCursor(selectionStart);\n            cm.replaceRange(text, selectionStart, selectionStart);\n            curPosFinal = selectionStart;\n          } else {\n            cm.replaceRange(text, selectionStart, selectionEnd);\n            curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);\n          }\n          // restore the the curEnd marker\n          if (lastSelectionCurEnd) {\n            vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n          }\n          if (linewise) {\n            curPosFinal.ch = 0;\n          }\n        } else {\n          if (blockwise) {\n            cm.setCursor(cur);\n            for (var i = 0; i < text.length; i++) {\n              var line = cur.line + i;\n              if (line > cm.lastLine()) {\n                cm.replaceRange('\\n', Pos(line, 0));\n              }\n              var lastCh = lineLength(cm, line);\n              if (lastCh < cur.ch) {\n                extendLineToColumn(cm, line, cur.ch);\n              }\n            }\n            cm.setCursor(cur);\n            selectBlock(cm, Pos(cur.line + text.length - 1, cur.ch));\n            cm.replaceSelections(text);\n            curPosFinal = cur;\n          } else {\n            cm.replaceRange(text, cur);\n            // Now fine tune the cursor to where we want it.\n            if (linewise && actionArgs.after) {\n              curPosFinal = Pos(cur.line + 1, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));\n            } else if (linewise && !actionArgs.after) {\n              curPosFinal = Pos(cur.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));\n            } else if (!linewise && actionArgs.after) {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length - 1);\n            } else {\n              idx = cm.indexFromPos(cur);\n              curPosFinal = cm.posFromIndex(idx + text.length);\n            }\n          }\n        }\n        if (vim.visualMode) {\n          exitVisualMode(cm, false);\n        }\n        cm.setCursor(curPosFinal);\n      },\n      undo: function (cm, actionArgs) {\n        cm.operation(function () {\n          repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n          cm.setCursor(cm.getCursor('anchor'));\n        });\n      },\n      redo: function (cm, actionArgs) {\n        repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n      },\n      setRegister: function (_cm, actionArgs, vim) {\n        vim.inputState.registerName = actionArgs.selectedCharacter;\n      },\n      setMark: function (cm, actionArgs, vim) {\n        var markName = actionArgs.selectedCharacter;\n        updateMark(cm, vim, markName, cm.getCursor());\n      },\n      replace: function (cm, actionArgs, vim) {\n        var replaceWith = actionArgs.selectedCharacter;\n        var curStart = cm.getCursor();\n        var replaceTo;\n        var curEnd;\n        var selections = cm.listSelections();\n        if (vim.visualMode) {\n          curStart = cm.getCursor('start');\n          curEnd = cm.getCursor('end');\n        } else {\n          var line = cm.getLine(curStart.line);\n          replaceTo = curStart.ch + actionArgs.repeat;\n          if (replaceTo > line.length) {\n            replaceTo = line.length;\n          }\n          curEnd = Pos(curStart.line, replaceTo);\n        }\n        if (replaceWith == '\\n') {\n          if (!vim.visualMode) cm.replaceRange('', curStart, curEnd);\n          // special case, where vim help says to replace by just one line-break\n          (CodeMirror.commands.newlineAndIndentContinueComment || CodeMirror.commands.newlineAndIndent)(cm);\n        } else {\n          var replaceWithStr = cm.getRange(curStart, curEnd);\n          //replace all characters in range by selected, but keep linebreaks\n          replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n          if (vim.visualBlock) {\n            // Tabs are split in visua block before replacing\n            var spaces = new Array(cm.getOption(\"tabSize\") + 1).join(' ');\n            replaceWithStr = cm.getSelection();\n            replaceWithStr = replaceWithStr.replace(/\\t/g, spaces).replace(/[^\\n]/g, replaceWith).split('\\n');\n            cm.replaceSelections(replaceWithStr);\n          } else {\n            cm.replaceRange(replaceWithStr, curStart, curEnd);\n          }\n          if (vim.visualMode) {\n            curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ? selections[0].anchor : selections[0].head;\n            cm.setCursor(curStart);\n            exitVisualMode(cm, false);\n          } else {\n            cm.setCursor(offsetCursor(curEnd, 0, -1));\n          }\n        }\n      },\n      incrementNumberToken: function (cm, actionArgs) {\n        var cur = cm.getCursor();\n        var lineStr = cm.getLine(cur.line);\n        var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n        var match;\n        var start;\n        var end;\n        var numberStr;\n        while ((match = re.exec(lineStr)) !== null) {\n          start = match.index;\n          end = start + match[0].length;\n          if (cur.ch < end) break;\n        }\n        if (!actionArgs.backtrack && end <= cur.ch) return;\n        if (match) {\n          var baseStr = match[2] || match[4];\n          var digits = match[3] || match[5];\n          var increment = actionArgs.increase ? 1 : -1;\n          var base = {\n            '0b': 2,\n            '0': 8,\n            '': 10,\n            '0x': 16\n          }[baseStr.toLowerCase()];\n          var number = parseInt(match[1] + digits, base) + increment * actionArgs.repeat;\n          numberStr = number.toString(base);\n          var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join('0') : '';\n          if (numberStr.charAt(0) === '-') {\n            numberStr = '-' + baseStr + zeroPadding + numberStr.substr(1);\n          } else {\n            numberStr = baseStr + zeroPadding + numberStr;\n          }\n          var from = Pos(cur.line, start);\n          var to = Pos(cur.line, end);\n          cm.replaceRange(numberStr, from, to);\n        } else {\n          return;\n        }\n        cm.setCursor(Pos(cur.line, start + numberStr.length - 1));\n      },\n      repeatLastEdit: function (cm, actionArgs, vim) {\n        var lastEditInputState = vim.lastEditInputState;\n        if (!lastEditInputState) {\n          return;\n        }\n        var repeat = actionArgs.repeat;\n        if (repeat && actionArgs.repeatIsExplicit) {\n          vim.lastEditInputState.repeatOverride = repeat;\n        } else {\n          repeat = vim.lastEditInputState.repeatOverride || repeat;\n        }\n        repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n      },\n      indent: function (cm, actionArgs) {\n        cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n      },\n      exitInsertMode: exitInsertMode\n    };\n    function defineAction(name, fn) {\n      actions[name] = fn;\n    }\n\n    /*\n     * Below are miscellaneous utility functions used by vim.js\n     */\n\n    /**\n     * Clips cursor to ensure that line is within the buffer's range\n     * If includeLineBreak is true, then allow cur.ch == lineLength.\n     */\n    function clipCursorToContent(cm, cur, includeLineBreak) {\n      var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine());\n      var maxCh = lineLength(cm, line) - 1;\n      maxCh = includeLineBreak ? maxCh + 1 : maxCh;\n      var ch = Math.min(Math.max(0, cur.ch), maxCh);\n      return Pos(line, ch);\n    }\n    function copyArgs(args) {\n      var ret = {};\n      for (var prop in args) {\n        if (args.hasOwnProperty(prop)) {\n          ret[prop] = args[prop];\n        }\n      }\n      return ret;\n    }\n    function offsetCursor(cur, offsetLine, offsetCh) {\n      if (typeof offsetLine === 'object') {\n        offsetCh = offsetLine.ch;\n        offsetLine = offsetLine.line;\n      }\n      return Pos(cur.line + offsetLine, cur.ch + offsetCh);\n    }\n    function getOffset(anchor, head) {\n      return {\n        line: head.line - anchor.line,\n        ch: head.line - anchor.line\n      };\n    }\n    function commandMatches(keys, keyMap, context, inputState) {\n      // Partial matches are not applied. They inform the key handler\n      // that the current key sequence is a subsequence of a valid key\n      // sequence, so that the key buffer is not cleared.\n      var match,\n        partial = [],\n        full = [];\n      for (var i = 0; i < keyMap.length; i++) {\n        var command = keyMap[i];\n        if (context == 'insert' && command.context != 'insert' || command.context && command.context != context || inputState.operator && command.type == 'action' || !(match = commandMatch(keys, command.keys))) {\n          continue;\n        }\n        if (match == 'partial') {\n          partial.push(command);\n        }\n        if (match == 'full') {\n          full.push(command);\n        }\n      }\n      return {\n        partial: partial.length && partial,\n        full: full.length && full\n      };\n    }\n    function commandMatch(pressed, mapped) {\n      if (mapped.slice(-11) == '<character>') {\n        // Last character matches anything.\n        var prefixLen = mapped.length - 11;\n        var pressedPrefix = pressed.slice(0, prefixLen);\n        var mappedPrefix = mapped.slice(0, prefixLen);\n        return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? 'full' : mappedPrefix.indexOf(pressedPrefix) == 0 ? 'partial' : false;\n      } else {\n        return pressed == mapped ? 'full' : mapped.indexOf(pressed) == 0 ? 'partial' : false;\n      }\n    }\n    function lastChar(keys) {\n      var match = /^.*(<[^>]+>)$/.exec(keys);\n      var selectedCharacter = match ? match[1] : keys.slice(-1);\n      if (selectedCharacter.length > 1) {\n        switch (selectedCharacter) {\n          case '<CR>':\n            selectedCharacter = '\\n';\n            break;\n          case '<Space>':\n            selectedCharacter = ' ';\n            break;\n          default:\n            selectedCharacter = '';\n            break;\n        }\n      }\n      return selectedCharacter;\n    }\n    function repeatFn(cm, fn, repeat) {\n      return function () {\n        for (var i = 0; i < repeat; i++) {\n          fn(cm);\n        }\n      };\n    }\n    function copyCursor(cur) {\n      return Pos(cur.line, cur.ch);\n    }\n    function cursorEqual(cur1, cur2) {\n      return cur1.ch == cur2.ch && cur1.line == cur2.line;\n    }\n    function cursorIsBefore(cur1, cur2) {\n      if (cur1.line < cur2.line) {\n        return true;\n      }\n      if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n        return true;\n      }\n      return false;\n    }\n    function cursorMin(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMin.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n    }\n    function cursorMax(cur1, cur2) {\n      if (arguments.length > 2) {\n        cur2 = cursorMax.apply(undefined, Array.prototype.slice.call(arguments, 1));\n      }\n      return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n    }\n    function cursorIsBetween(cur1, cur2, cur3) {\n      // returns true if cur2 is between cur1 and cur3.\n      var cur1before2 = cursorIsBefore(cur1, cur2);\n      var cur2before3 = cursorIsBefore(cur2, cur3);\n      return cur1before2 && cur2before3;\n    }\n    function lineLength(cm, lineNum) {\n      return cm.getLine(lineNum).length;\n    }\n    function trim(s) {\n      if (s.trim) {\n        return s.trim();\n      }\n      return s.replace(/^\\s+|\\s+$/g, '');\n    }\n    function escapeRegex(s) {\n      return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, '\\\\$1');\n    }\n    function extendLineToColumn(cm, lineNum, column) {\n      var endCh = lineLength(cm, lineNum);\n      var spaces = new Array(column - endCh + 1).join(' ');\n      cm.setCursor(Pos(lineNum, endCh));\n      cm.replaceRange(spaces, cm.getCursor());\n    }\n    // This functions selects a rectangular block\n    // of text with selectionEnd as any of its corner\n    // Height of block:\n    // Difference in selectionEnd.line and first/last selection.line\n    // Width of the block:\n    // Distance between selectionEnd.ch and any(first considered here) selection.ch\n    function selectBlock(cm, selectionEnd) {\n      var selections = [],\n        ranges = cm.listSelections();\n      var head = copyCursor(cm.clipPos(selectionEnd));\n      var isClipped = !cursorEqual(selectionEnd, head);\n      var curHead = cm.getCursor('head');\n      var primIndex = getIndex(ranges, curHead);\n      var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);\n      var max = ranges.length - 1;\n      var index = max - primIndex > primIndex ? max : 0;\n      var base = ranges[index].anchor;\n      var firstLine = Math.min(base.line, head.line);\n      var lastLine = Math.max(base.line, head.line);\n      var baseCh = base.ch,\n        headCh = head.ch;\n      var dir = ranges[index].head.ch - baseCh;\n      var newDir = headCh - baseCh;\n      if (dir > 0 && newDir <= 0) {\n        baseCh++;\n        if (!isClipped) {\n          headCh--;\n        }\n      } else if (dir < 0 && newDir >= 0) {\n        baseCh--;\n        if (!wasClipped) {\n          headCh++;\n        }\n      } else if (dir < 0 && newDir == -1) {\n        baseCh--;\n        headCh++;\n      }\n      for (var line = firstLine; line <= lastLine; line++) {\n        var range = {\n          anchor: new Pos(line, baseCh),\n          head: new Pos(line, headCh)\n        };\n        selections.push(range);\n      }\n      cm.setSelections(selections);\n      selectionEnd.ch = headCh;\n      base.ch = baseCh;\n      return base;\n    }\n    function selectForInsert(cm, head, height) {\n      var sel = [];\n      for (var i = 0; i < height; i++) {\n        var lineHead = offsetCursor(head, i, 0);\n        sel.push({\n          anchor: lineHead,\n          head: lineHead\n        });\n      }\n      cm.setSelections(sel, 0);\n    }\n    // getIndex returns the index of the cursor in the selections.\n    function getIndex(ranges, cursor, end) {\n      for (var i = 0; i < ranges.length; i++) {\n        var atAnchor = end != 'head' && cursorEqual(ranges[i].anchor, cursor);\n        var atHead = end != 'anchor' && cursorEqual(ranges[i].head, cursor);\n        if (atAnchor || atHead) {\n          return i;\n        }\n      }\n      return -1;\n    }\n    function getSelectedAreaRange(cm, vim) {\n      var lastSelection = vim.lastSelection;\n      var getCurrentSelectedAreaRange = function () {\n        var selections = cm.listSelections();\n        var start = selections[0];\n        var end = selections[selections.length - 1];\n        var selectionStart = cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head;\n        var selectionEnd = cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor;\n        return [selectionStart, selectionEnd];\n      };\n      var getLastSelectedAreaRange = function () {\n        var selectionStart = cm.getCursor();\n        var selectionEnd = cm.getCursor();\n        var block = lastSelection.visualBlock;\n        if (block) {\n          var width = block.width;\n          var height = block.height;\n          selectionEnd = Pos(selectionStart.line + height, selectionStart.ch + width);\n          var selections = [];\n          // selectBlock creates a 'proper' rectangular block.\n          // We do not want that in all cases, so we manually set selections.\n          for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n            var anchor = Pos(i, selectionStart.ch);\n            var head = Pos(i, selectionEnd.ch);\n            var range = {\n              anchor: anchor,\n              head: head\n            };\n            selections.push(range);\n          }\n          cm.setSelections(selections);\n        } else {\n          var start = lastSelection.anchorMark.find();\n          var end = lastSelection.headMark.find();\n          var line = end.line - start.line;\n          var ch = end.ch - start.ch;\n          selectionEnd = {\n            line: selectionEnd.line + line,\n            ch: line ? selectionEnd.ch : ch + selectionEnd.ch\n          };\n          if (lastSelection.visualLine) {\n            selectionStart = Pos(selectionStart.line, 0);\n            selectionEnd = Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));\n          }\n          cm.setSelection(selectionStart, selectionEnd);\n        }\n        return [selectionStart, selectionEnd];\n      };\n      if (!vim.visualMode) {\n        // In case of replaying the action.\n        return getLastSelectedAreaRange();\n      } else {\n        return getCurrentSelectedAreaRange();\n      }\n    }\n    // Updates the previous selection with the current selection's values. This\n    // should only be called in visual mode.\n    function updateLastSelection(cm, vim) {\n      var anchor = vim.sel.anchor;\n      var head = vim.sel.head;\n      // To accommodate the effect of lastPastedText in the last selection\n      if (vim.lastPastedText) {\n        head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);\n        vim.lastPastedText = null;\n      }\n      vim.lastSelection = {\n        'anchorMark': cm.setBookmark(anchor),\n        'headMark': cm.setBookmark(head),\n        'anchor': copyCursor(anchor),\n        'head': copyCursor(head),\n        'visualMode': vim.visualMode,\n        'visualLine': vim.visualLine,\n        'visualBlock': vim.visualBlock\n      };\n    }\n    function expandSelection(cm, start, end) {\n      var sel = cm.state.vim.sel;\n      var head = sel.head;\n      var anchor = sel.anchor;\n      var tmp;\n      if (cursorIsBefore(end, start)) {\n        tmp = end;\n        end = start;\n        start = tmp;\n      }\n      if (cursorIsBefore(head, anchor)) {\n        head = cursorMin(start, head);\n        anchor = cursorMax(anchor, end);\n      } else {\n        anchor = cursorMin(start, anchor);\n        head = cursorMax(head, end);\n        head = offsetCursor(head, 0, -1);\n        if (head.ch == -1 && head.line != cm.firstLine()) {\n          head = Pos(head.line - 1, lineLength(cm, head.line - 1));\n        }\n      }\n      return [anchor, head];\n    }\n    /**\n     * Updates the CodeMirror selection to match the provided vim selection.\n     * If no arguments are given, it uses the current vim selection state.\n     */\n    function updateCmSelection(cm, sel, mode) {\n      var vim = cm.state.vim;\n      sel = sel || vim.sel;\n      var mode = mode || vim.visualLine ? 'line' : vim.visualBlock ? 'block' : 'char';\n      var cmSel = makeCmSelection(cm, sel, mode);\n      cm.setSelections(cmSel.ranges, cmSel.primary);\n      updateFakeCursor(cm);\n    }\n    function makeCmSelection(cm, sel, mode, exclusive) {\n      var head = copyCursor(sel.head);\n      var anchor = copyCursor(sel.anchor);\n      if (mode == 'char') {\n        var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n        head = offsetCursor(sel.head, 0, headOffset);\n        anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n        return {\n          ranges: [{\n            anchor: anchor,\n            head: head\n          }],\n          primary: 0\n        };\n      } else if (mode == 'line') {\n        if (!cursorIsBefore(sel.head, sel.anchor)) {\n          anchor.ch = 0;\n          var lastLine = cm.lastLine();\n          if (head.line > lastLine) {\n            head.line = lastLine;\n          }\n          head.ch = lineLength(cm, head.line);\n        } else {\n          head.ch = 0;\n          anchor.ch = lineLength(cm, anchor.line);\n        }\n        return {\n          ranges: [{\n            anchor: anchor,\n            head: head\n          }],\n          primary: 0\n        };\n      } else if (mode == 'block') {\n        var top = Math.min(anchor.line, head.line),\n          left = Math.min(anchor.ch, head.ch),\n          bottom = Math.max(anchor.line, head.line),\n          right = Math.max(anchor.ch, head.ch) + 1;\n        var height = bottom - top + 1;\n        var primary = head.line == top ? 0 : height - 1;\n        var ranges = [];\n        for (var i = 0; i < height; i++) {\n          ranges.push({\n            anchor: Pos(top + i, left),\n            head: Pos(top + i, right)\n          });\n        }\n        return {\n          ranges: ranges,\n          primary: primary\n        };\n      }\n    }\n    function getHead(cm) {\n      var cur = cm.getCursor('head');\n      if (cm.getSelection().length == 1) {\n        // Small corner case when only 1 character is selected. The \"real\"\n        // head is the left of head and anchor.\n        cur = cursorMin(cur, cm.getCursor('anchor'));\n      }\n      return cur;\n    }\n\n    /**\n     * If moveHead is set to false, the CodeMirror selection will not be\n     * touched. The caller assumes the responsibility of putting the cursor\n    * in the right place.\n     */\n    function exitVisualMode(cm, moveHead) {\n      var vim = cm.state.vim;\n      if (moveHead !== false) {\n        cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n      }\n      updateLastSelection(cm, vim);\n      vim.visualMode = false;\n      vim.visualLine = false;\n      vim.visualBlock = false;\n      CodeMirror.signal(cm, \"vim-mode-change\", {\n        mode: \"normal\"\n      });\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n    }\n\n    // Remove any trailing newlines from the selection. For\n    // example, with the caret at the start of the last word on the line,\n    // 'dw' should word, but not the newline, while 'w' should advance the\n    // caret to the first character of the next line.\n    function clipToLine(cm, curStart, curEnd) {\n      var selection = cm.getRange(curStart, curEnd);\n      // Only clip if the selection ends with trailing newline + whitespace\n      if (/\\n\\s*$/.test(selection)) {\n        var lines = selection.split('\\n');\n        // We know this is all whitespace.\n        lines.pop();\n\n        // Cases:\n        // 1. Last word is an empty line - do not clip the trailing '\\n'\n        // 2. Last word is not an empty line - clip the trailing '\\n'\n        var line;\n        // Find the line containing the last word, and clip all whitespace up\n        // to it.\n        for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {\n          curEnd.line--;\n          curEnd.ch = 0;\n        }\n        // If the last word is not an empty line, clip an additional newline\n        if (line) {\n          curEnd.line--;\n          curEnd.ch = lineLength(cm, curEnd.line);\n        } else {\n          curEnd.ch = 0;\n        }\n      }\n    }\n\n    // Expand the selection to line ends.\n    function expandSelectionToLine(_cm, curStart, curEnd) {\n      curStart.ch = 0;\n      curEnd.ch = 0;\n      curEnd.line++;\n    }\n    function findFirstNonWhiteSpaceCharacter(text) {\n      if (!text) {\n        return 0;\n      }\n      var firstNonWS = text.search(/\\S/);\n      return firstNonWS == -1 ? text.length : firstNonWS;\n    }\n    function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n      var cur = getHead(cm);\n      var line = cm.getLine(cur.line);\n      var idx = cur.ch;\n\n      // Seek to first word or non-whitespace character, depending on if\n      // noSymbol is true.\n      var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0];\n      while (!test(line.charAt(idx))) {\n        idx++;\n        if (idx >= line.length) {\n          return null;\n        }\n      }\n      if (bigWord) {\n        test = bigWordCharTest[0];\n      } else {\n        test = wordCharTest[0];\n        if (!test(line.charAt(idx))) {\n          test = wordCharTest[1];\n        }\n      }\n      var end = idx,\n        start = idx;\n      while (test(line.charAt(end)) && end < line.length) {\n        end++;\n      }\n      while (test(line.charAt(start)) && start >= 0) {\n        start--;\n      }\n      start++;\n      if (inclusive) {\n        // If present, include all whitespace after word.\n        // Otherwise, include all whitespace before word, except indentation.\n        var wordEnd = end;\n        while (/\\s/.test(line.charAt(end)) && end < line.length) {\n          end++;\n        }\n        if (wordEnd == end) {\n          var wordStart = start;\n          while (/\\s/.test(line.charAt(start - 1)) && start > 0) {\n            start--;\n          }\n          if (!start) {\n            start = wordStart;\n          }\n        }\n      }\n      return {\n        start: Pos(cur.line, start),\n        end: Pos(cur.line, end)\n      };\n    }\n    function recordJumpPosition(cm, oldCur, newCur) {\n      if (!cursorEqual(oldCur, newCur)) {\n        vimGlobalState.jumpList.add(cm, oldCur, newCur);\n      }\n    }\n    function recordLastCharacterSearch(increment, args) {\n      vimGlobalState.lastCharacterSearch.increment = increment;\n      vimGlobalState.lastCharacterSearch.forward = args.forward;\n      vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;\n    }\n    var symbolToMode = {\n      '(': 'bracket',\n      ')': 'bracket',\n      '{': 'bracket',\n      '}': 'bracket',\n      '[': 'section',\n      ']': 'section',\n      '*': 'comment',\n      '/': 'comment',\n      'm': 'method',\n      'M': 'method',\n      '#': 'preprocess'\n    };\n    var findSymbolModes = {\n      bracket: {\n        isComplete: function (state) {\n          if (state.nextCh === state.symb) {\n            state.depth++;\n            if (state.depth >= 1) return true;\n          } else if (state.nextCh === state.reverseSymb) {\n            state.depth--;\n          }\n          return false;\n        }\n      },\n      section: {\n        init: function (state) {\n          state.curMoveThrough = true;\n          state.symb = (state.forward ? ']' : '[') === state.symb ? '{' : '}';\n        },\n        isComplete: function (state) {\n          return state.index === 0 && state.nextCh === state.symb;\n        }\n      },\n      comment: {\n        isComplete: function (state) {\n          var found = state.lastCh === '*' && state.nextCh === '/';\n          state.lastCh = state.nextCh;\n          return found;\n        }\n      },\n      // TODO: The original Vim implementation only operates on level 1 and 2.\n      // The current implementation doesn't check for code block level and\n      // therefore it operates on any levels.\n      method: {\n        init: function (state) {\n          state.symb = state.symb === 'm' ? '{' : '}';\n          state.reverseSymb = state.symb === '{' ? '}' : '{';\n        },\n        isComplete: function (state) {\n          if (state.nextCh === state.symb) return true;\n          return false;\n        }\n      },\n      preprocess: {\n        init: function (state) {\n          state.index = 0;\n        },\n        isComplete: function (state) {\n          if (state.nextCh === '#') {\n            var token = state.lineText.match(/#(\\w+)/)[1];\n            if (token === 'endif') {\n              if (state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth++;\n            } else if (token === 'if') {\n              if (!state.forward && state.depth === 0) {\n                return true;\n              }\n              state.depth--;\n            }\n            if (token === 'else' && state.depth === 0) return true;\n          }\n          return false;\n        }\n      }\n    };\n    function findSymbol(cm, repeat, forward, symb) {\n      var cur = copyCursor(cm.getCursor());\n      var increment = forward ? 1 : -1;\n      var endLine = forward ? cm.lineCount() : -1;\n      var curCh = cur.ch;\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      var state = {\n        lineText: lineText,\n        nextCh: lineText.charAt(curCh),\n        lastCh: null,\n        index: curCh,\n        symb: symb,\n        reverseSymb: (forward ? {\n          ')': '(',\n          '}': '{'\n        } : {\n          '(': ')',\n          '{': '}'\n        })[symb],\n        forward: forward,\n        depth: 0,\n        curMoveThrough: false\n      };\n      var mode = symbolToMode[symb];\n      if (!mode) return cur;\n      var init = findSymbolModes[mode].init;\n      var isComplete = findSymbolModes[mode].isComplete;\n      if (init) {\n        init(state);\n      }\n      while (line !== endLine && repeat) {\n        state.index += increment;\n        state.nextCh = state.lineText.charAt(state.index);\n        if (!state.nextCh) {\n          line += increment;\n          state.lineText = cm.getLine(line) || '';\n          if (increment > 0) {\n            state.index = 0;\n          } else {\n            var lineLen = state.lineText.length;\n            state.index = lineLen > 0 ? lineLen - 1 : 0;\n          }\n          state.nextCh = state.lineText.charAt(state.index);\n        }\n        if (isComplete(state)) {\n          cur.line = line;\n          cur.ch = state.index;\n          repeat--;\n        }\n      }\n      if (state.nextCh || state.curMoveThrough) {\n        return Pos(line, state.index);\n      }\n      return cur;\n    }\n\n    /*\n     * Returns the boundaries of the next word. If the cursor in the middle of\n     * the word, then returns the boundaries of the current word, starting at\n     * the cursor. If the cursor is at the start/end of a word, and we are going\n     * forward/backward, respectively, find the boundaries of the next word.\n     *\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Cursor} cur The cursor position.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only [a-zA-Z0-9] characters count as part of the word.\n     * @param {boolean} emptyLineIsWord True if empty lines should be treated\n     *     as words.\n     * @return {Object{from:number, to:number, line: number}} The boundaries of\n     *     the word, or null if there are no more words.\n     */\n    function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n      var lineNum = cur.line;\n      var pos = cur.ch;\n      var line = cm.getLine(lineNum);\n      var dir = forward ? 1 : -1;\n      var charTests = bigWord ? bigWordCharTest : wordCharTest;\n      if (emptyLineIsWord && line == '') {\n        lineNum += dir;\n        line = cm.getLine(lineNum);\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        pos = forward ? 0 : line.length;\n      }\n      while (true) {\n        if (emptyLineIsWord && line == '') {\n          return {\n            from: 0,\n            to: 0,\n            line: lineNum\n          };\n        }\n        var stop = dir > 0 ? line.length : -1;\n        var wordStart = stop,\n          wordEnd = stop;\n        // Find bounds of next word.\n        while (pos != stop) {\n          var foundWord = false;\n          for (var i = 0; i < charTests.length && !foundWord; ++i) {\n            if (charTests[i](line.charAt(pos))) {\n              wordStart = pos;\n              // Advance to end of word.\n              while (pos != stop && charTests[i](line.charAt(pos))) {\n                pos += dir;\n              }\n              wordEnd = pos;\n              foundWord = wordStart != wordEnd;\n              if (wordStart == cur.ch && lineNum == cur.line && wordEnd == wordStart + dir) {\n                // We started at the end of a word. Find the next one.\n                continue;\n              } else {\n                return {\n                  from: Math.min(wordStart, wordEnd + 1),\n                  to: Math.max(wordStart, wordEnd),\n                  line: lineNum\n                };\n              }\n            }\n          }\n          if (!foundWord) {\n            pos += dir;\n          }\n        }\n        // Advance to next/prev line.\n        lineNum += dir;\n        if (!isLine(cm, lineNum)) {\n          return null;\n        }\n        line = cm.getLine(lineNum);\n        pos = dir > 0 ? 0 : line.length;\n      }\n    }\n\n    /**\n     * @param {CodeMirror} cm CodeMirror object.\n     * @param {Pos} cur The position to start from.\n     * @param {int} repeat Number of words to move past.\n     * @param {boolean} forward True to search forward. False to search\n     *     backward.\n     * @param {boolean} wordEnd True to move to end of word. False to move to\n     *     beginning of word.\n     * @param {boolean} bigWord True if punctuation count as part of the word.\n     *     False if only alphabet characters count as part of the word.\n     * @return {Cursor} The position the cursor should move to.\n     */\n    function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n      var curStart = copyCursor(cur);\n      var words = [];\n      if (forward && !wordEnd || !forward && wordEnd) {\n        repeat++;\n      }\n      // For 'e', empty lines are not considered words, go figure.\n      var emptyLineIsWord = !(forward && wordEnd);\n      for (var i = 0; i < repeat; i++) {\n        var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n        if (!word) {\n          var eodCh = lineLength(cm, cm.lastLine());\n          words.push(forward ? {\n            line: cm.lastLine(),\n            from: eodCh,\n            to: eodCh\n          } : {\n            line: 0,\n            from: 0,\n            to: 0\n          });\n          break;\n        }\n        words.push(word);\n        cur = Pos(word.line, forward ? word.to - 1 : word.from);\n      }\n      var shortCircuit = words.length != repeat;\n      var firstWord = words[0];\n      var lastWord = words.pop();\n      if (forward && !wordEnd) {\n        // w\n        if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.from);\n      } else if (forward && wordEnd) {\n        return Pos(lastWord.line, lastWord.to - 1);\n      } else if (!forward && wordEnd) {\n        // ge\n        if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) {\n          // We did not start in the middle of a word. Discard the extra word at the end.\n          lastWord = words.pop();\n        }\n        return Pos(lastWord.line, lastWord.to);\n      } else {\n        // b\n        return Pos(lastWord.line, lastWord.from);\n      }\n    }\n    function moveToCharacter(cm, repeat, forward, character) {\n      var cur = cm.getCursor();\n      var start = cur.ch;\n      var idx;\n      for (var i = 0; i < repeat; i++) {\n        var line = cm.getLine(cur.line);\n        idx = charIdxInLine(start, line, character, forward, true);\n        if (idx == -1) {\n          return null;\n        }\n        start = idx;\n      }\n      return Pos(cm.getCursor().line, idx);\n    }\n    function moveToColumn(cm, repeat) {\n      // repeat is always >= 1, so repeat - 1 always corresponds\n      // to the column we want to go to.\n      var line = cm.getCursor().line;\n      return clipCursorToContent(cm, Pos(line, repeat - 1));\n    }\n    function updateMark(cm, vim, markName, pos) {\n      if (!inArray(markName, validMarks)) {\n        return;\n      }\n      if (vim.marks[markName]) {\n        vim.marks[markName].clear();\n      }\n      vim.marks[markName] = cm.setBookmark(pos);\n    }\n    function charIdxInLine(start, line, character, forward, includeChar) {\n      // Search for char in line.\n      // motion_options: {forward, includeChar}\n      // If includeChar = true, include it too.\n      // If forward = true, search forward, else search backwards.\n      // If char is not found on this line, do nothing\n      var idx;\n      if (forward) {\n        idx = line.indexOf(character, start + 1);\n        if (idx != -1 && !includeChar) {\n          idx -= 1;\n        }\n      } else {\n        idx = line.lastIndexOf(character, start - 1);\n        if (idx != -1 && !includeChar) {\n          idx += 1;\n        }\n      }\n      return idx;\n    }\n    function findParagraph(cm, head, repeat, dir, inclusive) {\n      var line = head.line;\n      var min = cm.firstLine();\n      var max = cm.lastLine();\n      var start,\n        end,\n        i = line;\n      function isEmpty(i) {\n        return !cm.getLine(i);\n      }\n      function isBoundary(i, dir, any) {\n        if (any) {\n          return isEmpty(i) != isEmpty(i + dir);\n        }\n        return !isEmpty(i) && isEmpty(i + dir);\n      }\n      if (dir) {\n        while (min <= i && i <= max && repeat > 0) {\n          if (isBoundary(i, dir)) {\n            repeat--;\n          }\n          i += dir;\n        }\n        return new Pos(i, 0);\n      }\n      var vim = cm.state.vim;\n      if (vim.visualLine && isBoundary(line, 1, true)) {\n        var anchor = vim.sel.anchor;\n        if (isBoundary(anchor.line, -1, true)) {\n          if (!inclusive || anchor.line != line) {\n            line += 1;\n          }\n        }\n      }\n      var startState = isEmpty(line);\n      for (i = line; i <= max && repeat; i++) {\n        if (isBoundary(i, 1, true)) {\n          if (!inclusive || isEmpty(i) != startState) {\n            repeat--;\n          }\n        }\n      }\n      end = new Pos(i, 0);\n      // select boundary before paragraph for the last one\n      if (i > max && !startState) {\n        startState = true;\n      } else {\n        inclusive = false;\n      }\n      for (i = line; i > min; i--) {\n        if (!inclusive || isEmpty(i) == startState || i == line) {\n          if (isBoundary(i, -1, true)) {\n            break;\n          }\n        }\n      }\n      start = new Pos(i, 0);\n      return {\n        start: start,\n        end: end\n      };\n    }\n    function findSentence(cm, cur, repeat, dir) {\n      /*\n        Takes an index object\n        {\n          line: the line string,\n          ln: line number,\n          pos: index in line,\n          dir: direction of traversal (-1 or 1)\n        }\n        and modifies the line, ln, and pos members to represent the\n        next valid position or sets them to null if there are\n        no more valid positions.\n       */\n      function nextChar(cm, idx) {\n        if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n          idx.ln += idx.dir;\n          if (!isLine(cm, idx.ln)) {\n            idx.line = null;\n            idx.ln = null;\n            idx.pos = null;\n            return;\n          }\n          idx.line = cm.getLine(idx.ln);\n          idx.pos = idx.dir > 0 ? 0 : idx.line.length - 1;\n        } else {\n          idx.pos += idx.dir;\n        }\n      }\n\n      /*\n        Performs one iteration of traversal in forward direction\n        Returns an index object of the new location\n       */\n      function forward(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var stop = line === \"\";\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir\n        };\n        var last_valid = {\n          ln: curr.ln,\n          pos: curr.pos\n        };\n        var skip_empty_lines = curr.line === \"\";\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n        while (curr.line !== null) {\n          last_valid.ln = curr.ln;\n          last_valid.pos = curr.pos;\n          if (curr.line === \"\" && !skip_empty_lines) {\n            return {\n              ln: curr.ln,\n              pos: curr.pos\n            };\n          } else if (stop && curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            return {\n              ln: curr.ln,\n              pos: curr.pos\n            };\n          } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && !stop && (curr.pos === curr.line.length - 1 || isWhiteSpaceString(curr.line[curr.pos + 1]))) {\n            stop = true;\n          }\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the last non whitespace character on the last\n          valid line in the case that we reach the end of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for (var i = line.length - 1; i >= 0; --i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n        return last_valid;\n      }\n\n      /*\n        Performs one iteration of traversal in reverse direction\n        Returns an index object of the new location\n       */\n      function reverse(cm, ln, pos, dir) {\n        var line = cm.getLine(ln);\n        var curr = {\n          line: line,\n          ln: ln,\n          pos: pos,\n          dir: dir\n        };\n        var last_valid = {\n          ln: curr.ln,\n          pos: null\n        };\n        var skip_empty_lines = curr.line === \"\";\n\n        // Move one step to skip character we start on\n        nextChar(cm, curr);\n        while (curr.line !== null) {\n          if (curr.line === \"\" && !skip_empty_lines) {\n            if (last_valid.pos !== null) {\n              return last_valid;\n            } else {\n              return {\n                ln: curr.ln,\n                pos: curr.pos\n              };\n            }\n          } else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && last_valid.pos !== null && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) {\n            return last_valid;\n          } else if (curr.line !== \"\" && !isWhiteSpaceString(curr.line[curr.pos])) {\n            skip_empty_lines = false;\n            last_valid = {\n              ln: curr.ln,\n              pos: curr.pos\n            };\n          }\n          nextChar(cm, curr);\n        }\n\n        /*\n          Set the position to the first non whitespace character on the last\n          valid line in the case that we reach the beginning of the document.\n        */\n        var line = cm.getLine(last_valid.ln);\n        last_valid.pos = 0;\n        for (var i = 0; i < line.length; ++i) {\n          if (!isWhiteSpaceString(line[i])) {\n            last_valid.pos = i;\n            break;\n          }\n        }\n        return last_valid;\n      }\n      var curr_index = {\n        ln: cur.line,\n        pos: cur.ch\n      };\n      while (repeat > 0) {\n        if (dir < 0) {\n          curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n        } else {\n          curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n        }\n        repeat--;\n      }\n      return Pos(curr_index.ln, curr_index.pos);\n    }\n\n    // TODO: perhaps this finagling of start and end positions belonds\n    // in codemirror/replaceRange?\n    function selectCompanionObject(cm, head, symb, inclusive) {\n      var cur = head,\n        start,\n        end;\n      var bracketRegexp = {\n        '(': /[()]/,\n        ')': /[()]/,\n        '[': /[[\\]]/,\n        ']': /[[\\]]/,\n        '{': /[{}]/,\n        '}': /[{}]/\n      }[symb];\n      var openSym = {\n        '(': '(',\n        ')': '(',\n        '[': '[',\n        ']': '[',\n        '{': '{',\n        '}': '{'\n      }[symb];\n      var curChar = cm.getLine(cur.line).charAt(cur.ch);\n      // Due to the behavior of scanForBracket, we need to add an offset if the\n      // cursor is on a matching open bracket.\n      var offset = curChar === openSym ? 1 : 0;\n      start = cm.scanForBracket(Pos(cur.line, cur.ch + offset), -1, undefined, {\n        'bracketRegex': bracketRegexp\n      });\n      end = cm.scanForBracket(Pos(cur.line, cur.ch + offset), 1, undefined, {\n        'bracketRegex': bracketRegexp\n      });\n      if (!start || !end) {\n        return {\n          start: cur,\n          end: cur\n        };\n      }\n      start = start.pos;\n      end = end.pos;\n      if (start.line == end.line && start.ch > end.ch || start.line > end.line) {\n        var tmp = start;\n        start = end;\n        end = tmp;\n      }\n      if (inclusive) {\n        end.ch += 1;\n      } else {\n        start.ch += 1;\n      }\n      return {\n        start: start,\n        end: end\n      };\n    }\n\n    // Takes in a symbol and a cursor and tries to simulate text objects that\n    // have identical opening and closing symbols\n    // TODO support across multiple lines\n    function findBeginningAndEnd(cm, head, symb, inclusive) {\n      var cur = copyCursor(head);\n      var line = cm.getLine(cur.line);\n      var chars = line.split('');\n      var start, end, i, len;\n      var firstIndex = chars.indexOf(symb);\n\n      // the decision tree is to always look backwards for the beginning first,\n      // but if the cursor is in front of the first instance of the symb,\n      // then move the cursor forward\n      if (cur.ch < firstIndex) {\n        cur.ch = firstIndex;\n        // Why is this line even here???\n        // cm.setCursor(cur.line, firstIndex+1);\n      }\n      // otherwise if the cursor is currently on the closing symbol\n      else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n        end = cur.ch; // assign end to the current cursor\n        --cur.ch; // make sure to look backwards\n      }\n\n      // if we're currently on the symbol, we've got a start\n      if (chars[cur.ch] == symb && !end) {\n        start = cur.ch + 1; // assign start to ahead of the cursor\n      } else {\n        // go backwards to find the start\n        for (i = cur.ch; i > -1 && !start; i--) {\n          if (chars[i] == symb) {\n            start = i + 1;\n          }\n        }\n      }\n\n      // look forwards for the end symbol\n      if (start && !end) {\n        for (i = start, len = chars.length; i < len && !end; i++) {\n          if (chars[i] == symb) {\n            end = i;\n          }\n        }\n      }\n\n      // nothing found\n      if (!start || !end) {\n        return {\n          start: cur,\n          end: cur\n        };\n      }\n\n      // include the symbols\n      if (inclusive) {\n        --start;\n        ++end;\n      }\n      return {\n        start: Pos(cur.line, start),\n        end: Pos(cur.line, end)\n      };\n    }\n\n    // Search functions\n    defineOption('pcre', true, 'boolean');\n    function SearchState() {}\n    SearchState.prototype = {\n      getQuery: function () {\n        return vimGlobalState.query;\n      },\n      setQuery: function (query) {\n        vimGlobalState.query = query;\n      },\n      getOverlay: function () {\n        return this.searchOverlay;\n      },\n      setOverlay: function (overlay) {\n        this.searchOverlay = overlay;\n      },\n      isReversed: function () {\n        return vimGlobalState.isReversed;\n      },\n      setReversed: function (reversed) {\n        vimGlobalState.isReversed = reversed;\n      },\n      getScrollbarAnnotate: function () {\n        return this.annotate;\n      },\n      setScrollbarAnnotate: function (annotate) {\n        this.annotate = annotate;\n      }\n    };\n    function getSearchState(cm) {\n      var vim = cm.state.vim;\n      return vim.searchState_ || (vim.searchState_ = new SearchState());\n    }\n    function dialog(cm, template, shortText, onClose, options) {\n      if (cm.openDialog) {\n        cm.openDialog(template, onClose, {\n          bottom: true,\n          value: options.value,\n          onKeyDown: options.onKeyDown,\n          onKeyUp: options.onKeyUp,\n          selectValueOnOpen: false\n        });\n      } else {\n        onClose(prompt(shortText, ''));\n      }\n    }\n    function splitBySlash(argString) {\n      return splitBySeparator(argString, '/');\n    }\n    function findUnescapedSlashes(argString) {\n      return findUnescapedSeparators(argString, '/');\n    }\n    function splitBySeparator(argString, separator) {\n      var slashes = findUnescapedSeparators(argString, separator) || [];\n      if (!slashes.length) return [];\n      var tokens = [];\n      // in case of strings like foo/bar\n      if (slashes[0] !== 0) return;\n      for (var i = 0; i < slashes.length; i++) {\n        if (typeof slashes[i] == 'number') tokens.push(argString.substring(slashes[i] + 1, slashes[i + 1]));\n      }\n      return tokens;\n    }\n    function findUnescapedSeparators(str, separator) {\n      if (!separator) separator = '/';\n      var escapeNextChar = false;\n      var slashes = [];\n      for (var i = 0; i < str.length; i++) {\n        var c = str.charAt(i);\n        if (!escapeNextChar && c == separator) {\n          slashes.push(i);\n        }\n        escapeNextChar = !escapeNextChar && c == '\\\\';\n      }\n      return slashes;\n    }\n\n    // Translates a search string from ex (vim) syntax into javascript form.\n    function translateRegex(str) {\n      // When these match, add a '\\' if unescaped or remove one if escaped.\n      var specials = '|(){';\n      // Remove, but never add, a '\\' for these.\n      var unescape = '}';\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i + 1) || '';\n        var specialComesNext = n && specials.indexOf(n) != -1;\n        if (escapeNextChar) {\n          if (c !== '\\\\' || !specialComesNext) {\n            out.push(c);\n          }\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            // Treat the unescape list as special for removing, but not adding '\\'.\n            if (n && unescape.indexOf(n) != -1) {\n              specialComesNext = true;\n            }\n            // Not passing this test means removing a '\\'.\n            if (!specialComesNext || n === '\\\\') {\n              out.push(c);\n            }\n          } else {\n            out.push(c);\n            if (specialComesNext && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Translates the replace part of a search and replace from ex (vim) syntax into\n    // javascript form.  Similar to translateRegex, but additionally fixes back references\n    // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n    var charUnescapes = {\n      '\\\\n': '\\n',\n      '\\\\r': '\\r',\n      '\\\\t': '\\t'\n    };\n    function translateRegexReplace(str) {\n      var escapeNextChar = false;\n      var out = [];\n      for (var i = -1; i < str.length; i++) {\n        var c = str.charAt(i) || '';\n        var n = str.charAt(i + 1) || '';\n        if (charUnescapes[c + n]) {\n          out.push(charUnescapes[c + n]);\n          i++;\n        } else if (escapeNextChar) {\n          // At any point in the loop, escapeNextChar is true if the previous\n          // character was a '\\' and was not escaped.\n          out.push(c);\n          escapeNextChar = false;\n        } else {\n          if (c === '\\\\') {\n            escapeNextChar = true;\n            if (isNumber(n) || n === '$') {\n              out.push('$');\n            } else if (n !== '/' && n !== '\\\\') {\n              out.push('\\\\');\n            }\n          } else {\n            if (c === '$') {\n              out.push('$');\n            }\n            out.push(c);\n            if (n === '/') {\n              out.push('\\\\');\n            }\n          }\n        }\n      }\n      return out.join('');\n    }\n\n    // Unescape \\ and / in the replace part, for PCRE mode.\n    var unescapes = {\n      '\\\\/': '/',\n      '\\\\\\\\': '\\\\',\n      '\\\\n': '\\n',\n      '\\\\r': '\\r',\n      '\\\\t': '\\t'\n    };\n    function unescapeRegexReplace(str) {\n      var stream = new CodeMirror.StringStream(str);\n      var output = [];\n      while (!stream.eol()) {\n        // Search for \\.\n        while (stream.peek() && stream.peek() != '\\\\') {\n          output.push(stream.next());\n        }\n        var matched = false;\n        for (var matcher in unescapes) {\n          if (stream.match(matcher, true)) {\n            matched = true;\n            output.push(unescapes[matcher]);\n            break;\n          }\n        }\n        if (!matched) {\n          // Don't change anything\n          output.push(stream.next());\n        }\n      }\n      return output.join('');\n    }\n\n    /**\n     * Extract the regular expression from the query and return a Regexp object.\n     * Returns null if the query is blank.\n     * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n     * If smartCase is passed in, and the query contains upper case letters,\n     *   then ignoreCase is overridden, and the 'i' flag will not be set.\n     * If the query contains the /i in the flag part of the regular expression,\n     *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n     *   through to the Regex object.\n     */\n    function parseQuery(query, ignoreCase, smartCase) {\n      // First update the last search register\n      var lastSearchRegister = vimGlobalState.registerController.getRegister('/');\n      lastSearchRegister.setText(query);\n      // Check if the query is already a regex.\n      if (query instanceof RegExp) {\n        return query;\n      }\n      // First try to extract regex + flags from the input. If no flags found,\n      // extract just the regex. IE does not accept flags directly defined in\n      // the regex string in the form /regex/flags\n      var slashes = findUnescapedSlashes(query);\n      var regexPart;\n      var forceIgnoreCase;\n      if (!slashes.length) {\n        // Query looks like 'regexp'\n        regexPart = query;\n      } else {\n        // Query looks like 'regexp/...'\n        regexPart = query.substring(0, slashes[0]);\n        var flagsPart = query.substring(slashes[0]);\n        forceIgnoreCase = flagsPart.indexOf('i') != -1;\n      }\n      if (!regexPart) {\n        return null;\n      }\n      if (!getOption('pcre')) {\n        regexPart = translateRegex(regexPart);\n      }\n      if (smartCase) {\n        ignoreCase = /^[^A-Z]*$/.test(regexPart);\n      }\n      var regexp = new RegExp(regexPart, ignoreCase || forceIgnoreCase ? 'i' : undefined);\n      return regexp;\n    }\n    function showConfirm(cm, text) {\n      if (cm.openNotification) {\n        cm.openNotification('<span style=\"color: red\">' + text + '</span>', {\n          bottom: true,\n          duration: 5000\n        });\n      } else {\n        alert(text);\n      }\n    }\n    function makePrompt(prefix, desc) {\n      var raw = '<span style=\"font-family: monospace; white-space: pre\">' + (prefix || \"\") + '<input type=\"text\"></span>';\n      if (desc) raw += ' <span style=\"color: #888\">' + desc + '</span>';\n      return raw;\n    }\n    var searchPromptDesc = '(Javascript regexp)';\n    function showPrompt(cm, options) {\n      var shortText = (options.prefix || '') + ' ' + (options.desc || '');\n      var prompt = makePrompt(options.prefix, options.desc);\n      dialog(cm, prompt, shortText, options.onClose, options);\n    }\n    function regexEqual(r1, r2) {\n      if (r1 instanceof RegExp && r2 instanceof RegExp) {\n        var props = ['global', 'multiline', 'ignoreCase', 'source'];\n        for (var i = 0; i < props.length; i++) {\n          var prop = props[i];\n          if (r1[prop] !== r2[prop]) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    }\n    // Returns true if the query is valid.\n    function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n      if (!rawQuery) {\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n      if (!query) {\n        return;\n      }\n      highlightSearchMatches(cm, query);\n      if (regexEqual(query, state.getQuery())) {\n        return query;\n      }\n      state.setQuery(query);\n      return query;\n    }\n    function searchOverlay(query) {\n      if (query.source.charAt(0) == '^') {\n        var matchSol = true;\n      }\n      return {\n        token: function (stream) {\n          if (matchSol && !stream.sol()) {\n            stream.skipToEnd();\n            return;\n          }\n          var match = stream.match(query, false);\n          if (match) {\n            if (match[0].length == 0) {\n              // Matched empty string, skip to next.\n              stream.next();\n              return 'searching';\n            }\n            if (!stream.sol()) {\n              // Backtrack 1 to match \\b\n              stream.backUp(1);\n              if (!query.exec(stream.next() + match[0])) {\n                stream.next();\n                return null;\n              }\n            }\n            stream.match(query);\n            return 'searching';\n          }\n          while (!stream.eol()) {\n            stream.next();\n            if (stream.match(query, false)) break;\n          }\n        },\n        query: query\n      };\n    }\n    function highlightSearchMatches(cm, query) {\n      var searchState = getSearchState(cm);\n      var overlay = searchState.getOverlay();\n      if (!overlay || query != overlay.query) {\n        if (overlay) {\n          cm.removeOverlay(overlay);\n        }\n        overlay = searchOverlay(query);\n        cm.addOverlay(overlay);\n        if (cm.showMatchesOnScrollbar) {\n          if (searchState.getScrollbarAnnotate()) {\n            searchState.getScrollbarAnnotate().clear();\n          }\n          searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n        }\n        searchState.setOverlay(overlay);\n      }\n    }\n    function findNext(cm, prev, query, repeat) {\n      if (repeat === undefined) {\n        repeat = 1;\n      }\n      return cm.operation(function () {\n        var pos = cm.getCursor();\n        var cursor = cm.getSearchCursor(query, pos);\n        for (var i = 0; i < repeat; i++) {\n          var found = cursor.find(prev);\n          if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n            found = cursor.find(prev);\n          }\n          if (!found) {\n            // SearchCursor may have returned null because it hit EOF, wrap\n            // around and try again.\n            cursor = cm.getSearchCursor(query, prev ? Pos(cm.lastLine()) : Pos(cm.firstLine(), 0));\n            if (!cursor.find(prev)) {\n              return;\n            }\n          }\n        }\n        return cursor.from();\n      });\n    }\n    function clearSearchHighlight(cm) {\n      var state = getSearchState(cm);\n      cm.removeOverlay(getSearchState(cm).getOverlay());\n      state.setOverlay(null);\n      if (state.getScrollbarAnnotate()) {\n        state.getScrollbarAnnotate().clear();\n        state.setScrollbarAnnotate(null);\n      }\n    }\n    /**\n     * Check if pos is in the specified range, INCLUSIVE.\n     * Range can be specified with 1 or 2 arguments.\n     * If the first range argument is an array, treat it as an array of line\n     * numbers. Match pos against any of the lines.\n     * If the first range argument is a number,\n     *   if there is only 1 range argument, check if pos has the same line\n     *       number\n     *   if there are 2 range arguments, then check if pos is in between the two\n     *       range arguments.\n     */\n    function isInRange(pos, start, end) {\n      if (typeof pos != 'number') {\n        // Assume it is a cursor position. Get the line number.\n        pos = pos.line;\n      }\n      if (start instanceof Array) {\n        return inArray(pos, start);\n      } else {\n        if (end) {\n          return pos >= start && pos <= end;\n        } else {\n          return pos == start;\n        }\n      }\n    }\n    function getUserVisibleLines(cm) {\n      var scrollInfo = cm.getScrollInfo();\n      var occludeToleranceTop = 6;\n      var occludeToleranceBottom = 10;\n      var from = cm.coordsChar({\n        left: 0,\n        top: occludeToleranceTop + scrollInfo.top\n      }, 'local');\n      var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n      var to = cm.coordsChar({\n        left: 0,\n        top: bottomY\n      }, 'local');\n      return {\n        top: from.line,\n        bottom: to.line\n      };\n    }\n    function getMarkPos(cm, vim, markName) {\n      if (markName == '\\'') {\n        var history = cm.doc.history.done;\n        var event = history[history.length - 2];\n        return event && event.ranges && event.ranges[0].head;\n      } else if (markName == '.') {\n        if (cm.doc.history.lastModTime == 0) {\n          return; // If no changes, bail out; don't bother to copy or reverse history array.\n        } else {\n          var changeHistory = cm.doc.history.done.filter(function (el) {\n            if (el.changes !== undefined) {\n              return el;\n            }\n          });\n          changeHistory.reverse();\n          var lastEditPos = changeHistory[0].changes[0].to;\n        }\n        return lastEditPos;\n      }\n      var mark = vim.marks[markName];\n      return mark && mark.find();\n    }\n    var ExCommandDispatcher = function () {\n      this.buildCommandMap_();\n    };\n    ExCommandDispatcher.prototype = {\n      processCommand: function (cm, input, opt_params) {\n        var that = this;\n        cm.operation(function () {\n          cm.curOp.isVimOp = true;\n          that._processCommand(cm, input, opt_params);\n        });\n      },\n      _processCommand: function (cm, input, opt_params) {\n        var vim = cm.state.vim;\n        var commandHistoryRegister = vimGlobalState.registerController.getRegister(':');\n        var previousCommand = commandHistoryRegister.toString();\n        if (vim.visualMode) {\n          exitVisualMode(cm);\n        }\n        var inputStream = new CodeMirror.StringStream(input);\n        // update \": with the latest command whether valid or invalid\n        commandHistoryRegister.setText(input);\n        var params = opt_params || {};\n        params.input = input;\n        try {\n          this.parseInput_(cm, inputStream, params);\n        } catch (e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n        var command;\n        var commandName;\n        if (!params.commandName) {\n          // If only a line range is defined, move to the line.\n          if (params.line !== undefined) {\n            commandName = 'move';\n          }\n        } else {\n          command = this.matchCommand_(params.commandName);\n          if (command) {\n            commandName = command.name;\n            if (command.excludeFromCommandHistory) {\n              commandHistoryRegister.setText(previousCommand);\n            }\n            this.parseCommandArgs_(inputStream, params, command);\n            if (command.type == 'exToKey') {\n              // Handle Ex to Key mapping.\n              for (var i = 0; i < command.toKeys.length; i++) {\n                CodeMirror.Vim.handleKey(cm, command.toKeys[i], 'mapping');\n              }\n              return;\n            } else if (command.type == 'exToEx') {\n              // Handle Ex to Ex mapping.\n              this.processCommand(cm, command.toInput);\n              return;\n            }\n          }\n        }\n        if (!commandName) {\n          showConfirm(cm, 'Not an editor command \":' + input + '\"');\n          return;\n        }\n        try {\n          exCommands[commandName](cm, params);\n          // Possibly asynchronous commands (e.g. substitute, which might have a\n          // user confirmation), are responsible for calling the callback when\n          // done. All others have it taken care of for them here.\n          if ((!command || !command.possiblyAsync) && params.callback) {\n            params.callback();\n          }\n        } catch (e) {\n          showConfirm(cm, e);\n          throw e;\n        }\n      },\n      parseInput_: function (cm, inputStream, result) {\n        inputStream.eatWhile(':');\n        // Parse range.\n        if (inputStream.eat('%')) {\n          result.line = cm.firstLine();\n          result.lineEnd = cm.lastLine();\n        } else {\n          result.line = this.parseLineSpec_(cm, inputStream);\n          if (result.line !== undefined && inputStream.eat(',')) {\n            result.lineEnd = this.parseLineSpec_(cm, inputStream);\n          }\n        }\n\n        // Parse command name.\n        var commandMatch = inputStream.match(/^(\\w+)/);\n        if (commandMatch) {\n          result.commandName = commandMatch[1];\n        } else {\n          result.commandName = inputStream.match(/.*/)[0];\n        }\n        return result;\n      },\n      parseLineSpec_: function (cm, inputStream) {\n        var numberMatch = inputStream.match(/^(\\d+)/);\n        if (numberMatch) {\n          // Absolute line number plus offset (N+M or N-M) is probably a typo,\n          // not something the user actually wanted. (NB: vim does allow this.)\n          return parseInt(numberMatch[1], 10) - 1;\n        }\n        switch (inputStream.next()) {\n          case '.':\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          case '$':\n            return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n          case '\\'':\n            var markName = inputStream.next();\n            var markPos = getMarkPos(cm, cm.state.vim, markName);\n            if (!markPos) throw new Error('Mark not set');\n            return this.parseLineSpecOffset_(inputStream, markPos.line);\n          case '-':\n          case '+':\n            inputStream.backUp(1);\n            // Offset is relative to current line if not otherwise specified.\n            return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n          default:\n            inputStream.backUp(1);\n            return undefined;\n        }\n      },\n      parseLineSpecOffset_: function (inputStream, line) {\n        var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n        if (offsetMatch) {\n          var offset = parseInt(offsetMatch[2], 10);\n          if (offsetMatch[1] == \"-\") {\n            line -= offset;\n          } else {\n            line += offset;\n          }\n        }\n        return line;\n      },\n      parseCommandArgs_: function (inputStream, params, command) {\n        if (inputStream.eol()) {\n          return;\n        }\n        params.argString = inputStream.match(/.*/)[0];\n        // Parse command-line arguments\n        var delim = command.argDelimiter || /\\s+/;\n        var args = trim(params.argString).split(delim);\n        if (args.length && args[0]) {\n          params.args = args;\n        }\n      },\n      matchCommand_: function (commandName) {\n        // Return the command in the command map that matches the shortest\n        // prefix of the passed in command name. The match is guaranteed to be\n        // unambiguous if the defaultExCommandMap's shortNames are set up\n        // correctly. (see @code{defaultExCommandMap}).\n        for (var i = commandName.length; i > 0; i--) {\n          var prefix = commandName.substring(0, i);\n          if (this.commandMap_[prefix]) {\n            var command = this.commandMap_[prefix];\n            if (command.name.indexOf(commandName) === 0) {\n              return command;\n            }\n          }\n        }\n        return null;\n      },\n      buildCommandMap_: function () {\n        this.commandMap_ = {};\n        for (var i = 0; i < defaultExCommandMap.length; i++) {\n          var command = defaultExCommandMap[i];\n          var key = command.shortName || command.name;\n          this.commandMap_[key] = command;\n        }\n      },\n      map: function (lhs, rhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          if (ctx) {\n            throw Error('Mode not supported for ex mappings');\n          }\n          var commandName = lhs.substring(1);\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Ex to Ex mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToEx',\n              toInput: rhs.substring(1),\n              user: true\n            };\n          } else {\n            // Ex to key mapping\n            this.commandMap_[commandName] = {\n              name: commandName,\n              type: 'exToKey',\n              toKeys: rhs,\n              user: true\n            };\n          }\n        } else {\n          if (rhs != ':' && rhs.charAt(0) == ':') {\n            // Key to Ex mapping.\n            var mapping = {\n              keys: lhs,\n              type: 'keyToEx',\n              exArgs: {\n                input: rhs.substring(1)\n              }\n            };\n            if (ctx) {\n              mapping.context = ctx;\n            }\n            defaultKeymap.unshift(mapping);\n          } else {\n            // Key to key mapping\n            var mapping = {\n              keys: lhs,\n              type: 'keyToKey',\n              toKeys: rhs\n            };\n            if (ctx) {\n              mapping.context = ctx;\n            }\n            defaultKeymap.unshift(mapping);\n          }\n        }\n      },\n      unmap: function (lhs, ctx) {\n        if (lhs != ':' && lhs.charAt(0) == ':') {\n          // Ex to Ex or Ex to key mapping\n          if (ctx) {\n            throw Error('Mode not supported for ex mappings');\n          }\n          var commandName = lhs.substring(1);\n          if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {\n            delete this.commandMap_[commandName];\n            return;\n          }\n        } else {\n          // Key to Ex or key to key mapping\n          var keys = lhs;\n          for (var i = 0; i < defaultKeymap.length; i++) {\n            if (keys == defaultKeymap[i].keys && defaultKeymap[i].context === ctx) {\n              defaultKeymap.splice(i, 1);\n              return;\n            }\n          }\n        }\n        throw Error('No such mapping.');\n      }\n    };\n    var exCommands = {\n      colorscheme: function (cm, params) {\n        if (!params.args || params.args.length < 1) {\n          showConfirm(cm, cm.getOption('theme'));\n          return;\n        }\n        cm.setOption('theme', params.args[0]);\n      },\n      map: function (cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 2) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n      },\n      imap: function (cm, params) {\n        this.map(cm, params, 'insert');\n      },\n      nmap: function (cm, params) {\n        this.map(cm, params, 'normal');\n      },\n      vmap: function (cm, params) {\n        this.map(cm, params, 'visual');\n      },\n      unmap: function (cm, params, ctx) {\n        var mapArgs = params.args;\n        if (!mapArgs || mapArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'No such mapping: ' + params.input);\n          }\n          return;\n        }\n        exCommandDispatcher.unmap(mapArgs[0], ctx);\n      },\n      move: function (cm, params) {\n        commandDispatcher.processCommand(cm, cm.state.vim, {\n          type: 'motion',\n          motion: 'moveToLineOrEdgeOfDocument',\n          motionArgs: {\n            forward: false,\n            explicitRepeat: true,\n            linewise: true\n          },\n          repeatOverride: params.line + 1\n        });\n      },\n      set: function (cm, params) {\n        var setArgs = params.args;\n        // Options passed through to the setOption/getOption calls. May be passed in by the\n        // local/global versions of the set command\n        var setCfg = params.setCfg || {};\n        if (!setArgs || setArgs.length < 1) {\n          if (cm) {\n            showConfirm(cm, 'Invalid mapping: ' + params.input);\n          }\n          return;\n        }\n        var expr = setArgs[0].split('=');\n        var optionName = expr[0];\n        var value = expr[1];\n        var forceGet = false;\n        if (optionName.charAt(optionName.length - 1) == '?') {\n          // If post-fixed with ?, then the set is actually a get.\n          if (value) {\n            throw Error('Trailing characters: ' + params.argString);\n          }\n          optionName = optionName.substring(0, optionName.length - 1);\n          forceGet = true;\n        }\n        if (value === undefined && optionName.substring(0, 2) == 'no') {\n          // To set boolean options to false, the option name is prefixed with\n          // 'no'.\n          optionName = optionName.substring(2);\n          value = false;\n        }\n        var optionIsBoolean = options[optionName] && options[optionName].type == 'boolean';\n        if (optionIsBoolean && value == undefined) {\n          // Calling set with a boolean option sets it to true.\n          value = true;\n        }\n        // If no value is provided, then we assume this is a get.\n        if (!optionIsBoolean && value === undefined || forceGet) {\n          var oldValue = getOption(optionName, cm, setCfg);\n          if (oldValue instanceof Error) {\n            showConfirm(cm, oldValue.message);\n          } else if (oldValue === true || oldValue === false) {\n            showConfirm(cm, ' ' + (oldValue ? '' : 'no') + optionName);\n          } else {\n            showConfirm(cm, '  ' + optionName + '=' + oldValue);\n          }\n        } else {\n          var setOptionReturn = setOption(optionName, value, cm, setCfg);\n          if (setOptionReturn instanceof Error) {\n            showConfirm(cm, setOptionReturn.message);\n          }\n        }\n      },\n      setlocal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {\n          scope: 'local'\n        };\n        this.set(cm, params);\n      },\n      setglobal: function (cm, params) {\n        // setCfg is passed through to setOption\n        params.setCfg = {\n          scope: 'global'\n        };\n        this.set(cm, params);\n      },\n      registers: function (cm, params) {\n        var regArgs = params.args;\n        var registers = vimGlobalState.registerController.registers;\n        var regInfo = '----------Registers----------<br><br>';\n        if (!regArgs) {\n          for (var registerName in registers) {\n            var text = registers[registerName].toString();\n            if (text.length) {\n              regInfo += '\"' + registerName + '    ' + text + '<br>';\n            }\n          }\n        } else {\n          var registerName;\n          regArgs = regArgs.join('');\n          for (var i = 0; i < regArgs.length; i++) {\n            registerName = regArgs.charAt(i);\n            if (!vimGlobalState.registerController.isValidRegister(registerName)) {\n              continue;\n            }\n            var register = registers[registerName] || new Register();\n            regInfo += '\"' + registerName + '    ' + register.toString() + '<br>';\n          }\n        }\n        showConfirm(cm, regInfo);\n      },\n      sort: function (cm, params) {\n        var reverse, ignoreCase, unique, number, pattern;\n        function parseArgs() {\n          if (params.argString) {\n            var args = new CodeMirror.StringStream(params.argString);\n            if (args.eat('!')) {\n              reverse = true;\n            }\n            if (args.eol()) {\n              return;\n            }\n            if (!args.eatSpace()) {\n              return 'Invalid arguments';\n            }\n            var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n            if (!opts && !args.eol()) {\n              return 'Invalid arguments';\n            }\n            if (opts[1]) {\n              ignoreCase = opts[1].indexOf('i') != -1;\n              unique = opts[1].indexOf('u') != -1;\n              var decimal = opts[1].indexOf('d') != -1 || opts[1].indexOf('n') != -1 && 1;\n              var hex = opts[1].indexOf('x') != -1 && 1;\n              var octal = opts[1].indexOf('o') != -1 && 1;\n              if (decimal + hex + octal > 1) {\n                return 'Invalid arguments';\n              }\n              number = decimal && 'decimal' || hex && 'hex' || octal && 'octal';\n            }\n            if (opts[2]) {\n              pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? 'i' : '');\n            }\n          }\n        }\n        var err = parseArgs();\n        if (err) {\n          showConfirm(cm, err + ': ' + params.argString);\n          return;\n        }\n        var lineStart = params.line || cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        if (lineStart == lineEnd) {\n          return;\n        }\n        var curStart = Pos(lineStart, 0);\n        var curEnd = Pos(lineEnd, lineLength(cm, lineEnd));\n        var text = cm.getRange(curStart, curEnd).split('\\n');\n        var numberRegex = pattern ? pattern : number == 'decimal' ? /(-?)([\\d]+)/ : number == 'hex' ? /(-?)(?:0x)?([0-9a-f]+)/i : number == 'octal' ? /([0-7]+)/ : null;\n        var radix = number == 'decimal' ? 10 : number == 'hex' ? 16 : number == 'octal' ? 8 : null;\n        var numPart = [],\n          textPart = [];\n        if (number || pattern) {\n          for (var i = 0; i < text.length; i++) {\n            var matchPart = pattern ? text[i].match(pattern) : null;\n            if (matchPart && matchPart[0] != '') {\n              numPart.push(matchPart);\n            } else if (!pattern && numberRegex.exec(text[i])) {\n              numPart.push(text[i]);\n            } else {\n              textPart.push(text[i]);\n            }\n          }\n        } else {\n          textPart = text;\n        }\n        function compareFn(a, b) {\n          if (reverse) {\n            var tmp;\n            tmp = a;\n            a = b;\n            b = tmp;\n          }\n          if (ignoreCase) {\n            a = a.toLowerCase();\n            b = b.toLowerCase();\n          }\n          var anum = number && numberRegex.exec(a);\n          var bnum = number && numberRegex.exec(b);\n          if (!anum) {\n            return a < b ? -1 : 1;\n          }\n          anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n          bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n          return anum - bnum;\n        }\n        function comparePatternFn(a, b) {\n          if (reverse) {\n            var tmp;\n            tmp = a;\n            a = b;\n            b = tmp;\n          }\n          if (ignoreCase) {\n            a[0] = a[0].toLowerCase();\n            b[0] = b[0].toLowerCase();\n          }\n          return a[0] < b[0] ? -1 : 1;\n        }\n        numPart.sort(pattern ? comparePatternFn : compareFn);\n        if (pattern) {\n          for (var i = 0; i < numPart.length; i++) {\n            numPart[i] = numPart[i].input;\n          }\n        } else if (!number) {\n          textPart.sort(compareFn);\n        }\n        text = !reverse ? textPart.concat(numPart) : numPart.concat(textPart);\n        if (unique) {\n          // Remove duplicate lines\n          var textOld = text;\n          var lastLine;\n          text = [];\n          for (var i = 0; i < textOld.length; i++) {\n            if (textOld[i] != lastLine) {\n              text.push(textOld[i]);\n            }\n            lastLine = textOld[i];\n          }\n        }\n        cm.replaceRange(text.join('\\n'), curStart, curEnd);\n      },\n      global: function (cm, params) {\n        // a global command is of the form\n        // :[range]g/pattern/[cmd]\n        // argString holds the string /pattern/[cmd]\n        var argString = params.argString;\n        if (!argString) {\n          showConfirm(cm, 'Regular Expression missing from global');\n          return;\n        }\n        // range is specified here\n        var lineStart = params.line !== undefined ? params.line : cm.firstLine();\n        var lineEnd = params.lineEnd || params.line || cm.lastLine();\n        // get the tokens from argString\n        var tokens = splitBySlash(argString);\n        var regexPart = argString,\n          cmd;\n        if (tokens.length) {\n          regexPart = tokens[0];\n          cmd = tokens.slice(1, tokens.length).join('/');\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise\n          // use the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n        // now that we have the regexPart, search for regex matches in the\n        // specified range of lines\n        var query = getSearchState(cm).getQuery();\n        var matchedLines = [],\n          content = '';\n        for (var i = lineStart; i <= lineEnd; i++) {\n          var matched = query.test(cm.getLine(i));\n          if (matched) {\n            matchedLines.push(i + 1);\n            content += cm.getLine(i) + '<br>';\n          }\n        }\n        // if there is no [cmd], just display the list of matched lines\n        if (!cmd) {\n          showConfirm(cm, content);\n          return;\n        }\n        var index = 0;\n        var nextCommand = function () {\n          if (index < matchedLines.length) {\n            var command = matchedLines[index] + cmd;\n            exCommandDispatcher.processCommand(cm, command, {\n              callback: nextCommand\n            });\n          }\n          index++;\n        };\n        nextCommand();\n      },\n      substitute: function (cm, params) {\n        if (!cm.getSearchCursor) {\n          throw new Error('Search feature not available. Requires searchcursor.js or ' + 'any other getSearchCursor implementation.');\n        }\n        var argString = params.argString;\n        var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n        var regexPart,\n          replacePart = '',\n          trailing,\n          flagsPart,\n          count;\n        var confirm = false; // Whether to confirm each replace.\n        var global = false; // True to replace all instances on a line, false to replace only 1.\n        if (tokens.length) {\n          regexPart = tokens[0];\n          replacePart = tokens[1];\n          if (regexPart && regexPart[regexPart.length - 1] === '$') {\n            regexPart = regexPart.slice(0, regexPart.length - 1) + '\\\\n';\n            replacePart = replacePart ? replacePart + '\\n' : '\\n';\n          }\n          if (replacePart !== undefined) {\n            if (getOption('pcre')) {\n              replacePart = unescapeRegexReplace(replacePart);\n            } else {\n              replacePart = translateRegexReplace(replacePart);\n            }\n            vimGlobalState.lastSubstituteReplacePart = replacePart;\n          }\n          trailing = tokens[2] ? tokens[2].split(' ') : [];\n        } else {\n          // either the argString is empty or its of the form ' hello/world'\n          // actually splitBySlash returns a list of tokens\n          // only if the string starts with a '/'\n          if (argString && argString.length) {\n            showConfirm(cm, 'Substitutions should be of the form ' + ':s/pattern/replace/');\n            return;\n          }\n        }\n        // After the 3rd slash, we can have flags followed by a space followed\n        // by count.\n        if (trailing) {\n          flagsPart = trailing[0];\n          count = parseInt(trailing[1]);\n          if (flagsPart) {\n            if (flagsPart.indexOf('c') != -1) {\n              confirm = true;\n              flagsPart.replace('c', '');\n            }\n            if (flagsPart.indexOf('g') != -1) {\n              global = true;\n              flagsPart.replace('g', '');\n            }\n            regexPart = regexPart.replace(/\\//g, \"\\\\/\") + '/' + flagsPart;\n          }\n        }\n        if (regexPart) {\n          // If regex part is empty, then use the previous query. Otherwise use\n          // the regex part as the new query.\n          try {\n            updateSearchQuery(cm, regexPart, true /** ignoreCase */, true /** smartCase */);\n          } catch (e) {\n            showConfirm(cm, 'Invalid regex: ' + regexPart);\n            return;\n          }\n        }\n        replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n        if (replacePart === undefined) {\n          showConfirm(cm, 'No previous substitute regular expression');\n          return;\n        }\n        var state = getSearchState(cm);\n        var query = state.getQuery();\n        var lineStart = params.line !== undefined ? params.line : cm.getCursor().line;\n        var lineEnd = params.lineEnd || lineStart;\n        if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n          lineEnd = Infinity;\n        }\n        if (count) {\n          lineStart = lineEnd;\n          lineEnd = lineStart + count - 1;\n        }\n        var startPos = clipCursorToContent(cm, Pos(lineStart, 0));\n        var cursor = cm.getSearchCursor(query, startPos);\n        doReplace(cm, confirm, global, lineStart, lineEnd, cursor, query, replacePart, params.callback);\n      },\n      redo: CodeMirror.commands.redo,\n      undo: CodeMirror.commands.undo,\n      write: function (cm) {\n        if (CodeMirror.commands.save) {\n          // If a save command is defined, call it.\n          CodeMirror.commands.save(cm);\n        } else if (cm.save) {\n          // Saves to text area if no save command is defined and cm.save() is available.\n          cm.save();\n        }\n      },\n      nohlsearch: function (cm) {\n        clearSearchHighlight(cm);\n      },\n      yank: function (cm) {\n        var cur = copyCursor(cm.getCursor());\n        var line = cur.line;\n        var lineText = cm.getLine(line);\n        vimGlobalState.registerController.pushText('0', 'yank', lineText, true, true);\n      },\n      delmarks: function (cm, params) {\n        if (!params.argString || !trim(params.argString)) {\n          showConfirm(cm, 'Argument required');\n          return;\n        }\n        var state = cm.state.vim;\n        var stream = new CodeMirror.StringStream(trim(params.argString));\n        while (!stream.eol()) {\n          stream.eatSpace();\n\n          // Record the streams position at the beginning of the loop for use\n          // in error messages.\n          var count = stream.pos;\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n            return;\n          }\n          var sym = stream.next();\n          // Check if this symbol is part of a range\n          if (stream.match('-', true)) {\n            // This symbol is part of a range.\n\n            // The range must terminate at an alphabetic character.\n            if (!stream.match(/[a-zA-Z]/, false)) {\n              showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n              return;\n            }\n            var startMark = sym;\n            var finishMark = stream.next();\n            // The range must terminate at an alphabetic character which\n            // shares the same case as the start of the range.\n            if (isLowerCase(startMark) && isLowerCase(finishMark) || isUpperCase(startMark) && isUpperCase(finishMark)) {\n              var start = startMark.charCodeAt(0);\n              var finish = finishMark.charCodeAt(0);\n              if (start >= finish) {\n                showConfirm(cm, 'Invalid argument: ' + params.argString.substring(count));\n                return;\n              }\n\n              // Because marks are always ASCII values, and we have\n              // determined that they are the same case, we can use\n              // their char codes to iterate through the defined range.\n              for (var j = 0; j <= finish - start; j++) {\n                var mark = String.fromCharCode(start + j);\n                delete state.marks[mark];\n              }\n            } else {\n              showConfirm(cm, 'Invalid argument: ' + startMark + '-');\n              return;\n            }\n          } else {\n            // This symbol is a valid mark, and is not part of a range.\n            delete state.marks[sym];\n          }\n        }\n      }\n    };\n    var exCommandDispatcher = new ExCommandDispatcher();\n\n    /**\n    * @param {CodeMirror} cm CodeMirror instance we are in.\n    * @param {boolean} confirm Whether to confirm each replace.\n    * @param {Cursor} lineStart Line to start replacing from.\n    * @param {Cursor} lineEnd Line to stop replacing at.\n    * @param {RegExp} query Query for performing matches with.\n    * @param {string} replaceWith Text to replace matches with. May contain $1,\n    *     $2, etc for replacing captured groups using Javascript replace.\n    * @param {function()} callback A callback for when the replace is done.\n    */\n    function doReplace(cm, confirm, global, lineStart, lineEnd, searchCursor, query, replaceWith, callback) {\n      // Set up all the functions.\n      cm.state.vim.exMode = true;\n      var done = false;\n      var lastPos = searchCursor.from();\n      function replaceAll() {\n        cm.operation(function () {\n          while (!done) {\n            replace();\n            next();\n          }\n          stop();\n        });\n      }\n      function replace() {\n        var text = cm.getRange(searchCursor.from(), searchCursor.to());\n        var newText = text.replace(query, replaceWith);\n        searchCursor.replace(newText);\n      }\n      function next() {\n        // The below only loops to skip over multiple occurrences on the same\n        // line when 'global' is not true.\n        while (searchCursor.findNext() && isInRange(searchCursor.from(), lineStart, lineEnd)) {\n          if (!global && lastPos && searchCursor.from().line == lastPos.line) {\n            continue;\n          }\n          cm.scrollIntoView(searchCursor.from(), 30);\n          cm.setSelection(searchCursor.from(), searchCursor.to());\n          lastPos = searchCursor.from();\n          done = false;\n          return;\n        }\n        done = true;\n      }\n      function stop(close) {\n        if (close) {\n          close();\n        }\n        cm.focus();\n        if (lastPos) {\n          cm.setCursor(lastPos);\n          var vim = cm.state.vim;\n          vim.exMode = false;\n          vim.lastHPos = vim.lastHSPos = lastPos.ch;\n        }\n        if (callback) {\n          callback();\n        }\n      }\n      function onPromptKeyDown(e, _value, close) {\n        // Swallow all keys.\n        CodeMirror.e_stop(e);\n        var keyName = CodeMirror.keyName(e);\n        switch (keyName) {\n          case 'Y':\n            replace();\n            next();\n            break;\n          case 'N':\n            next();\n            break;\n          case 'A':\n            // replaceAll contains a call to close of its own. We don't want it\n            // to fire too early or multiple times.\n            var savedCallback = callback;\n            callback = undefined;\n            cm.operation(replaceAll);\n            callback = savedCallback;\n            break;\n          case 'L':\n            replace();\n          // fall through and exit.\n          case 'Q':\n          case 'Esc':\n          case 'Ctrl-C':\n          case 'Ctrl-[':\n            stop(close);\n            break;\n        }\n        if (done) {\n          stop(close);\n        }\n        return true;\n      }\n\n      // Actually do replace.\n      next();\n      if (done) {\n        showConfirm(cm, 'No matches for ' + query.source);\n        return;\n      }\n      if (!confirm) {\n        replaceAll();\n        if (callback) {\n          callback();\n        }\n        return;\n      }\n      showPrompt(cm, {\n        prefix: 'replace with <strong>' + replaceWith + '</strong> (y/n/a/q/l)',\n        onKeyDown: onPromptKeyDown\n      });\n    }\n    CodeMirror.keyMap.vim = {\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n    function exitInsertMode(cm) {\n      var vim = cm.state.vim;\n      var macroModeState = vimGlobalState.macroModeState;\n      var insertModeChangeRegister = vimGlobalState.registerController.getRegister('.');\n      var isPlaying = macroModeState.isPlaying;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      // In case of visual block, the insertModeChanges are not saved as a\n      // single word, so we convert them to a single word\n      // so as to update the \". register as expected in real vim.\n      var text = [];\n      if (!isPlaying) {\n        var selLength = lastChange.inVisualBlock && vim.lastSelection ? vim.lastSelection.visualBlock.height : 1;\n        var changes = lastChange.changes;\n        var text = [];\n        var i = 0;\n        // In case of multiple selections in blockwise visual,\n        // the inserted text, for example: 'f<Backspace>oo', is stored as\n        // 'f', 'f', InsertModeKey 'o', 'o', 'o', 'o'. (if you have a block with 2 lines).\n        // We push the contents of the changes array as per the following:\n        // 1. In case of InsertModeKey, just increment by 1.\n        // 2. In case of a character, jump by selLength (2 in the example).\n        while (i < changes.length) {\n          // This loop will convert 'ff<bs>oooo' to 'f<bs>oo'.\n          text.push(changes[i]);\n          if (changes[i] instanceof InsertModeKey) {\n            i++;\n          } else {\n            i += selLength;\n          }\n        }\n        lastChange.changes = text;\n        cm.off('change', onChange);\n        CodeMirror.off(cm.getInputField(), 'keydown', onKeyEventTargetKeyDown);\n      }\n      if (!isPlaying && vim.insertModeRepeat > 1) {\n        // Perform insert mode repeat for commands like 3,a and 3,o.\n        repeatLastEdit(cm, vim, vim.insertModeRepeat - 1, true /** repeatForInsert */);\n        vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n      }\n      delete vim.insertModeRepeat;\n      vim.insertMode = false;\n      cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1);\n      cm.setOption('keyMap', 'vim');\n      cm.setOption('disableInput', true);\n      cm.toggleOverwrite(false); // exit replace mode if we were in it.\n      // update the \". register before exiting insert mode\n      insertModeChangeRegister.setText(lastChange.changes.join(''));\n      CodeMirror.signal(cm, \"vim-mode-change\", {\n        mode: \"normal\"\n      });\n      if (macroModeState.isRecording) {\n        logInsertModeChange(macroModeState);\n      }\n    }\n    function _mapCommand(command) {\n      defaultKeymap.unshift(command);\n    }\n    function mapCommand(keys, type, name, args, extra) {\n      var command = {\n        keys: keys,\n        type: type\n      };\n      command[type] = name;\n      command[type + \"Args\"] = args;\n      for (var key in extra) command[key] = extra[key];\n      _mapCommand(command);\n    }\n\n    // The timeout in milliseconds for the two-character ESC keymap should be\n    // adjusted according to your typing speed to prevent false positives.\n    defineOption('insertModeEscKeysTimeout', 200, 'number');\n    CodeMirror.keyMap['vim-insert'] = {\n      // TODO: override navigation keys so that Esc will cancel automatic\n      // indentation from o, O, i_<CR>\n      fallthrough: ['default'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n    CodeMirror.keyMap['vim-replace'] = {\n      'Backspace': 'goCharLeft',\n      fallthrough: ['vim-insert'],\n      attach: attachVimMap,\n      detach: detachVimMap,\n      call: cmKey\n    };\n    function executeMacroRegister(cm, vim, macroModeState, registerName) {\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (registerName == ':') {\n        // Read-only register containing last Ex command.\n        if (register.keyBuffer[0]) {\n          exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n        }\n        macroModeState.isPlaying = false;\n        return;\n      }\n      var keyBuffer = register.keyBuffer;\n      var imc = 0;\n      macroModeState.isPlaying = true;\n      macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n      for (var i = 0; i < keyBuffer.length; i++) {\n        var text = keyBuffer[i];\n        var match, key;\n        while (text) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = /<\\w+-.+?>|<\\w+>|./.exec(text);\n          key = match[0];\n          text = text.substring(match.index + key.length);\n          CodeMirror.Vim.handleKey(cm, key, 'macro');\n          if (vim.insertMode) {\n            var changes = register.insertModeChanges[imc++].changes;\n            vimGlobalState.macroModeState.lastInsertModeChanges.changes = changes;\n            repeatInsertModeChanges(cm, changes, 1);\n            exitInsertMode(cm);\n          }\n        }\n      }\n      macroModeState.isPlaying = false;\n    }\n    function logKey(macroModeState, key) {\n      if (macroModeState.isPlaying) {\n        return;\n      }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.pushText(key);\n      }\n    }\n    function logInsertModeChange(macroModeState) {\n      if (macroModeState.isPlaying) {\n        return;\n      }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushInsertModeChanges) {\n        register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n      }\n    }\n    function logSearchQuery(macroModeState, query) {\n      if (macroModeState.isPlaying) {\n        return;\n      }\n      var registerName = macroModeState.latestRegister;\n      var register = vimGlobalState.registerController.getRegister(registerName);\n      if (register && register.pushSearchQuery) {\n        register.pushSearchQuery(query);\n      }\n    }\n\n    /**\n     * Listens for changes made in insert mode.\n     * Should only be active in insert mode.\n     */\n    function onChange(cm, changeObj) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (!macroModeState.isPlaying) {\n        while (changeObj) {\n          lastChange.expectCursorActivityForChange = true;\n          if (changeObj.origin == '+input' || changeObj.origin == 'paste' || changeObj.origin === undefined /* only in testing */) {\n            var text = changeObj.text.join('\\n');\n            if (lastChange.maybeReset) {\n              lastChange.changes = [];\n              lastChange.maybeReset = false;\n            }\n            if (cm.state.overwrite && !/\\n/.test(text)) {\n              lastChange.changes.push([text]);\n            } else {\n              lastChange.changes.push(text);\n            }\n          }\n          // Change objects may be chained with next.\n          changeObj = changeObj.next;\n        }\n      }\n    }\n\n    /**\n    * Listens for any kind of cursor activity on CodeMirror.\n    */\n    function onCursorActivity(cm) {\n      var vim = cm.state.vim;\n      if (vim.insertMode) {\n        // Tracking cursor activity in insert mode (for macro support).\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isPlaying) {\n          return;\n        }\n        var lastChange = macroModeState.lastInsertModeChanges;\n        if (lastChange.expectCursorActivityForChange) {\n          lastChange.expectCursorActivityForChange = false;\n        } else {\n          // Cursor moved outside the context of an edit. Reset the change.\n          lastChange.maybeReset = true;\n        }\n      } else if (!cm.curOp.isVimOp) {\n        handleExternalSelection(cm, vim);\n      }\n      if (vim.visualMode) {\n        updateFakeCursor(cm);\n      }\n    }\n    function updateFakeCursor(cm) {\n      var vim = cm.state.vim;\n      var from = clipCursorToContent(cm, copyCursor(vim.sel.head));\n      var to = offsetCursor(from, 0, 1);\n      if (vim.fakeCursor) {\n        vim.fakeCursor.clear();\n      }\n      vim.fakeCursor = cm.markText(from, to, {\n        className: 'cm-animate-fat-cursor'\n      });\n    }\n    function handleExternalSelection(cm, vim) {\n      var anchor = cm.getCursor('anchor');\n      var head = cm.getCursor('head');\n      // Enter or exit visual mode to match mouse selection.\n      if (vim.visualMode && !cm.somethingSelected()) {\n        exitVisualMode(cm, false);\n      } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n        vim.visualMode = true;\n        vim.visualLine = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\"\n        });\n      }\n      if (vim.visualMode) {\n        // Bind CodeMirror selection model to vim selection model.\n        // Mouse selections are considered visual characterwise.\n        var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n        var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n        head = offsetCursor(head, 0, headOffset);\n        anchor = offsetCursor(anchor, 0, anchorOffset);\n        vim.sel = {\n          anchor: anchor,\n          head: head\n        };\n        updateMark(cm, vim, '<', cursorMin(head, anchor));\n        updateMark(cm, vim, '>', cursorMax(head, anchor));\n      } else if (!vim.insertMode) {\n        // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n        vim.lastHPos = cm.getCursor().ch;\n      }\n    }\n\n    /** Wrapper for special keys pressed in insert mode */\n    function InsertModeKey(keyName) {\n      this.keyName = keyName;\n    }\n\n    /**\n    * Handles raw key down events from the text area.\n    * - Should only be active in insert mode.\n    * - For recording deletes in insert mode.\n    */\n    function onKeyEventTargetKeyDown(e) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var lastChange = macroModeState.lastInsertModeChanges;\n      var keyName = CodeMirror.keyName(e);\n      if (!keyName) {\n        return;\n      }\n      function onKeyFound() {\n        if (lastChange.maybeReset) {\n          lastChange.changes = [];\n          lastChange.maybeReset = false;\n        }\n        lastChange.changes.push(new InsertModeKey(keyName));\n        return true;\n      }\n      if (keyName.indexOf('Delete') != -1 || keyName.indexOf('Backspace') != -1) {\n        CodeMirror.lookupKey(keyName, 'vim-insert', onKeyFound);\n      }\n    }\n\n    /**\n     * Repeats the last edit, which includes exactly 1 command and at most 1\n     * insert. Operator and motion commands are read from lastEditInputState,\n     * while action commands are read from lastEditActionCommand.\n     *\n     * If repeatForInsert is true, then the function was called by\n     * exitInsertMode to repeat the insert mode changes the user just made. The\n     * corresponding enterInsertMode call was made with a count.\n     */\n    function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n      var macroModeState = vimGlobalState.macroModeState;\n      macroModeState.isPlaying = true;\n      var isAction = !!vim.lastEditActionCommand;\n      var cachedInputState = vim.inputState;\n      function repeatCommand() {\n        if (isAction) {\n          commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n        } else {\n          commandDispatcher.evalInput(cm, vim);\n        }\n      }\n      function repeatInsert(repeat) {\n        if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n          // For some reason, repeat cw in desktop VIM does not repeat\n          // insert mode changes. Will conform to that behavior.\n          repeat = !vim.lastEditActionCommand ? 1 : repeat;\n          var changeObject = macroModeState.lastInsertModeChanges;\n          repeatInsertModeChanges(cm, changeObject.changes, repeat);\n        }\n      }\n      vim.inputState = vim.lastEditInputState;\n      if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n        // o and O repeat have to be interlaced with insert repeats so that the\n        // insertions appear on separate lines instead of the last line.\n        for (var i = 0; i < repeat; i++) {\n          repeatCommand();\n          repeatInsert(1);\n        }\n      } else {\n        if (!repeatForInsert) {\n          // Hack to get the cursor to end up at the right place. If I is\n          // repeated in insert mode repeat, cursor will be 1 insert\n          // change set left of where it should be.\n          repeatCommand();\n        }\n        repeatInsert(repeat);\n      }\n      vim.inputState = cachedInputState;\n      if (vim.insertMode && !repeatForInsert) {\n        // Don't exit insert mode twice. If repeatForInsert is set, then we\n        // were called by an exitInsertMode call lower on the stack.\n        exitInsertMode(cm);\n      }\n      macroModeState.isPlaying = false;\n    }\n    function repeatInsertModeChanges(cm, changes, repeat) {\n      function keyHandler(binding) {\n        if (typeof binding == 'string') {\n          CodeMirror.commands[binding](cm);\n        } else {\n          binding(cm);\n        }\n        return true;\n      }\n      var head = cm.getCursor('head');\n      var inVisualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.inVisualBlock;\n      if (inVisualBlock) {\n        // Set up block selection again for repeating the changes.\n        var vim = cm.state.vim;\n        var lastSel = vim.lastSelection;\n        var offset = getOffset(lastSel.anchor, lastSel.head);\n        selectForInsert(cm, head, offset.line + 1);\n        repeat = cm.listSelections().length;\n        cm.setCursor(head);\n      }\n      for (var i = 0; i < repeat; i++) {\n        if (inVisualBlock) {\n          cm.setCursor(offsetCursor(head, i, 0));\n        }\n        for (var j = 0; j < changes.length; j++) {\n          var change = changes[j];\n          if (change instanceof InsertModeKey) {\n            CodeMirror.lookupKey(change.keyName, 'vim-insert', keyHandler);\n          } else if (typeof change == \"string\") {\n            var cur = cm.getCursor();\n            cm.replaceRange(change, cur, cur);\n          } else {\n            var start = cm.getCursor();\n            var end = offsetCursor(start, 0, change[0].length);\n            cm.replaceRange(change[0], start, end);\n          }\n        }\n      }\n      if (inVisualBlock) {\n        cm.setCursor(offsetCursor(head, 0, 1));\n      }\n    }\n    resetVimGlobalState();\n    return vimApi;\n  };\n  // Initialize Vim and make it available as an API.\n  CodeMirror.Vim = Vim();\n});"],"sourceRoot":""}