{"version":3,"sources":["webpack:///./node_modules/esprima/esprima.js"],"names":["root","factory","exports","Token","TokenName","FnExprTokens","Syntax","PlaceHolders","Messages","Regex","source","strict","index","lineNumber","lineStart","hasLineTerminator","lastIndex","lastLineNumber","lastLineStart","startIndex","startLineNumber","startLineStart","scanning","length","lookahead","state","extra","isBindingElement","isAssignmentTarget","firstCoverInitializedNameError","assert","condition","message","Error","isDecimalDigit","ch","isHexDigit","indexOf","isOctalDigit","octalToDecimal","octal","code","isWhiteSpace","isLineTerminator","fromCodePoint","cp","String","fromCharCode","isIdentifierStart","NonAsciiIdentifierStart","test","isIdentifierPart","NonAsciiIdentifierPart","isStrictModeReservedWord","id","isRestrictedWord","addComment","type","value","start","end","loc","comment","lastCommentStart","range","comments","push","attachComment","leadingComments","trailingComments","tokenize","delegate","tokens","skipSingleLineComment","offset","line","column","charCodeAt","slice","skipMultiLineComment","tolerateUnexpectedToken","skipComment","scanHexEscape","prefix","i","len","toLowerCase","scanUnicodeCodePointEscape","throwUnexpectedToken","codePointAt","second","getComplexIdentifier","substr","scanIdentifier","getIdentifier","Identifier","isKeyword","Keyword","NullLiteral","BooleanLiteral","scanPunctuator","token","str","Punctuator","openParenToken","tokenValues","openCurlyToken","curlyStack","pop","scanOctalLiteral","number","NumericLiteral","parseInt","scanNumericLiteral","scanHexLiteral","scanBinaryLiteral","isImplicitOctalLiteral","parseFloat","scanRegExp","body","flags","classMarker","terminated","UnterminatedRegExp","literal","scanRegExpBody","restore","scanRegExpFlags","pattern","tmp","replace","$0","$1","$2","codePoint","InvalidRegExp","RegExp","e","exception","testRegExp","RegularExpression","regex","collectRegex","pos","isIdentifierName","advance","EOF","quote","unescaped","octToDec","StringLiteral","scanStringLiteral","previous","check","testKeyword","advanceSlash","rawOffset","head","tail","cooked","throwError","TemplateOctalLiteral","Template","raw","scanTemplate","collectToken","entry","lex","peek","Position","this","SourceLocation","WrappingSourceLocation","startToken","Node","WrappingNode","recordError","error","existing","errors","createError","description","msg","base","Object","create","defineProperty","constructError","messageFormat","args","Array","prototype","call","arguments","whole","idx","tolerateError","unexpectedTokenError","UnexpectedToken","UnexpectedEOS","UnexpectedIdentifier","UnexpectedNumber","UnexpectedString","UnexpectedTemplate","isFutureReservedWord","StrictReservedWord","UnexpectedReserved","expect","expectCommaSeparator","expectKeyword","keyword","match","matchKeyword","matchContextualKeyword","consumeSemicolon","isolateCoverGrammar","parser","result","oldIsBindingElement","oldIsAssignmentTarget","oldFirstCoverInitializedNameError","inheritCoverGrammar","parsePropertyPattern","params","kind","key","keyToken","init","node","computed","parseVariableIdentifier","parseAssignmentExpression","finishProperty","finishAssignmentPattern","parseObjectPropertyKey","parsePatternWithDefault","parsePattern","rest","restNode","elements","finishRestElement","finishArrayPattern","parseArrayPattern","properties","finishObjectPattern","parseObjectPattern","previousAllowYield","right","allowYield","parseArrayInitializer","restSpread","finishSpreadElement","finishArrayExpression","parsePropertyFunction","paramInfo","isGenerator","previousStrict","parseFunctionSourceElements","firstRestricted","stricted","finishFunctionExpression","defaults","expr","StrictOctalLiteral","finishLiteral","finishIdentifier","lookaheadPropertyName","tryParseMethodDefinition","options","methodNode","defaultCount","paramSet","parseParam","parseParams","method","parsePropertyMethodFunction","parseObjectProperty","hasProto","maybeMethod","proto","name","Literal","DuplicateProtoProperty","parseObjectInitializer","finishObjectExpression","reinterpretExpressionAsPattern","MemberExpression","RestElement","AssignmentPattern","SpreadElement","argument","ArrayExpression","ArrayPattern","ObjectExpression","ObjectPattern","AssignmentExpression","left","parseTemplateElement","option","finishTemplateElement","parseTemplateLiteral","quasi","quasis","expressions","parseExpression","finishTemplateLiteral","parseGroupExpression","ArrowParameterPlaceHolder","rawParams","parseRestElement","finishSequenceExpression","SequenceExpression","parsePrimaryExpression","sourceType","parseNonComputedProperty","StrictFunctionName","parseFunctionExpression","finishThisExpression","classBody","superClass","classNode","parseLeftHandSideExpressionAllowCall","parseClassBody","finishClassExpression","parseClassExpression","parseArguments","parseNonComputedMember","parseComputedMember","parseNewExpression","callee","inFunctionBody","finishMetaProperty","parseLeftHandSideExpression","finishNewExpression","property","previousAllowIn","allowIn","finishSuper","finishMemberExpression","finishCallExpression","finishTaggedTemplateExpression","parsePostfixExpression","StrictLHSPostfix","InvalidLHSInAssignment","finishPostfixExpression","parseUnaryExpression","StrictLHSPrefix","finishUnaryExpression","operator","StrictDelete","binaryPrecedence","prec","parseBinaryExpression","marker","markers","stack","finishBinaryExpression","checkPatternParam","param","validateParam","YieldExpression","parseArrowFunctionExpression","finishArrowFunctionExpression","BlockStatement","list","op","finishYieldExpression","parseYieldExpression","consequent","alternate","finishConditionalExpression","parseConditionalExpression","StrictParamDupe","reinterpretAsCoverFormalsList","StrictLHSAssignment","finishAssignmentExpression","parseStatementListItem","IllegalExportDeclaration","declaration","expression","parseFunctionDeclaration","finishExportDefaultDeclaration","parseClassDeclaration","parseExportDefaultDeclaration","src","MissingFromClause","parseModuleSpecifier","finishExportAllDeclaration","parseExportAllDeclaration","isExportFromIdentifier","specifiers","parseLexicalDeclaration","inFor","finishExportNamedDeclaration","parseExportSpecifier","parseExportNamedDeclaration","parseExportDeclaration","IllegalImportDeclaration","concat","parseNamedImports","parseImportNamespaceSpecifier","local","finishImportDefaultSpecifier","parseImportDefaultSpecifier","finishImportDeclaration","parseImportDeclaration","ts","tokenCount","lexical","splice","resetTokenizerState","parseStatement","parseBlock","block","parseStatementList","finishBlockStatement","parseVariableDeclaration","StrictVarName","finishVariableDeclarator","parseVariableDeclarationList","opt","parseLexicalBinding","parseBindingList","declarations","finishLexicalDeclaration","ObjectPatternAsRestParameter","DefaultRestParameter","ParameterAfterRestParameter","parseSwitchCase","statement","finishSwitchCase","parseTryStatement","handler","finalizer","paramMap","hasOwnProperty","DuplicateBinding","StrictCatchVariable","finishCatchClause","parseCatchClause","NoCatchOrFinally","finishTryStatement","labeledBody","finishEmptyStatement","parseEmptyStatement","finishExpressionStatement","parseExpressionStatement","label","inIteration","inSwitch","IllegalBreak","finishBreakStatement","labelSet","UnknownLabel","parseBreakStatement","IllegalContinue","finishContinueStatement","parseContinueStatement","finishDebuggerStatement","parseDebuggerStatement","oldInIteration","finishDoWhileStatement","parseDoWhileStatement","forIn","initSeq","initStartToken","update","finishVariableDeclaration","InvalidLHSInForIn","InvalidLHSInForLoop","finishForStatement","finishForInStatement","finishForOfStatement","parseForStatement","finishIfStatement","parseIfStatement","IllegalReturn","finishReturnStatement","parseReturnStatement","discriminant","cases","clause","oldInSwitch","defaultFound","finishSwitchStatement","MultipleDefaultsInSwitch","parseSwitchStatement","NewlineAfterThrow","finishThrowStatement","parseThrowStatement","parseVariableStatement","finishWhileStatement","parseWhileStatement","object","StrictModeWith","finishWithStatement","parseWithStatement","Redeclaration","finishLabeledStatement","oldLabelSet","oldInFunctionBody","StrictParamName","def","identifierIsOptional","finishFunctionDeclaration","isStatic","hasConstructor","toString","StaticPrototype","generator","ConstructorSpecialMethod","DuplicateConstructor","MethodDefinition","shorthand","finishClassBody","finishClassDeclaration","InvalidModuleSpecifier","exported","finishExportSpecifier","imported","finishImportSpecifier","NoAsAfterImportNamespace","finishImportNamespaceSpecifier","parseProgram","parseScriptBody","finishProgram","ArrowFunctionExpression","BinaryExpression","BreakStatement","CallExpression","CatchClause","ClassBody","ClassDeclaration","ClassExpression","ConditionalExpression","ContinueStatement","DoWhileStatement","DebuggerStatement","EmptyStatement","ExportAllDeclaration","ExportDefaultDeclaration","ExportNamedDeclaration","ExportSpecifier","ExpressionStatement","ForStatement","ForOfStatement","ForInStatement","FunctionDeclaration","FunctionExpression","IfStatement","ImportDeclaration","ImportDefaultSpecifier","ImportNamespaceSpecifier","ImportSpecifier","LabeledStatement","LogicalExpression","MetaProperty","NewExpression","Program","Property","ReturnStatement","Super","SwitchCase","SwitchStatement","TaggedTemplateExpression","TemplateElement","TemplateLiteral","ThisExpression","ThrowStatement","TryStatement","UnaryExpression","UpdateExpression","VariableDeclaration","VariableDeclarator","WhileStatement","WithStatement","processComment","lastChild","innerComments","bottomRight","bottomRightStack","last","unshift","undefined","finish","each","accessor","meta","tag","guardedHandlers","handlers","version","tolerant","lexError","parse","program","filterTokenLocation","types","freeze"],"mappings":"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","file":"e6d6ed13-f66b80e7d04ca230012c.js","sourcesContent":["require(\"core-js/modules/es.regexp.flags.js\");\n/*\n  Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n(function (root, factory) {\n  'use strict';\n\n  // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n  // Rhino, and plain browser loading.\n\n  /* istanbul ignore next */\n  if (typeof define === 'function' && define.amd) {\n    define(['exports'], factory);\n  } else if (typeof exports !== 'undefined') {\n    factory(exports);\n  } else {\n    factory(root.esprima = {});\n  }\n})(this, function (exports) {\n  'use strict';\n\n  var Token, TokenName, FnExprTokens, Syntax, PlaceHolders, Messages, Regex, source, strict, index, lineNumber, lineStart, hasLineTerminator, lastIndex, lastLineNumber, lastLineStart, startIndex, startLineNumber, startLineStart, scanning, length, lookahead, state, extra, isBindingElement, isAssignmentTarget, firstCoverInitializedNameError;\n  Token = {\n    BooleanLiteral: 1,\n    EOF: 2,\n    Identifier: 3,\n    Keyword: 4,\n    NullLiteral: 5,\n    NumericLiteral: 6,\n    Punctuator: 7,\n    StringLiteral: 8,\n    RegularExpression: 9,\n    Template: 10\n  };\n  TokenName = {};\n  TokenName[Token.BooleanLiteral] = 'Boolean';\n  TokenName[Token.EOF] = '<end>';\n  TokenName[Token.Identifier] = 'Identifier';\n  TokenName[Token.Keyword] = 'Keyword';\n  TokenName[Token.NullLiteral] = 'Null';\n  TokenName[Token.NumericLiteral] = 'Numeric';\n  TokenName[Token.Punctuator] = 'Punctuator';\n  TokenName[Token.StringLiteral] = 'String';\n  TokenName[Token.RegularExpression] = 'RegularExpression';\n  TokenName[Token.Template] = 'Template';\n\n  // A function following one of those tokens is an expression.\n  FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new', 'return', 'case', 'delete', 'throw', 'void',\n  // assignment operators\n  '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=', '&=', '|=', '^=', ',',\n  // binary/unary operators\n  '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&', '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=', '<=', '<', '>', '!=', '!=='];\n  Syntax = {\n    AssignmentExpression: 'AssignmentExpression',\n    AssignmentPattern: 'AssignmentPattern',\n    ArrayExpression: 'ArrayExpression',\n    ArrayPattern: 'ArrayPattern',\n    ArrowFunctionExpression: 'ArrowFunctionExpression',\n    BlockStatement: 'BlockStatement',\n    BinaryExpression: 'BinaryExpression',\n    BreakStatement: 'BreakStatement',\n    CallExpression: 'CallExpression',\n    CatchClause: 'CatchClause',\n    ClassBody: 'ClassBody',\n    ClassDeclaration: 'ClassDeclaration',\n    ClassExpression: 'ClassExpression',\n    ConditionalExpression: 'ConditionalExpression',\n    ContinueStatement: 'ContinueStatement',\n    DoWhileStatement: 'DoWhileStatement',\n    DebuggerStatement: 'DebuggerStatement',\n    EmptyStatement: 'EmptyStatement',\n    ExportAllDeclaration: 'ExportAllDeclaration',\n    ExportDefaultDeclaration: 'ExportDefaultDeclaration',\n    ExportNamedDeclaration: 'ExportNamedDeclaration',\n    ExportSpecifier: 'ExportSpecifier',\n    ExpressionStatement: 'ExpressionStatement',\n    ForStatement: 'ForStatement',\n    ForOfStatement: 'ForOfStatement',\n    ForInStatement: 'ForInStatement',\n    FunctionDeclaration: 'FunctionDeclaration',\n    FunctionExpression: 'FunctionExpression',\n    Identifier: 'Identifier',\n    IfStatement: 'IfStatement',\n    ImportDeclaration: 'ImportDeclaration',\n    ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n    ImportSpecifier: 'ImportSpecifier',\n    Literal: 'Literal',\n    LabeledStatement: 'LabeledStatement',\n    LogicalExpression: 'LogicalExpression',\n    MemberExpression: 'MemberExpression',\n    MetaProperty: 'MetaProperty',\n    MethodDefinition: 'MethodDefinition',\n    NewExpression: 'NewExpression',\n    ObjectExpression: 'ObjectExpression',\n    ObjectPattern: 'ObjectPattern',\n    Program: 'Program',\n    Property: 'Property',\n    RestElement: 'RestElement',\n    ReturnStatement: 'ReturnStatement',\n    SequenceExpression: 'SequenceExpression',\n    SpreadElement: 'SpreadElement',\n    Super: 'Super',\n    SwitchCase: 'SwitchCase',\n    SwitchStatement: 'SwitchStatement',\n    TaggedTemplateExpression: 'TaggedTemplateExpression',\n    TemplateElement: 'TemplateElement',\n    TemplateLiteral: 'TemplateLiteral',\n    ThisExpression: 'ThisExpression',\n    ThrowStatement: 'ThrowStatement',\n    TryStatement: 'TryStatement',\n    UnaryExpression: 'UnaryExpression',\n    UpdateExpression: 'UpdateExpression',\n    VariableDeclaration: 'VariableDeclaration',\n    VariableDeclarator: 'VariableDeclarator',\n    WhileStatement: 'WhileStatement',\n    WithStatement: 'WithStatement',\n    YieldExpression: 'YieldExpression'\n  };\n  PlaceHolders = {\n    ArrowParameterPlaceHolder: 'ArrowParameterPlaceHolder'\n  };\n\n  // Error messages should be identical to V8.\n  Messages = {\n    UnexpectedToken: 'Unexpected token %0',\n    UnexpectedNumber: 'Unexpected number',\n    UnexpectedString: 'Unexpected string',\n    UnexpectedIdentifier: 'Unexpected identifier',\n    UnexpectedReserved: 'Unexpected reserved word',\n    UnexpectedTemplate: 'Unexpected quasi %0',\n    UnexpectedEOS: 'Unexpected end of input',\n    NewlineAfterThrow: 'Illegal newline after throw',\n    InvalidRegExp: 'Invalid regular expression',\n    UnterminatedRegExp: 'Invalid regular expression: missing /',\n    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',\n    InvalidLHSInForIn: 'Invalid left-hand side in for-in',\n    InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',\n    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n    NoCatchOrFinally: 'Missing catch or finally after try',\n    UnknownLabel: 'Undefined label \\'%0\\'',\n    Redeclaration: '%0 \\'%1\\' has already been declared',\n    IllegalContinue: 'Illegal continue statement',\n    IllegalBreak: 'Illegal break statement',\n    IllegalReturn: 'Illegal return statement',\n    StrictModeWith: 'Strict mode code may not include a with statement',\n    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',\n    StrictVarName: 'Variable name may not be eval or arguments in strict mode',\n    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',\n    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',\n    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',\n    StrictDelete: 'Delete of an unqualified identifier in strict mode.',\n    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',\n    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n    StrictReservedWord: 'Use of future reserved word in strict mode',\n    TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',\n    ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',\n    DefaultRestParameter: 'Unexpected token =',\n    ObjectPatternAsRestParameter: 'Unexpected token {',\n    DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',\n    ConstructorSpecialMethod: 'Class constructor may not be an accessor',\n    DuplicateConstructor: 'A class may only have one constructor',\n    StaticPrototype: 'Classes may not have static property named prototype',\n    MissingFromClause: 'Unexpected token',\n    NoAsAfterImportNamespace: 'Unexpected token',\n    InvalidModuleSpecifier: 'Unexpected token',\n    IllegalImportDeclaration: 'Unexpected token',\n    IllegalExportDeclaration: 'Unexpected token',\n    DuplicateBinding: 'Duplicate binding %0'\n  };\n\n  // See also tools/generate-unicode-regex.js.\n  Regex = {\n    // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:\n    NonAsciiIdentifierStart: /[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF5D-\\uDF61]|\\uD805[\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA]|\\uD806[\\uDCA0-\\uDCDF\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF98]|\\uD809[\\uDC00-\\uDC6E]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50\\uDF93-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD83A[\\uDC00-\\uDCC4]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D]|\\uD87E[\\uDC00-\\uDE1D]/,\n    // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:\n    NonAsciiIdentifierPart: /[\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF30-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE33\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDD0-\\uDDDA\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF01-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3C-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB7\\uDEC0-\\uDEC9]|\\uD806[\\uDCA0-\\uDCE9\\uDCFF\\uDEC0-\\uDEF8]|\\uD808[\\uDC00-\\uDF98]|\\uD809[\\uDC00-\\uDC6E]|[\\uD80C\\uD840-\\uD868\\uD86A-\\uD86C][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDF00-\\uDF44\\uDF50-\\uDF7E\\uDF8F-\\uDF9F]|\\uD82C[\\uDC00\\uDC01]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDED6\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D]|\\uD87E[\\uDC00-\\uDE1D]|\\uDB40[\\uDD00-\\uDDEF]/\n  };\n\n  // Ensure the condition is true, otherwise throw an error.\n  // This is only to have a better contract semantic, i.e. another safety net\n  // to catch a logic error. The condition shall be fulfilled in normal case.\n  // Do NOT use this to enforce a certain condition on any user input.\n\n  function assert(condition, message) {\n    /* istanbul ignore if */\n    if (!condition) {\n      throw new Error('ASSERT: ' + message);\n    }\n  }\n  function isDecimalDigit(ch) {\n    return ch >= 0x30 && ch <= 0x39; // 0..9\n  }\n  function isHexDigit(ch) {\n    return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n  }\n  function isOctalDigit(ch) {\n    return '01234567'.indexOf(ch) >= 0;\n  }\n  function octalToDecimal(ch) {\n    // \\0 is not octal escape sequence\n    var octal = ch !== '0',\n      code = '01234567'.indexOf(ch);\n    if (index < length && isOctalDigit(source[index])) {\n      octal = true;\n      code = code * 8 + '01234567'.indexOf(source[index++]);\n\n      // 3 digits are only allowed when string starts\n      // with 0, 1, 2, 3\n      if ('0123'.indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {\n        code = code * 8 + '01234567'.indexOf(source[index++]);\n      }\n    }\n    return {\n      code: code,\n      octal: octal\n    };\n  }\n\n  // ECMA-262 11.2 White Space\n\n  function isWhiteSpace(ch) {\n    return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0;\n  }\n\n  // ECMA-262 11.3 Line Terminators\n\n  function isLineTerminator(ch) {\n    return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;\n  }\n\n  // ECMA-262 11.6 Identifier Names and Identifiers\n\n  function fromCodePoint(cp) {\n    return cp < 0x10000 ? String.fromCharCode(cp) : String.fromCharCode(0xD800 + (cp - 0x10000 >> 10)) + String.fromCharCode(0xDC00 + (cp - 0x10000 & 1023));\n  }\n  function isIdentifierStart(ch) {\n    return ch === 0x24 || ch === 0x5F ||\n    // $ (dollar) and _ (underscore)\n    ch >= 0x41 && ch <= 0x5A ||\n    // A..Z\n    ch >= 0x61 && ch <= 0x7A ||\n    // a..z\n    ch === 0x5C ||\n    // \\ (backslash)\n    ch >= 0x80 && Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));\n  }\n  function isIdentifierPart(ch) {\n    return ch === 0x24 || ch === 0x5F ||\n    // $ (dollar) and _ (underscore)\n    ch >= 0x41 && ch <= 0x5A ||\n    // A..Z\n    ch >= 0x61 && ch <= 0x7A ||\n    // a..z\n    ch >= 0x30 && ch <= 0x39 ||\n    // 0..9\n    ch === 0x5C ||\n    // \\ (backslash)\n    ch >= 0x80 && Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));\n  }\n\n  // ECMA-262 11.6.2.2 Future Reserved Words\n\n  function isFutureReservedWord(id) {\n    switch (id) {\n      case 'enum':\n      case 'export':\n      case 'import':\n      case 'super':\n        return true;\n      default:\n        return false;\n    }\n  }\n  function isStrictModeReservedWord(id) {\n    switch (id) {\n      case 'implements':\n      case 'interface':\n      case 'package':\n      case 'private':\n      case 'protected':\n      case 'public':\n      case 'static':\n      case 'yield':\n      case 'let':\n        return true;\n      default:\n        return false;\n    }\n  }\n  function isRestrictedWord(id) {\n    return id === 'eval' || id === 'arguments';\n  }\n\n  // ECMA-262 11.6.2.1 Keywords\n\n  function isKeyword(id) {\n    switch (id.length) {\n      case 2:\n        return id === 'if' || id === 'in' || id === 'do';\n      case 3:\n        return id === 'var' || id === 'for' || id === 'new' || id === 'try' || id === 'let';\n      case 4:\n        return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';\n      case 5:\n        return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';\n      case 6:\n        return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';\n      case 7:\n        return id === 'default' || id === 'finally' || id === 'extends';\n      case 8:\n        return id === 'function' || id === 'continue' || id === 'debugger';\n      case 10:\n        return id === 'instanceof';\n      default:\n        return false;\n    }\n  }\n\n  // ECMA-262 11.4 Comments\n\n  function addComment(type, value, start, end, loc) {\n    var comment;\n    assert(typeof start === 'number', 'Comment must have valid position');\n    state.lastCommentStart = start;\n    comment = {\n      type: type,\n      value: value\n    };\n    if (extra.range) {\n      comment.range = [start, end];\n    }\n    if (extra.loc) {\n      comment.loc = loc;\n    }\n    extra.comments.push(comment);\n    if (extra.attachComment) {\n      extra.leadingComments.push(comment);\n      extra.trailingComments.push(comment);\n    }\n    if (extra.tokenize) {\n      comment.type = comment.type + 'Comment';\n      if (extra.delegate) {\n        comment = extra.delegate(comment);\n      }\n      extra.tokens.push(comment);\n    }\n  }\n  function skipSingleLineComment(offset) {\n    var start, loc, ch, comment;\n    start = index - offset;\n    loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart - offset\n      }\n    };\n    while (index < length) {\n      ch = source.charCodeAt(index);\n      ++index;\n      if (isLineTerminator(ch)) {\n        hasLineTerminator = true;\n        if (extra.comments) {\n          comment = source.slice(start + offset, index - 1);\n          loc.end = {\n            line: lineNumber,\n            column: index - lineStart - 1\n          };\n          addComment('Line', comment, start, index - 1, loc);\n        }\n        if (ch === 13 && source.charCodeAt(index) === 10) {\n          ++index;\n        }\n        ++lineNumber;\n        lineStart = index;\n        return;\n      }\n    }\n    if (extra.comments) {\n      comment = source.slice(start + offset, index);\n      loc.end = {\n        line: lineNumber,\n        column: index - lineStart\n      };\n      addComment('Line', comment, start, index, loc);\n    }\n  }\n  function skipMultiLineComment() {\n    var start, loc, ch, comment;\n    if (extra.comments) {\n      start = index - 2;\n      loc = {\n        start: {\n          line: lineNumber,\n          column: index - lineStart - 2\n        }\n      };\n    }\n    while (index < length) {\n      ch = source.charCodeAt(index);\n      if (isLineTerminator(ch)) {\n        if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {\n          ++index;\n        }\n        hasLineTerminator = true;\n        ++lineNumber;\n        ++index;\n        lineStart = index;\n      } else if (ch === 0x2A) {\n        // Block comment ends with '*/'.\n        if (source.charCodeAt(index + 1) === 0x2F) {\n          ++index;\n          ++index;\n          if (extra.comments) {\n            comment = source.slice(start + 2, index - 2);\n            loc.end = {\n              line: lineNumber,\n              column: index - lineStart\n            };\n            addComment('Block', comment, start, index, loc);\n          }\n          return;\n        }\n        ++index;\n      } else {\n        ++index;\n      }\n    }\n\n    // Ran off the end of the file - the whole thing is a comment\n    if (extra.comments) {\n      loc.end = {\n        line: lineNumber,\n        column: index - lineStart\n      };\n      comment = source.slice(start + 2, index);\n      addComment('Block', comment, start, index, loc);\n    }\n    tolerateUnexpectedToken();\n  }\n  function skipComment() {\n    var ch, start;\n    hasLineTerminator = false;\n    start = index === 0;\n    while (index < length) {\n      ch = source.charCodeAt(index);\n      if (isWhiteSpace(ch)) {\n        ++index;\n      } else if (isLineTerminator(ch)) {\n        hasLineTerminator = true;\n        ++index;\n        if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n          ++index;\n        }\n        ++lineNumber;\n        lineStart = index;\n        start = true;\n      } else if (ch === 0x2F) {\n        // U+002F is '/'\n        ch = source.charCodeAt(index + 1);\n        if (ch === 0x2F) {\n          ++index;\n          ++index;\n          skipSingleLineComment(2);\n          start = true;\n        } else if (ch === 0x2A) {\n          // U+002A is '*'\n          ++index;\n          ++index;\n          skipMultiLineComment();\n        } else {\n          break;\n        }\n      } else if (start && ch === 0x2D) {\n        // U+002D is '-'\n        // U+003E is '>'\n        if (source.charCodeAt(index + 1) === 0x2D && source.charCodeAt(index + 2) === 0x3E) {\n          // '-->' is a single-line comment\n          index += 3;\n          skipSingleLineComment(3);\n        } else {\n          break;\n        }\n      } else if (ch === 0x3C) {\n        // U+003C is '<'\n        if (source.slice(index + 1, index + 4) === '!--') {\n          ++index; // `<`\n          ++index; // `!`\n          ++index; // `-`\n          ++index; // `-`\n          skipSingleLineComment(4);\n        } else {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n  }\n  function scanHexEscape(prefix) {\n    var i,\n      len,\n      ch,\n      code = 0;\n    len = prefix === 'u' ? 4 : 2;\n    for (i = 0; i < len; ++i) {\n      if (index < length && isHexDigit(source[index])) {\n        ch = source[index++];\n        code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      } else {\n        return '';\n      }\n    }\n    return String.fromCharCode(code);\n  }\n  function scanUnicodeCodePointEscape() {\n    var ch, code;\n    ch = source[index];\n    code = 0;\n\n    // At least, one hex digit is required.\n    if (ch === '}') {\n      throwUnexpectedToken();\n    }\n    while (index < length) {\n      ch = source[index++];\n      if (!isHexDigit(ch)) {\n        break;\n      }\n      code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n    }\n    if (code > 0x10FFFF || ch !== '}') {\n      throwUnexpectedToken();\n    }\n    return fromCodePoint(code);\n  }\n  function codePointAt(i) {\n    var cp, first, second;\n    cp = source.charCodeAt(i);\n    if (cp >= 0xD800 && cp <= 0xDBFF) {\n      second = source.charCodeAt(i + 1);\n      if (second >= 0xDC00 && second <= 0xDFFF) {\n        first = cp;\n        cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n      }\n    }\n    return cp;\n  }\n  function getComplexIdentifier() {\n    var cp, ch, id;\n    cp = codePointAt(index);\n    id = fromCodePoint(cp);\n    index += id.length;\n\n    // '\\u' (U+005C, U+0075) denotes an escaped character.\n    if (cp === 0x5C) {\n      if (source.charCodeAt(index) !== 0x75) {\n        throwUnexpectedToken();\n      }\n      ++index;\n      if (source[index] === '{') {\n        ++index;\n        ch = scanUnicodeCodePointEscape();\n      } else {\n        ch = scanHexEscape('u');\n        cp = ch.charCodeAt(0);\n        if (!ch || ch === '\\\\' || !isIdentifierStart(cp)) {\n          throwUnexpectedToken();\n        }\n      }\n      id = ch;\n    }\n    while (index < length) {\n      cp = codePointAt(index);\n      if (!isIdentifierPart(cp)) {\n        break;\n      }\n      ch = fromCodePoint(cp);\n      id += ch;\n      index += ch.length;\n\n      // '\\u' (U+005C, U+0075) denotes an escaped character.\n      if (cp === 0x5C) {\n        id = id.substr(0, id.length - 1);\n        if (source.charCodeAt(index) !== 0x75) {\n          throwUnexpectedToken();\n        }\n        ++index;\n        if (source[index] === '{') {\n          ++index;\n          ch = scanUnicodeCodePointEscape();\n        } else {\n          ch = scanHexEscape('u');\n          cp = ch.charCodeAt(0);\n          if (!ch || ch === '\\\\' || !isIdentifierPart(cp)) {\n            throwUnexpectedToken();\n          }\n        }\n        id += ch;\n      }\n    }\n    return id;\n  }\n  function getIdentifier() {\n    var start, ch;\n    start = index++;\n    while (index < length) {\n      ch = source.charCodeAt(index);\n      if (ch === 0x5C) {\n        // Blackslash (U+005C) marks Unicode escape sequence.\n        index = start;\n        return getComplexIdentifier();\n      } else if (ch >= 0xD800 && ch < 0xDFFF) {\n        // Need to handle surrogate pairs.\n        index = start;\n        return getComplexIdentifier();\n      }\n      if (isIdentifierPart(ch)) {\n        ++index;\n      } else {\n        break;\n      }\n    }\n    return source.slice(start, index);\n  }\n  function scanIdentifier() {\n    var start, id, type;\n    start = index;\n\n    // Backslash (U+005C) starts an escaped character.\n    id = source.charCodeAt(index) === 0x5C ? getComplexIdentifier() : getIdentifier();\n\n    // There is no keyword or literal with only one character.\n    // Thus, it must be an identifier.\n    if (id.length === 1) {\n      type = Token.Identifier;\n    } else if (isKeyword(id)) {\n      type = Token.Keyword;\n    } else if (id === 'null') {\n      type = Token.NullLiteral;\n    } else if (id === 'true' || id === 'false') {\n      type = Token.BooleanLiteral;\n    } else {\n      type = Token.Identifier;\n    }\n    return {\n      type: type,\n      value: id,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n\n  // ECMA-262 11.7 Punctuators\n\n  function scanPunctuator() {\n    var token, str;\n    token = {\n      type: Token.Punctuator,\n      value: '',\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: index,\n      end: index\n    };\n\n    // Check for most common single-character punctuators.\n    str = source[index];\n    switch (str) {\n      case '(':\n        if (extra.tokenize) {\n          extra.openParenToken = extra.tokenValues.length;\n        }\n        ++index;\n        break;\n      case '{':\n        if (extra.tokenize) {\n          extra.openCurlyToken = extra.tokenValues.length;\n        }\n        state.curlyStack.push('{');\n        ++index;\n        break;\n      case '.':\n        ++index;\n        if (source[index] === '.' && source[index + 1] === '.') {\n          // Spread operator: ...\n          index += 2;\n          str = '...';\n        }\n        break;\n      case '}':\n        ++index;\n        state.curlyStack.pop();\n        break;\n      case ')':\n      case ';':\n      case ',':\n      case '[':\n      case ']':\n      case ':':\n      case '?':\n      case '~':\n        ++index;\n        break;\n      default:\n        // 4-character punctuator.\n        str = source.substr(index, 4);\n        if (str === '>>>=') {\n          index += 4;\n        } else {\n          // 3-character punctuators.\n          str = str.substr(0, 3);\n          if (str === '===' || str === '!==' || str === '>>>' || str === '<<=' || str === '>>=') {\n            index += 3;\n          } else {\n            // 2-character punctuators.\n            str = str.substr(0, 2);\n            if (str === '&&' || str === '||' || str === '==' || str === '!=' || str === '+=' || str === '-=' || str === '*=' || str === '/=' || str === '++' || str === '--' || str === '<<' || str === '>>' || str === '&=' || str === '|=' || str === '^=' || str === '%=' || str === '<=' || str === '>=' || str === '=>') {\n              index += 2;\n            } else {\n              // 1-character punctuators.\n              str = source[index];\n              if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {\n                ++index;\n              }\n            }\n          }\n        }\n    }\n    if (index === token.start) {\n      throwUnexpectedToken();\n    }\n    token.end = index;\n    token.value = str;\n    return token;\n  }\n\n  // ECMA-262 11.8.3 Numeric Literals\n\n  function scanHexLiteral(start) {\n    var number = '';\n    while (index < length) {\n      if (!isHexDigit(source[index])) {\n        break;\n      }\n      number += source[index++];\n    }\n    if (number.length === 0) {\n      throwUnexpectedToken();\n    }\n    if (isIdentifierStart(source.charCodeAt(index))) {\n      throwUnexpectedToken();\n    }\n    return {\n      type: Token.NumericLiteral,\n      value: parseInt('0x' + number, 16),\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n  function scanBinaryLiteral(start) {\n    var ch, number;\n    number = '';\n    while (index < length) {\n      ch = source[index];\n      if (ch !== '0' && ch !== '1') {\n        break;\n      }\n      number += source[index++];\n    }\n    if (number.length === 0) {\n      // only 0b or 0B\n      throwUnexpectedToken();\n    }\n    if (index < length) {\n      ch = source.charCodeAt(index);\n      /* istanbul ignore else */\n      if (isIdentifierStart(ch) || isDecimalDigit(ch)) {\n        throwUnexpectedToken();\n      }\n    }\n    return {\n      type: Token.NumericLiteral,\n      value: parseInt(number, 2),\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n  function scanOctalLiteral(prefix, start) {\n    var number, octal;\n    if (isOctalDigit(prefix)) {\n      octal = true;\n      number = '0' + source[index++];\n    } else {\n      octal = false;\n      ++index;\n      number = '';\n    }\n    while (index < length) {\n      if (!isOctalDigit(source[index])) {\n        break;\n      }\n      number += source[index++];\n    }\n    if (!octal && number.length === 0) {\n      // only 0o or 0O\n      throwUnexpectedToken();\n    }\n    if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n      throwUnexpectedToken();\n    }\n    return {\n      type: Token.NumericLiteral,\n      value: parseInt(number, 8),\n      octal: octal,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n  function isImplicitOctalLiteral() {\n    var i, ch;\n\n    // Implicit octal, unless there is a non-octal digit.\n    // (Annex B.1.1 on Numeric Literals)\n    for (i = index + 1; i < length; ++i) {\n      ch = source[i];\n      if (ch === '8' || ch === '9') {\n        return false;\n      }\n      if (!isOctalDigit(ch)) {\n        return true;\n      }\n    }\n    return true;\n  }\n  function scanNumericLiteral() {\n    var number, start, ch;\n    ch = source[index];\n    assert(isDecimalDigit(ch.charCodeAt(0)) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');\n    start = index;\n    number = '';\n    if (ch !== '.') {\n      number = source[index++];\n      ch = source[index];\n\n      // Hex number starts with '0x'.\n      // Octal number starts with '0'.\n      // Octal number in ES6 starts with '0o'.\n      // Binary number in ES6 starts with '0b'.\n      if (number === '0') {\n        if (ch === 'x' || ch === 'X') {\n          ++index;\n          return scanHexLiteral(start);\n        }\n        if (ch === 'b' || ch === 'B') {\n          ++index;\n          return scanBinaryLiteral(start);\n        }\n        if (ch === 'o' || ch === 'O') {\n          return scanOctalLiteral(ch, start);\n        }\n        if (isOctalDigit(ch)) {\n          if (isImplicitOctalLiteral()) {\n            return scanOctalLiteral(ch, start);\n          }\n        }\n      }\n      while (isDecimalDigit(source.charCodeAt(index))) {\n        number += source[index++];\n      }\n      ch = source[index];\n    }\n    if (ch === '.') {\n      number += source[index++];\n      while (isDecimalDigit(source.charCodeAt(index))) {\n        number += source[index++];\n      }\n      ch = source[index];\n    }\n    if (ch === 'e' || ch === 'E') {\n      number += source[index++];\n      ch = source[index];\n      if (ch === '+' || ch === '-') {\n        number += source[index++];\n      }\n      if (isDecimalDigit(source.charCodeAt(index))) {\n        while (isDecimalDigit(source.charCodeAt(index))) {\n          number += source[index++];\n        }\n      } else {\n        throwUnexpectedToken();\n      }\n    }\n    if (isIdentifierStart(source.charCodeAt(index))) {\n      throwUnexpectedToken();\n    }\n    return {\n      type: Token.NumericLiteral,\n      value: parseFloat(number),\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n\n  // ECMA-262 11.8.4 String Literals\n\n  function scanStringLiteral() {\n    var str = '',\n      quote,\n      start,\n      ch,\n      unescaped,\n      octToDec,\n      octal = false;\n    quote = source[index];\n    assert(quote === '\\'' || quote === '\"', 'String literal must starts with a quote');\n    start = index;\n    ++index;\n    while (index < length) {\n      ch = source[index++];\n      if (ch === quote) {\n        quote = '';\n        break;\n      } else if (ch === '\\\\') {\n        ch = source[index++];\n        if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n          switch (ch) {\n            case 'u':\n            case 'x':\n              if (source[index] === '{') {\n                ++index;\n                str += scanUnicodeCodePointEscape();\n              } else {\n                unescaped = scanHexEscape(ch);\n                if (!unescaped) {\n                  throw throwUnexpectedToken();\n                }\n                str += unescaped;\n              }\n              break;\n            case 'n':\n              str += '\\n';\n              break;\n            case 'r':\n              str += '\\r';\n              break;\n            case 't':\n              str += '\\t';\n              break;\n            case 'b':\n              str += '\\b';\n              break;\n            case 'f':\n              str += '\\f';\n              break;\n            case 'v':\n              str += '\\x0B';\n              break;\n            case '8':\n            case '9':\n              str += ch;\n              tolerateUnexpectedToken();\n              break;\n            default:\n              if (isOctalDigit(ch)) {\n                octToDec = octalToDecimal(ch);\n                octal = octToDec.octal || octal;\n                str += String.fromCharCode(octToDec.code);\n              } else {\n                str += ch;\n              }\n              break;\n          }\n        } else {\n          ++lineNumber;\n          if (ch === '\\r' && source[index] === '\\n') {\n            ++index;\n          }\n          lineStart = index;\n        }\n      } else if (isLineTerminator(ch.charCodeAt(0))) {\n        break;\n      } else {\n        str += ch;\n      }\n    }\n    if (quote !== '') {\n      index = start;\n      throwUnexpectedToken();\n    }\n    return {\n      type: Token.StringLiteral,\n      value: str,\n      octal: octal,\n      lineNumber: startLineNumber,\n      lineStart: startLineStart,\n      start: start,\n      end: index\n    };\n  }\n\n  // ECMA-262 11.8.6 Template Literal Lexical Components\n\n  function scanTemplate() {\n    var cooked = '',\n      ch,\n      start,\n      rawOffset,\n      terminated,\n      head,\n      tail,\n      restore,\n      unescaped;\n    terminated = false;\n    tail = false;\n    start = index;\n    head = source[index] === '`';\n    rawOffset = 2;\n    ++index;\n    while (index < length) {\n      ch = source[index++];\n      if (ch === '`') {\n        rawOffset = 1;\n        tail = true;\n        terminated = true;\n        break;\n      } else if (ch === '$') {\n        if (source[index] === '{') {\n          state.curlyStack.push('${');\n          ++index;\n          terminated = true;\n          break;\n        }\n        cooked += ch;\n      } else if (ch === '\\\\') {\n        ch = source[index++];\n        if (!isLineTerminator(ch.charCodeAt(0))) {\n          switch (ch) {\n            case 'n':\n              cooked += '\\n';\n              break;\n            case 'r':\n              cooked += '\\r';\n              break;\n            case 't':\n              cooked += '\\t';\n              break;\n            case 'u':\n            case 'x':\n              if (source[index] === '{') {\n                ++index;\n                cooked += scanUnicodeCodePointEscape();\n              } else {\n                restore = index;\n                unescaped = scanHexEscape(ch);\n                if (unescaped) {\n                  cooked += unescaped;\n                } else {\n                  index = restore;\n                  cooked += ch;\n                }\n              }\n              break;\n            case 'b':\n              cooked += '\\b';\n              break;\n            case 'f':\n              cooked += '\\f';\n              break;\n            case 'v':\n              cooked += '\\v';\n              break;\n            default:\n              if (ch === '0') {\n                if (isDecimalDigit(source.charCodeAt(index))) {\n                  // Illegal: \\01 \\02 and so on\n                  throwError(Messages.TemplateOctalLiteral);\n                }\n                cooked += '\\0';\n              } else if (isOctalDigit(ch)) {\n                // Illegal: \\1 \\2\n                throwError(Messages.TemplateOctalLiteral);\n              } else {\n                cooked += ch;\n              }\n              break;\n          }\n        } else {\n          ++lineNumber;\n          if (ch === '\\r' && source[index] === '\\n') {\n            ++index;\n          }\n          lineStart = index;\n        }\n      } else if (isLineTerminator(ch.charCodeAt(0))) {\n        ++lineNumber;\n        if (ch === '\\r' && source[index] === '\\n') {\n          ++index;\n        }\n        lineStart = index;\n        cooked += '\\n';\n      } else {\n        cooked += ch;\n      }\n    }\n    if (!terminated) {\n      throwUnexpectedToken();\n    }\n    if (!head) {\n      state.curlyStack.pop();\n    }\n    return {\n      type: Token.Template,\n      value: {\n        cooked: cooked,\n        raw: source.slice(start + 1, index - rawOffset)\n      },\n      head: head,\n      tail: tail,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n\n  // ECMA-262 11.8.5 Regular Expression Literals\n\n  function testRegExp(pattern, flags) {\n    // The BMP character to use as a replacement for astral symbols when\n    // translating an ES6 \"u\"-flagged pattern to an ES5-compatible\n    // approximation.\n    // Note: replacing with '\\uFFFF' enables false positives in unlikely\n    // scenarios. For example, `[\\u{1044f}-\\u{10440}]` is an invalid\n    // pattern that would not be detected by this substitution.\n    var astralSubstitute = '\\uFFFF',\n      tmp = pattern;\n    if (flags.indexOf('u') >= 0) {\n      tmp = tmp\n      // Replace every Unicode escape sequence with the equivalent\n      // BMP character or a constant ASCII code point in the case of\n      // astral symbols. (See the above note on `astralSubstitute`\n      // for more information.)\n      .replace(/\\\\u\\{([0-9a-fA-F]+)\\}|\\\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {\n        var codePoint = parseInt($1 || $2, 16);\n        if (codePoint > 0x10FFFF) {\n          throwUnexpectedToken(null, Messages.InvalidRegExp);\n        }\n        if (codePoint <= 0xFFFF) {\n          return String.fromCharCode(codePoint);\n        }\n        return astralSubstitute;\n      })\n      // Replace each paired surrogate with a single ASCII symbol to\n      // avoid throwing on regular expressions that are only valid in\n      // combination with the \"u\" flag.\n      .replace(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, astralSubstitute);\n    }\n\n    // First, detect invalid regular expressions.\n    try {\n      RegExp(tmp);\n    } catch (e) {\n      throwUnexpectedToken(null, Messages.InvalidRegExp);\n    }\n\n    // Return a regular expression object for this pattern-flag pair, or\n    // `null` in case the current environment doesn't support the flags it\n    // uses.\n    try {\n      return new RegExp(pattern, flags);\n    } catch (exception) {\n      /* istanbul ignore next */\n      return null;\n    }\n  }\n  function scanRegExpBody() {\n    var ch, str, classMarker, terminated, body;\n    ch = source[index];\n    assert(ch === '/', 'Regular expression literal must start with a slash');\n    str = source[index++];\n    classMarker = false;\n    terminated = false;\n    while (index < length) {\n      ch = source[index++];\n      str += ch;\n      if (ch === '\\\\') {\n        ch = source[index++];\n        // ECMA-262 7.8.5\n        if (isLineTerminator(ch.charCodeAt(0))) {\n          throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n        }\n        str += ch;\n      } else if (isLineTerminator(ch.charCodeAt(0))) {\n        throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n      } else if (classMarker) {\n        if (ch === ']') {\n          classMarker = false;\n        }\n      } else {\n        if (ch === '/') {\n          terminated = true;\n          break;\n        } else if (ch === '[') {\n          classMarker = true;\n        }\n      }\n    }\n    if (!terminated) {\n      throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n    }\n\n    // Exclude leading and trailing slash.\n    body = str.substr(1, str.length - 2);\n    return {\n      value: body,\n      literal: str\n    };\n  }\n  function scanRegExpFlags() {\n    var ch, str, flags, restore;\n    str = '';\n    flags = '';\n    while (index < length) {\n      ch = source[index];\n      if (!isIdentifierPart(ch.charCodeAt(0))) {\n        break;\n      }\n      ++index;\n      if (ch === '\\\\' && index < length) {\n        ch = source[index];\n        if (ch === 'u') {\n          ++index;\n          restore = index;\n          ch = scanHexEscape('u');\n          if (ch) {\n            flags += ch;\n            for (str += '\\\\u'; restore < index; ++restore) {\n              str += source[restore];\n            }\n          } else {\n            index = restore;\n            flags += 'u';\n            str += '\\\\u';\n          }\n          tolerateUnexpectedToken();\n        } else {\n          str += '\\\\';\n          tolerateUnexpectedToken();\n        }\n      } else {\n        flags += ch;\n        str += ch;\n      }\n    }\n    return {\n      value: flags,\n      literal: str\n    };\n  }\n  function scanRegExp() {\n    var start, body, flags, value;\n    scanning = true;\n    lookahead = null;\n    skipComment();\n    start = index;\n    body = scanRegExpBody();\n    flags = scanRegExpFlags();\n    value = testRegExp(body.value, flags.value);\n    scanning = false;\n    if (extra.tokenize) {\n      return {\n        type: Token.RegularExpression,\n        value: value,\n        regex: {\n          pattern: body.value,\n          flags: flags.value\n        },\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        start: start,\n        end: index\n      };\n    }\n    return {\n      literal: body.literal + flags.literal,\n      value: value,\n      regex: {\n        pattern: body.value,\n        flags: flags.value\n      },\n      start: start,\n      end: index\n    };\n  }\n  function collectRegex() {\n    var pos, loc, regex, token;\n    skipComment();\n    pos = index;\n    loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart\n      }\n    };\n    regex = scanRegExp();\n    loc.end = {\n      line: lineNumber,\n      column: index - lineStart\n    };\n\n    /* istanbul ignore next */\n    if (!extra.tokenize) {\n      // Pop the previous token, which is likely '/' or '/='\n      if (extra.tokens.length > 0) {\n        token = extra.tokens[extra.tokens.length - 1];\n        if (token.range[0] === pos && token.type === 'Punctuator') {\n          if (token.value === '/' || token.value === '/=') {\n            extra.tokens.pop();\n          }\n        }\n      }\n      extra.tokens.push({\n        type: 'RegularExpression',\n        value: regex.literal,\n        regex: regex.regex,\n        range: [pos, index],\n        loc: loc\n      });\n    }\n    return regex;\n  }\n  function isIdentifierName(token) {\n    return token.type === Token.Identifier || token.type === Token.Keyword || token.type === Token.BooleanLiteral || token.type === Token.NullLiteral;\n  }\n\n  // Using the following algorithm:\n  // https://github.com/mozilla/sweet.js/wiki/design\n\n  function advanceSlash() {\n    var regex, previous, check;\n    function testKeyword(value) {\n      return value && value.length > 1 && value[0] >= 'a' && value[0] <= 'z';\n    }\n    previous = extra.tokenValues[extra.tokenValues.length - 1];\n    regex = previous !== null;\n    switch (previous) {\n      case 'this':\n      case ']':\n        regex = false;\n        break;\n      case ')':\n        check = extra.tokenValues[extra.openParenToken - 1];\n        regex = check === 'if' || check === 'while' || check === 'for' || check === 'with';\n        break;\n      case '}':\n        // Dividing a function by anything makes little sense,\n        // but we have to check for that.\n        regex = false;\n        if (testKeyword(extra.tokenValues[extra.openCurlyToken - 3])) {\n          // Anonymous function, e.g. function(){} /42\n          check = extra.tokenValues[extra.openCurlyToken - 4];\n          regex = check ? FnExprTokens.indexOf(check) < 0 : false;\n        } else if (testKeyword(extra.tokenValues[extra.openCurlyToken - 4])) {\n          // Named function, e.g. function f(){} /42/\n          check = extra.tokenValues[extra.openCurlyToken - 5];\n          regex = check ? FnExprTokens.indexOf(check) < 0 : true;\n        }\n    }\n    return regex ? collectRegex() : scanPunctuator();\n  }\n  function advance() {\n    var cp, token;\n    if (index >= length) {\n      return {\n        type: Token.EOF,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        start: index,\n        end: index\n      };\n    }\n    cp = source.charCodeAt(index);\n    if (isIdentifierStart(cp)) {\n      token = scanIdentifier();\n      if (strict && isStrictModeReservedWord(token.value)) {\n        token.type = Token.Keyword;\n      }\n      return token;\n    }\n\n    // Very common: ( and ) and ;\n    if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {\n      return scanPunctuator();\n    }\n\n    // String literal starts with single quote (U+0027) or double quote (U+0022).\n    if (cp === 0x27 || cp === 0x22) {\n      return scanStringLiteral();\n    }\n\n    // Dot (.) U+002E can also start a floating-point number, hence the need\n    // to check the next character.\n    if (cp === 0x2E) {\n      if (isDecimalDigit(source.charCodeAt(index + 1))) {\n        return scanNumericLiteral();\n      }\n      return scanPunctuator();\n    }\n    if (isDecimalDigit(cp)) {\n      return scanNumericLiteral();\n    }\n\n    // Slash (/) U+002F can also start a regex.\n    if (extra.tokenize && cp === 0x2F) {\n      return advanceSlash();\n    }\n\n    // Template literals start with ` (U+0060) for template head\n    // or } (U+007D) for template middle or template tail.\n    if (cp === 0x60 || cp === 0x7D && state.curlyStack[state.curlyStack.length - 1] === '${') {\n      return scanTemplate();\n    }\n\n    // Possible identifier start in a surrogate pair.\n    if (cp >= 0xD800 && cp < 0xDFFF) {\n      cp = codePointAt(index);\n      if (isIdentifierStart(cp)) {\n        return scanIdentifier();\n      }\n    }\n    return scanPunctuator();\n  }\n  function collectToken() {\n    var loc, token, value, entry;\n    loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart\n      }\n    };\n    token = advance();\n    loc.end = {\n      line: lineNumber,\n      column: index - lineStart\n    };\n    if (token.type !== Token.EOF) {\n      value = source.slice(token.start, token.end);\n      entry = {\n        type: TokenName[token.type],\n        value: value,\n        range: [token.start, token.end],\n        loc: loc\n      };\n      if (token.regex) {\n        entry.regex = {\n          pattern: token.regex.pattern,\n          flags: token.regex.flags\n        };\n      }\n      if (extra.tokenValues) {\n        extra.tokenValues.push(entry.type === 'Punctuator' || entry.type === 'Keyword' ? entry.value : null);\n      }\n      if (extra.tokenize) {\n        if (!extra.range) {\n          delete entry.range;\n        }\n        if (!extra.loc) {\n          delete entry.loc;\n        }\n        if (extra.delegate) {\n          entry = extra.delegate(entry);\n        }\n      }\n      extra.tokens.push(entry);\n    }\n    return token;\n  }\n  function lex() {\n    var token;\n    scanning = true;\n    lastIndex = index;\n    lastLineNumber = lineNumber;\n    lastLineStart = lineStart;\n    skipComment();\n    token = lookahead;\n    startIndex = index;\n    startLineNumber = lineNumber;\n    startLineStart = lineStart;\n    lookahead = typeof extra.tokens !== 'undefined' ? collectToken() : advance();\n    scanning = false;\n    return token;\n  }\n  function peek() {\n    scanning = true;\n    skipComment();\n    lastIndex = index;\n    lastLineNumber = lineNumber;\n    lastLineStart = lineStart;\n    startIndex = index;\n    startLineNumber = lineNumber;\n    startLineStart = lineStart;\n    lookahead = typeof extra.tokens !== 'undefined' ? collectToken() : advance();\n    scanning = false;\n  }\n  function Position() {\n    this.line = startLineNumber;\n    this.column = startIndex - startLineStart;\n  }\n  function SourceLocation() {\n    this.start = new Position();\n    this.end = null;\n  }\n  function WrappingSourceLocation(startToken) {\n    this.start = {\n      line: startToken.lineNumber,\n      column: startToken.start - startToken.lineStart\n    };\n    this.end = null;\n  }\n  function Node() {\n    if (extra.range) {\n      this.range = [startIndex, 0];\n    }\n    if (extra.loc) {\n      this.loc = new SourceLocation();\n    }\n  }\n  function WrappingNode(startToken) {\n    if (extra.range) {\n      this.range = [startToken.start, 0];\n    }\n    if (extra.loc) {\n      this.loc = new WrappingSourceLocation(startToken);\n    }\n  }\n  WrappingNode.prototype = Node.prototype = {\n    processComment: function () {\n      var lastChild,\n        innerComments,\n        leadingComments,\n        trailingComments,\n        bottomRight = extra.bottomRightStack,\n        i,\n        comment,\n        last = bottomRight[bottomRight.length - 1];\n      if (this.type === Syntax.Program) {\n        if (this.body.length > 0) {\n          return;\n        }\n      }\n      /**\n       * patch innnerComments for properties empty block\n       * `function a() {/** comments **\\/}`\n       */\n\n      if (this.type === Syntax.BlockStatement && this.body.length === 0) {\n        innerComments = [];\n        for (i = extra.leadingComments.length - 1; i >= 0; --i) {\n          comment = extra.leadingComments[i];\n          if (this.range[1] >= comment.range[1]) {\n            innerComments.unshift(comment);\n            extra.leadingComments.splice(i, 1);\n            extra.trailingComments.splice(i, 1);\n          }\n        }\n        if (innerComments.length) {\n          this.innerComments = innerComments;\n          //bottomRight.push(this);\n          return;\n        }\n      }\n      if (extra.trailingComments.length > 0) {\n        trailingComments = [];\n        for (i = extra.trailingComments.length - 1; i >= 0; --i) {\n          comment = extra.trailingComments[i];\n          if (comment.range[0] >= this.range[1]) {\n            trailingComments.unshift(comment);\n            extra.trailingComments.splice(i, 1);\n          }\n        }\n        extra.trailingComments = [];\n      } else {\n        if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {\n          trailingComments = last.trailingComments;\n          delete last.trailingComments;\n        }\n      }\n\n      // Eating the stack.\n      while (last && last.range[0] >= this.range[0]) {\n        lastChild = bottomRight.pop();\n        last = bottomRight[bottomRight.length - 1];\n      }\n      if (lastChild) {\n        if (lastChild.leadingComments) {\n          leadingComments = [];\n          for (i = lastChild.leadingComments.length - 1; i >= 0; --i) {\n            comment = lastChild.leadingComments[i];\n            if (comment.range[1] <= this.range[0]) {\n              leadingComments.unshift(comment);\n              lastChild.leadingComments.splice(i, 1);\n            }\n          }\n          if (!lastChild.leadingComments.length) {\n            lastChild.leadingComments = undefined;\n          }\n        }\n      } else if (extra.leadingComments.length > 0) {\n        leadingComments = [];\n        for (i = extra.leadingComments.length - 1; i >= 0; --i) {\n          comment = extra.leadingComments[i];\n          if (comment.range[1] <= this.range[0]) {\n            leadingComments.unshift(comment);\n            extra.leadingComments.splice(i, 1);\n          }\n        }\n      }\n      if (leadingComments && leadingComments.length > 0) {\n        this.leadingComments = leadingComments;\n      }\n      if (trailingComments && trailingComments.length > 0) {\n        this.trailingComments = trailingComments;\n      }\n      bottomRight.push(this);\n    },\n    finish: function () {\n      if (extra.range) {\n        this.range[1] = lastIndex;\n      }\n      if (extra.loc) {\n        this.loc.end = {\n          line: lastLineNumber,\n          column: lastIndex - lastLineStart\n        };\n        if (extra.source) {\n          this.loc.source = extra.source;\n        }\n      }\n      if (extra.attachComment) {\n        this.processComment();\n      }\n    },\n    finishArrayExpression: function (elements) {\n      this.type = Syntax.ArrayExpression;\n      this.elements = elements;\n      this.finish();\n      return this;\n    },\n    finishArrayPattern: function (elements) {\n      this.type = Syntax.ArrayPattern;\n      this.elements = elements;\n      this.finish();\n      return this;\n    },\n    finishArrowFunctionExpression: function (params, defaults, body, expression) {\n      this.type = Syntax.ArrowFunctionExpression;\n      this.id = null;\n      this.params = params;\n      this.defaults = defaults;\n      this.body = body;\n      this.generator = false;\n      this.expression = expression;\n      this.finish();\n      return this;\n    },\n    finishAssignmentExpression: function (operator, left, right) {\n      this.type = Syntax.AssignmentExpression;\n      this.operator = operator;\n      this.left = left;\n      this.right = right;\n      this.finish();\n      return this;\n    },\n    finishAssignmentPattern: function (left, right) {\n      this.type = Syntax.AssignmentPattern;\n      this.left = left;\n      this.right = right;\n      this.finish();\n      return this;\n    },\n    finishBinaryExpression: function (operator, left, right) {\n      this.type = operator === '||' || operator === '&&' ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n      this.operator = operator;\n      this.left = left;\n      this.right = right;\n      this.finish();\n      return this;\n    },\n    finishBlockStatement: function (body) {\n      this.type = Syntax.BlockStatement;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishBreakStatement: function (label) {\n      this.type = Syntax.BreakStatement;\n      this.label = label;\n      this.finish();\n      return this;\n    },\n    finishCallExpression: function (callee, args) {\n      this.type = Syntax.CallExpression;\n      this.callee = callee;\n      this.arguments = args;\n      this.finish();\n      return this;\n    },\n    finishCatchClause: function (param, body) {\n      this.type = Syntax.CatchClause;\n      this.param = param;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishClassBody: function (body) {\n      this.type = Syntax.ClassBody;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishClassDeclaration: function (id, superClass, body) {\n      this.type = Syntax.ClassDeclaration;\n      this.id = id;\n      this.superClass = superClass;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishClassExpression: function (id, superClass, body) {\n      this.type = Syntax.ClassExpression;\n      this.id = id;\n      this.superClass = superClass;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishConditionalExpression: function (test, consequent, alternate) {\n      this.type = Syntax.ConditionalExpression;\n      this.test = test;\n      this.consequent = consequent;\n      this.alternate = alternate;\n      this.finish();\n      return this;\n    },\n    finishContinueStatement: function (label) {\n      this.type = Syntax.ContinueStatement;\n      this.label = label;\n      this.finish();\n      return this;\n    },\n    finishDebuggerStatement: function () {\n      this.type = Syntax.DebuggerStatement;\n      this.finish();\n      return this;\n    },\n    finishDoWhileStatement: function (body, test) {\n      this.type = Syntax.DoWhileStatement;\n      this.body = body;\n      this.test = test;\n      this.finish();\n      return this;\n    },\n    finishEmptyStatement: function () {\n      this.type = Syntax.EmptyStatement;\n      this.finish();\n      return this;\n    },\n    finishExpressionStatement: function (expression) {\n      this.type = Syntax.ExpressionStatement;\n      this.expression = expression;\n      this.finish();\n      return this;\n    },\n    finishForStatement: function (init, test, update, body) {\n      this.type = Syntax.ForStatement;\n      this.init = init;\n      this.test = test;\n      this.update = update;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishForOfStatement: function (left, right, body) {\n      this.type = Syntax.ForOfStatement;\n      this.left = left;\n      this.right = right;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishForInStatement: function (left, right, body) {\n      this.type = Syntax.ForInStatement;\n      this.left = left;\n      this.right = right;\n      this.body = body;\n      this.each = false;\n      this.finish();\n      return this;\n    },\n    finishFunctionDeclaration: function (id, params, defaults, body, generator) {\n      this.type = Syntax.FunctionDeclaration;\n      this.id = id;\n      this.params = params;\n      this.defaults = defaults;\n      this.body = body;\n      this.generator = generator;\n      this.expression = false;\n      this.finish();\n      return this;\n    },\n    finishFunctionExpression: function (id, params, defaults, body, generator) {\n      this.type = Syntax.FunctionExpression;\n      this.id = id;\n      this.params = params;\n      this.defaults = defaults;\n      this.body = body;\n      this.generator = generator;\n      this.expression = false;\n      this.finish();\n      return this;\n    },\n    finishIdentifier: function (name) {\n      this.type = Syntax.Identifier;\n      this.name = name;\n      this.finish();\n      return this;\n    },\n    finishIfStatement: function (test, consequent, alternate) {\n      this.type = Syntax.IfStatement;\n      this.test = test;\n      this.consequent = consequent;\n      this.alternate = alternate;\n      this.finish();\n      return this;\n    },\n    finishLabeledStatement: function (label, body) {\n      this.type = Syntax.LabeledStatement;\n      this.label = label;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishLiteral: function (token) {\n      this.type = Syntax.Literal;\n      this.value = token.value;\n      this.raw = source.slice(token.start, token.end);\n      if (token.regex) {\n        this.regex = token.regex;\n      }\n      this.finish();\n      return this;\n    },\n    finishMemberExpression: function (accessor, object, property) {\n      this.type = Syntax.MemberExpression;\n      this.computed = accessor === '[';\n      this.object = object;\n      this.property = property;\n      this.finish();\n      return this;\n    },\n    finishMetaProperty: function (meta, property) {\n      this.type = Syntax.MetaProperty;\n      this.meta = meta;\n      this.property = property;\n      this.finish();\n      return this;\n    },\n    finishNewExpression: function (callee, args) {\n      this.type = Syntax.NewExpression;\n      this.callee = callee;\n      this.arguments = args;\n      this.finish();\n      return this;\n    },\n    finishObjectExpression: function (properties) {\n      this.type = Syntax.ObjectExpression;\n      this.properties = properties;\n      this.finish();\n      return this;\n    },\n    finishObjectPattern: function (properties) {\n      this.type = Syntax.ObjectPattern;\n      this.properties = properties;\n      this.finish();\n      return this;\n    },\n    finishPostfixExpression: function (operator, argument) {\n      this.type = Syntax.UpdateExpression;\n      this.operator = operator;\n      this.argument = argument;\n      this.prefix = false;\n      this.finish();\n      return this;\n    },\n    finishProgram: function (body, sourceType) {\n      this.type = Syntax.Program;\n      this.body = body;\n      this.sourceType = sourceType;\n      this.finish();\n      return this;\n    },\n    finishProperty: function (kind, key, computed, value, method, shorthand) {\n      this.type = Syntax.Property;\n      this.key = key;\n      this.computed = computed;\n      this.value = value;\n      this.kind = kind;\n      this.method = method;\n      this.shorthand = shorthand;\n      this.finish();\n      return this;\n    },\n    finishRestElement: function (argument) {\n      this.type = Syntax.RestElement;\n      this.argument = argument;\n      this.finish();\n      return this;\n    },\n    finishReturnStatement: function (argument) {\n      this.type = Syntax.ReturnStatement;\n      this.argument = argument;\n      this.finish();\n      return this;\n    },\n    finishSequenceExpression: function (expressions) {\n      this.type = Syntax.SequenceExpression;\n      this.expressions = expressions;\n      this.finish();\n      return this;\n    },\n    finishSpreadElement: function (argument) {\n      this.type = Syntax.SpreadElement;\n      this.argument = argument;\n      this.finish();\n      return this;\n    },\n    finishSwitchCase: function (test, consequent) {\n      this.type = Syntax.SwitchCase;\n      this.test = test;\n      this.consequent = consequent;\n      this.finish();\n      return this;\n    },\n    finishSuper: function () {\n      this.type = Syntax.Super;\n      this.finish();\n      return this;\n    },\n    finishSwitchStatement: function (discriminant, cases) {\n      this.type = Syntax.SwitchStatement;\n      this.discriminant = discriminant;\n      this.cases = cases;\n      this.finish();\n      return this;\n    },\n    finishTaggedTemplateExpression: function (tag, quasi) {\n      this.type = Syntax.TaggedTemplateExpression;\n      this.tag = tag;\n      this.quasi = quasi;\n      this.finish();\n      return this;\n    },\n    finishTemplateElement: function (value, tail) {\n      this.type = Syntax.TemplateElement;\n      this.value = value;\n      this.tail = tail;\n      this.finish();\n      return this;\n    },\n    finishTemplateLiteral: function (quasis, expressions) {\n      this.type = Syntax.TemplateLiteral;\n      this.quasis = quasis;\n      this.expressions = expressions;\n      this.finish();\n      return this;\n    },\n    finishThisExpression: function () {\n      this.type = Syntax.ThisExpression;\n      this.finish();\n      return this;\n    },\n    finishThrowStatement: function (argument) {\n      this.type = Syntax.ThrowStatement;\n      this.argument = argument;\n      this.finish();\n      return this;\n    },\n    finishTryStatement: function (block, handler, finalizer) {\n      this.type = Syntax.TryStatement;\n      this.block = block;\n      this.guardedHandlers = [];\n      this.handlers = handler ? [handler] : [];\n      this.handler = handler;\n      this.finalizer = finalizer;\n      this.finish();\n      return this;\n    },\n    finishUnaryExpression: function (operator, argument) {\n      this.type = operator === '++' || operator === '--' ? Syntax.UpdateExpression : Syntax.UnaryExpression;\n      this.operator = operator;\n      this.argument = argument;\n      this.prefix = true;\n      this.finish();\n      return this;\n    },\n    finishVariableDeclaration: function (declarations) {\n      this.type = Syntax.VariableDeclaration;\n      this.declarations = declarations;\n      this.kind = 'var';\n      this.finish();\n      return this;\n    },\n    finishLexicalDeclaration: function (declarations, kind) {\n      this.type = Syntax.VariableDeclaration;\n      this.declarations = declarations;\n      this.kind = kind;\n      this.finish();\n      return this;\n    },\n    finishVariableDeclarator: function (id, init) {\n      this.type = Syntax.VariableDeclarator;\n      this.id = id;\n      this.init = init;\n      this.finish();\n      return this;\n    },\n    finishWhileStatement: function (test, body) {\n      this.type = Syntax.WhileStatement;\n      this.test = test;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishWithStatement: function (object, body) {\n      this.type = Syntax.WithStatement;\n      this.object = object;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishExportSpecifier: function (local, exported) {\n      this.type = Syntax.ExportSpecifier;\n      this.exported = exported || local;\n      this.local = local;\n      this.finish();\n      return this;\n    },\n    finishImportDefaultSpecifier: function (local) {\n      this.type = Syntax.ImportDefaultSpecifier;\n      this.local = local;\n      this.finish();\n      return this;\n    },\n    finishImportNamespaceSpecifier: function (local) {\n      this.type = Syntax.ImportNamespaceSpecifier;\n      this.local = local;\n      this.finish();\n      return this;\n    },\n    finishExportNamedDeclaration: function (declaration, specifiers, src) {\n      this.type = Syntax.ExportNamedDeclaration;\n      this.declaration = declaration;\n      this.specifiers = specifiers;\n      this.source = src;\n      this.finish();\n      return this;\n    },\n    finishExportDefaultDeclaration: function (declaration) {\n      this.type = Syntax.ExportDefaultDeclaration;\n      this.declaration = declaration;\n      this.finish();\n      return this;\n    },\n    finishExportAllDeclaration: function (src) {\n      this.type = Syntax.ExportAllDeclaration;\n      this.source = src;\n      this.finish();\n      return this;\n    },\n    finishImportSpecifier: function (local, imported) {\n      this.type = Syntax.ImportSpecifier;\n      this.local = local || imported;\n      this.imported = imported;\n      this.finish();\n      return this;\n    },\n    finishImportDeclaration: function (specifiers, src) {\n      this.type = Syntax.ImportDeclaration;\n      this.specifiers = specifiers;\n      this.source = src;\n      this.finish();\n      return this;\n    },\n    finishYieldExpression: function (argument, delegate) {\n      this.type = Syntax.YieldExpression;\n      this.argument = argument;\n      this.delegate = delegate;\n      this.finish();\n      return this;\n    }\n  };\n  function recordError(error) {\n    var e, existing;\n    for (e = 0; e < extra.errors.length; e++) {\n      existing = extra.errors[e];\n      // Prevent duplicated error.\n      /* istanbul ignore next */\n      if (existing.index === error.index && existing.message === error.message) {\n        return;\n      }\n    }\n    extra.errors.push(error);\n  }\n  function constructError(msg, column) {\n    var error = new Error(msg);\n    try {\n      throw error;\n    } catch (base) {\n      /* istanbul ignore else */\n      if (Object.create && Object.defineProperty) {\n        error = Object.create(base);\n        Object.defineProperty(error, 'column', {\n          value: column\n        });\n      }\n    } finally {\n      return error;\n    }\n  }\n  function createError(line, pos, description) {\n    var msg, column, error;\n    msg = 'Line ' + line + ': ' + description;\n    column = pos - (scanning ? lineStart : lastLineStart) + 1;\n    error = constructError(msg, column);\n    error.lineNumber = line;\n    error.description = description;\n    error.index = pos;\n    return error;\n  }\n\n  // Throw an exception\n\n  function throwError(messageFormat) {\n    var args, msg;\n    args = Array.prototype.slice.call(arguments, 1);\n    msg = messageFormat.replace(/%(\\d)/g, function (whole, idx) {\n      assert(idx < args.length, 'Message reference must be in range');\n      return args[idx];\n    });\n    throw createError(lastLineNumber, lastIndex, msg);\n  }\n  function tolerateError(messageFormat) {\n    var args, msg, error;\n    args = Array.prototype.slice.call(arguments, 1);\n    /* istanbul ignore next */\n    msg = messageFormat.replace(/%(\\d)/g, function (whole, idx) {\n      assert(idx < args.length, 'Message reference must be in range');\n      return args[idx];\n    });\n    error = createError(lineNumber, lastIndex, msg);\n    if (extra.errors) {\n      recordError(error);\n    } else {\n      throw error;\n    }\n  }\n\n  // Throw an exception because of the token.\n\n  function unexpectedTokenError(token, message) {\n    var value,\n      msg = message || Messages.UnexpectedToken;\n    if (token) {\n      if (!message) {\n        msg = token.type === Token.EOF ? Messages.UnexpectedEOS : token.type === Token.Identifier ? Messages.UnexpectedIdentifier : token.type === Token.NumericLiteral ? Messages.UnexpectedNumber : token.type === Token.StringLiteral ? Messages.UnexpectedString : token.type === Token.Template ? Messages.UnexpectedTemplate : Messages.UnexpectedToken;\n        if (token.type === Token.Keyword) {\n          if (isFutureReservedWord(token.value)) {\n            msg = Messages.UnexpectedReserved;\n          } else if (strict && isStrictModeReservedWord(token.value)) {\n            msg = Messages.StrictReservedWord;\n          }\n        }\n      }\n      value = token.type === Token.Template ? token.value.raw : token.value;\n    } else {\n      value = 'ILLEGAL';\n    }\n    msg = msg.replace('%0', value);\n    return token && typeof token.lineNumber === 'number' ? createError(token.lineNumber, token.start, msg) : createError(scanning ? lineNumber : lastLineNumber, scanning ? index : lastIndex, msg);\n  }\n  function throwUnexpectedToken(token, message) {\n    throw unexpectedTokenError(token, message);\n  }\n  function tolerateUnexpectedToken(token, message) {\n    var error = unexpectedTokenError(token, message);\n    if (extra.errors) {\n      recordError(error);\n    } else {\n      throw error;\n    }\n  }\n\n  // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n\n  function expect(value) {\n    var token = lex();\n    if (token.type !== Token.Punctuator || token.value !== value) {\n      throwUnexpectedToken(token);\n    }\n  }\n\n  /**\n   * @name expectCommaSeparator\n   * @description Quietly expect a comma when in tolerant mode, otherwise delegates\n   * to <code>expect(value)</code>\n   * @since 2.0\n   */\n  function expectCommaSeparator() {\n    var token;\n    if (extra.errors) {\n      token = lookahead;\n      if (token.type === Token.Punctuator && token.value === ',') {\n        lex();\n      } else if (token.type === Token.Punctuator && token.value === ';') {\n        lex();\n        tolerateUnexpectedToken(token);\n      } else {\n        tolerateUnexpectedToken(token, Messages.UnexpectedToken);\n      }\n    } else {\n      expect(',');\n    }\n  }\n\n  // Expect the next token to match the specified keyword.\n  // If not, an exception will be thrown.\n\n  function expectKeyword(keyword) {\n    var token = lex();\n    if (token.type !== Token.Keyword || token.value !== keyword) {\n      throwUnexpectedToken(token);\n    }\n  }\n\n  // Return true if the next token matches the specified punctuator.\n\n  function match(value) {\n    return lookahead.type === Token.Punctuator && lookahead.value === value;\n  }\n\n  // Return true if the next token matches the specified keyword\n\n  function matchKeyword(keyword) {\n    return lookahead.type === Token.Keyword && lookahead.value === keyword;\n  }\n\n  // Return true if the next token matches the specified contextual keyword\n  // (where an identifier is sometimes a keyword depending on the context)\n\n  function matchContextualKeyword(keyword) {\n    return lookahead.type === Token.Identifier && lookahead.value === keyword;\n  }\n\n  // Return true if the next token is an assignment operator\n\n  function matchAssign() {\n    var op;\n    if (lookahead.type !== Token.Punctuator) {\n      return false;\n    }\n    op = lookahead.value;\n    return op === '=' || op === '*=' || op === '/=' || op === '%=' || op === '+=' || op === '-=' || op === '<<=' || op === '>>=' || op === '>>>=' || op === '&=' || op === '^=' || op === '|=';\n  }\n  function consumeSemicolon() {\n    // Catch the very common case first: immediately a semicolon (U+003B).\n    if (source.charCodeAt(startIndex) === 0x3B || match(';')) {\n      lex();\n      return;\n    }\n    if (hasLineTerminator) {\n      return;\n    }\n\n    // FIXME(ikarienator): this is seemingly an issue in the previous location info convention.\n    lastIndex = startIndex;\n    lastLineNumber = startLineNumber;\n    lastLineStart = startLineStart;\n    if (lookahead.type !== Token.EOF && !match('}')) {\n      throwUnexpectedToken(lookahead);\n    }\n  }\n\n  // Cover grammar support.\n  //\n  // When an assignment expression position starts with an left parenthesis, the determination of the type\n  // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)\n  // or the first comma. This situation also defers the determination of all the expressions nested in the pair.\n  //\n  // There are three productions that can be parsed in a parentheses pair that needs to be determined\n  // after the outermost pair is closed. They are:\n  //\n  //   1. AssignmentExpression\n  //   2. BindingElements\n  //   3. AssignmentTargets\n  //\n  // In order to avoid exponential backtracking, we use two flags to denote if the production can be\n  // binding element or assignment target.\n  //\n  // The three productions have the relationship:\n  //\n  //   BindingElements  AssignmentTargets  AssignmentExpression\n  //\n  // with a single exception that CoverInitializedName when used directly in an Expression, generates\n  // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the\n  // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.\n  //\n  // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not\n  // effect the current flags. This means the production the parser parses is only used as an expression. Therefore\n  // the CoverInitializedName check is conducted.\n  //\n  // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates\n  // the flags outside of the parser. This means the production the parser parses is used as a part of a potential\n  // pattern. The CoverInitializedName check is deferred.\n  function isolateCoverGrammar(parser) {\n    var oldIsBindingElement = isBindingElement,\n      oldIsAssignmentTarget = isAssignmentTarget,\n      oldFirstCoverInitializedNameError = firstCoverInitializedNameError,\n      result;\n    isBindingElement = true;\n    isAssignmentTarget = true;\n    firstCoverInitializedNameError = null;\n    result = parser();\n    if (firstCoverInitializedNameError !== null) {\n      throwUnexpectedToken(firstCoverInitializedNameError);\n    }\n    isBindingElement = oldIsBindingElement;\n    isAssignmentTarget = oldIsAssignmentTarget;\n    firstCoverInitializedNameError = oldFirstCoverInitializedNameError;\n    return result;\n  }\n  function inheritCoverGrammar(parser) {\n    var oldIsBindingElement = isBindingElement,\n      oldIsAssignmentTarget = isAssignmentTarget,\n      oldFirstCoverInitializedNameError = firstCoverInitializedNameError,\n      result;\n    isBindingElement = true;\n    isAssignmentTarget = true;\n    firstCoverInitializedNameError = null;\n    result = parser();\n    isBindingElement = isBindingElement && oldIsBindingElement;\n    isAssignmentTarget = isAssignmentTarget && oldIsAssignmentTarget;\n    firstCoverInitializedNameError = oldFirstCoverInitializedNameError || firstCoverInitializedNameError;\n    return result;\n  }\n\n  // ECMA-262 13.3.3 Destructuring Binding Patterns\n\n  function parseArrayPattern(params, kind) {\n    var node = new Node(),\n      elements = [],\n      rest,\n      restNode;\n    expect('[');\n    while (!match(']')) {\n      if (match(',')) {\n        lex();\n        elements.push(null);\n      } else {\n        if (match('...')) {\n          restNode = new Node();\n          lex();\n          params.push(lookahead);\n          rest = parseVariableIdentifier(kind);\n          elements.push(restNode.finishRestElement(rest));\n          break;\n        } else {\n          elements.push(parsePatternWithDefault(params, kind));\n        }\n        if (!match(']')) {\n          expect(',');\n        }\n      }\n    }\n    expect(']');\n    return node.finishArrayPattern(elements);\n  }\n  function parsePropertyPattern(params, kind) {\n    var node = new Node(),\n      key,\n      keyToken,\n      computed = match('['),\n      init;\n    if (lookahead.type === Token.Identifier) {\n      keyToken = lookahead;\n      key = parseVariableIdentifier();\n      if (match('=')) {\n        params.push(keyToken);\n        lex();\n        init = parseAssignmentExpression();\n        return node.finishProperty('init', key, false, new WrappingNode(keyToken).finishAssignmentPattern(key, init), false, true);\n      } else if (!match(':')) {\n        params.push(keyToken);\n        return node.finishProperty('init', key, false, key, false, true);\n      }\n    } else {\n      key = parseObjectPropertyKey();\n    }\n    expect(':');\n    init = parsePatternWithDefault(params, kind);\n    return node.finishProperty('init', key, computed, init, false, false);\n  }\n  function parseObjectPattern(params, kind) {\n    var node = new Node(),\n      properties = [];\n    expect('{');\n    while (!match('}')) {\n      properties.push(parsePropertyPattern(params, kind));\n      if (!match('}')) {\n        expect(',');\n      }\n    }\n    lex();\n    return node.finishObjectPattern(properties);\n  }\n  function parsePattern(params, kind) {\n    if (match('[')) {\n      return parseArrayPattern(params, kind);\n    } else if (match('{')) {\n      return parseObjectPattern(params, kind);\n    } else if (matchKeyword('let')) {\n      if (kind === 'const' || kind === 'let') {\n        tolerateUnexpectedToken(lookahead, Messages.UnexpectedToken);\n      }\n    }\n    params.push(lookahead);\n    return parseVariableIdentifier(kind);\n  }\n  function parsePatternWithDefault(params, kind) {\n    var startToken = lookahead,\n      pattern,\n      previousAllowYield,\n      right;\n    pattern = parsePattern(params, kind);\n    if (match('=')) {\n      lex();\n      previousAllowYield = state.allowYield;\n      state.allowYield = true;\n      right = isolateCoverGrammar(parseAssignmentExpression);\n      state.allowYield = previousAllowYield;\n      pattern = new WrappingNode(startToken).finishAssignmentPattern(pattern, right);\n    }\n    return pattern;\n  }\n\n  // ECMA-262 12.2.5 Array Initializer\n\n  function parseArrayInitializer() {\n    var elements = [],\n      node = new Node(),\n      restSpread;\n    expect('[');\n    while (!match(']')) {\n      if (match(',')) {\n        lex();\n        elements.push(null);\n      } else if (match('...')) {\n        restSpread = new Node();\n        lex();\n        restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));\n        if (!match(']')) {\n          isAssignmentTarget = isBindingElement = false;\n          expect(',');\n        }\n        elements.push(restSpread);\n      } else {\n        elements.push(inheritCoverGrammar(parseAssignmentExpression));\n        if (!match(']')) {\n          expect(',');\n        }\n      }\n    }\n    lex();\n    return node.finishArrayExpression(elements);\n  }\n\n  // ECMA-262 12.2.6 Object Initializer\n\n  function parsePropertyFunction(node, paramInfo, isGenerator) {\n    var previousStrict, body;\n    isAssignmentTarget = isBindingElement = false;\n    previousStrict = strict;\n    body = isolateCoverGrammar(parseFunctionSourceElements);\n    if (strict && paramInfo.firstRestricted) {\n      tolerateUnexpectedToken(paramInfo.firstRestricted, paramInfo.message);\n    }\n    if (strict && paramInfo.stricted) {\n      tolerateUnexpectedToken(paramInfo.stricted, paramInfo.message);\n    }\n    strict = previousStrict;\n    return node.finishFunctionExpression(null, paramInfo.params, paramInfo.defaults, body, isGenerator);\n  }\n  function parsePropertyMethodFunction() {\n    var params,\n      method,\n      node = new Node(),\n      previousAllowYield = state.allowYield;\n    state.allowYield = false;\n    params = parseParams();\n    state.allowYield = previousAllowYield;\n    state.allowYield = false;\n    method = parsePropertyFunction(node, params, false);\n    state.allowYield = previousAllowYield;\n    return method;\n  }\n  function parseObjectPropertyKey() {\n    var token,\n      node = new Node(),\n      expr;\n    token = lex();\n\n    // Note: This function is called only from parseObjectProperty(), where\n    // EOF and Punctuator tokens are already filtered out.\n\n    switch (token.type) {\n      case Token.StringLiteral:\n      case Token.NumericLiteral:\n        if (strict && token.octal) {\n          tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);\n        }\n        return node.finishLiteral(token);\n      case Token.Identifier:\n      case Token.BooleanLiteral:\n      case Token.NullLiteral:\n      case Token.Keyword:\n        return node.finishIdentifier(token.value);\n      case Token.Punctuator:\n        if (token.value === '[') {\n          expr = isolateCoverGrammar(parseAssignmentExpression);\n          expect(']');\n          return expr;\n        }\n        break;\n    }\n    throwUnexpectedToken(token);\n  }\n  function lookaheadPropertyName() {\n    switch (lookahead.type) {\n      case Token.Identifier:\n      case Token.StringLiteral:\n      case Token.BooleanLiteral:\n      case Token.NullLiteral:\n      case Token.NumericLiteral:\n      case Token.Keyword:\n        return true;\n      case Token.Punctuator:\n        return lookahead.value === '[';\n    }\n    return false;\n  }\n\n  // This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,\n  // it might be called at a position where there is in fact a short hand identifier pattern or a data property.\n  // This can only be determined after we consumed up to the left parentheses.\n  //\n  // In order to avoid back tracking, it returns `null` if the position is not a MethodDefinition and the caller\n  // is responsible to visit other options.\n  function tryParseMethodDefinition(token, key, computed, node) {\n    var value,\n      options,\n      methodNode,\n      params,\n      previousAllowYield = state.allowYield;\n    if (token.type === Token.Identifier) {\n      // check for `get` and `set`;\n\n      if (token.value === 'get' && lookaheadPropertyName()) {\n        computed = match('[');\n        key = parseObjectPropertyKey();\n        methodNode = new Node();\n        expect('(');\n        expect(')');\n        state.allowYield = false;\n        value = parsePropertyFunction(methodNode, {\n          params: [],\n          defaults: [],\n          stricted: null,\n          firstRestricted: null,\n          message: null\n        }, false);\n        state.allowYield = previousAllowYield;\n        return node.finishProperty('get', key, computed, value, false, false);\n      } else if (token.value === 'set' && lookaheadPropertyName()) {\n        computed = match('[');\n        key = parseObjectPropertyKey();\n        methodNode = new Node();\n        expect('(');\n        options = {\n          params: [],\n          defaultCount: 0,\n          defaults: [],\n          firstRestricted: null,\n          paramSet: {}\n        };\n        if (match(')')) {\n          tolerateUnexpectedToken(lookahead);\n        } else {\n          state.allowYield = false;\n          parseParam(options);\n          state.allowYield = previousAllowYield;\n          if (options.defaultCount === 0) {\n            options.defaults = [];\n          }\n        }\n        expect(')');\n        state.allowYield = false;\n        value = parsePropertyFunction(methodNode, options, false);\n        state.allowYield = previousAllowYield;\n        return node.finishProperty('set', key, computed, value, false, false);\n      }\n    } else if (token.type === Token.Punctuator && token.value === '*' && lookaheadPropertyName()) {\n      computed = match('[');\n      key = parseObjectPropertyKey();\n      methodNode = new Node();\n      state.allowYield = true;\n      params = parseParams();\n      state.allowYield = previousAllowYield;\n      state.allowYield = false;\n      value = parsePropertyFunction(methodNode, params, true);\n      state.allowYield = previousAllowYield;\n      return node.finishProperty('init', key, computed, value, true, false);\n    }\n    if (key && match('(')) {\n      value = parsePropertyMethodFunction();\n      return node.finishProperty('init', key, computed, value, true, false);\n    }\n\n    // Not a MethodDefinition.\n    return null;\n  }\n  function parseObjectProperty(hasProto) {\n    var token = lookahead,\n      node = new Node(),\n      computed,\n      key,\n      maybeMethod,\n      proto,\n      value;\n    computed = match('[');\n    if (match('*')) {\n      lex();\n    } else {\n      key = parseObjectPropertyKey();\n    }\n    maybeMethod = tryParseMethodDefinition(token, key, computed, node);\n    if (maybeMethod) {\n      return maybeMethod;\n    }\n    if (!key) {\n      throwUnexpectedToken(lookahead);\n    }\n\n    // Check for duplicated __proto__\n    if (!computed) {\n      proto = key.type === Syntax.Identifier && key.name === '__proto__' || key.type === Syntax.Literal && key.value === '__proto__';\n      if (hasProto.value && proto) {\n        tolerateError(Messages.DuplicateProtoProperty);\n      }\n      hasProto.value |= proto;\n    }\n    if (match(':')) {\n      lex();\n      value = inheritCoverGrammar(parseAssignmentExpression);\n      return node.finishProperty('init', key, computed, value, false, false);\n    }\n    if (token.type === Token.Identifier) {\n      if (match('=')) {\n        firstCoverInitializedNameError = lookahead;\n        lex();\n        value = isolateCoverGrammar(parseAssignmentExpression);\n        return node.finishProperty('init', key, computed, new WrappingNode(token).finishAssignmentPattern(key, value), false, true);\n      }\n      return node.finishProperty('init', key, computed, key, false, true);\n    }\n    throwUnexpectedToken(lookahead);\n  }\n  function parseObjectInitializer() {\n    var properties = [],\n      hasProto = {\n        value: false\n      },\n      node = new Node();\n    expect('{');\n    while (!match('}')) {\n      properties.push(parseObjectProperty(hasProto));\n      if (!match('}')) {\n        expectCommaSeparator();\n      }\n    }\n    expect('}');\n    return node.finishObjectExpression(properties);\n  }\n  function reinterpretExpressionAsPattern(expr) {\n    var i;\n    switch (expr.type) {\n      case Syntax.Identifier:\n      case Syntax.MemberExpression:\n      case Syntax.RestElement:\n      case Syntax.AssignmentPattern:\n        break;\n      case Syntax.SpreadElement:\n        expr.type = Syntax.RestElement;\n        reinterpretExpressionAsPattern(expr.argument);\n        break;\n      case Syntax.ArrayExpression:\n        expr.type = Syntax.ArrayPattern;\n        for (i = 0; i < expr.elements.length; i++) {\n          if (expr.elements[i] !== null) {\n            reinterpretExpressionAsPattern(expr.elements[i]);\n          }\n        }\n        break;\n      case Syntax.ObjectExpression:\n        expr.type = Syntax.ObjectPattern;\n        for (i = 0; i < expr.properties.length; i++) {\n          reinterpretExpressionAsPattern(expr.properties[i].value);\n        }\n        break;\n      case Syntax.AssignmentExpression:\n        expr.type = Syntax.AssignmentPattern;\n        reinterpretExpressionAsPattern(expr.left);\n        break;\n      default:\n        // Allow other node type for tolerant parsing.\n        break;\n    }\n  }\n\n  // ECMA-262 12.2.9 Template Literals\n\n  function parseTemplateElement(option) {\n    var node, token;\n    if (lookahead.type !== Token.Template || option.head && !lookahead.head) {\n      throwUnexpectedToken();\n    }\n    node = new Node();\n    token = lex();\n    return node.finishTemplateElement({\n      raw: token.value.raw,\n      cooked: token.value.cooked\n    }, token.tail);\n  }\n  function parseTemplateLiteral() {\n    var quasi,\n      quasis,\n      expressions,\n      node = new Node();\n    quasi = parseTemplateElement({\n      head: true\n    });\n    quasis = [quasi];\n    expressions = [];\n    while (!quasi.tail) {\n      expressions.push(parseExpression());\n      quasi = parseTemplateElement({\n        head: false\n      });\n      quasis.push(quasi);\n    }\n    return node.finishTemplateLiteral(quasis, expressions);\n  }\n\n  // ECMA-262 12.2.10 The Grouping Operator\n\n  function parseGroupExpression() {\n    var expr,\n      expressions,\n      startToken,\n      i,\n      params = [];\n    expect('(');\n    if (match(')')) {\n      lex();\n      if (!match('=>')) {\n        expect('=>');\n      }\n      return {\n        type: PlaceHolders.ArrowParameterPlaceHolder,\n        params: [],\n        rawParams: []\n      };\n    }\n    startToken = lookahead;\n    if (match('...')) {\n      expr = parseRestElement(params);\n      expect(')');\n      if (!match('=>')) {\n        expect('=>');\n      }\n      return {\n        type: PlaceHolders.ArrowParameterPlaceHolder,\n        params: [expr]\n      };\n    }\n    isBindingElement = true;\n    expr = inheritCoverGrammar(parseAssignmentExpression);\n    if (match(',')) {\n      isAssignmentTarget = false;\n      expressions = [expr];\n      while (startIndex < length) {\n        if (!match(',')) {\n          break;\n        }\n        lex();\n        if (match('...')) {\n          if (!isBindingElement) {\n            throwUnexpectedToken(lookahead);\n          }\n          expressions.push(parseRestElement(params));\n          expect(')');\n          if (!match('=>')) {\n            expect('=>');\n          }\n          isBindingElement = false;\n          for (i = 0; i < expressions.length; i++) {\n            reinterpretExpressionAsPattern(expressions[i]);\n          }\n          return {\n            type: PlaceHolders.ArrowParameterPlaceHolder,\n            params: expressions\n          };\n        }\n        expressions.push(inheritCoverGrammar(parseAssignmentExpression));\n      }\n      expr = new WrappingNode(startToken).finishSequenceExpression(expressions);\n    }\n    expect(')');\n    if (match('=>')) {\n      if (expr.type === Syntax.Identifier && expr.name === 'yield') {\n        return {\n          type: PlaceHolders.ArrowParameterPlaceHolder,\n          params: [expr]\n        };\n      }\n      if (!isBindingElement) {\n        throwUnexpectedToken(lookahead);\n      }\n      if (expr.type === Syntax.SequenceExpression) {\n        for (i = 0; i < expr.expressions.length; i++) {\n          reinterpretExpressionAsPattern(expr.expressions[i]);\n        }\n      } else {\n        reinterpretExpressionAsPattern(expr);\n      }\n      expr = {\n        type: PlaceHolders.ArrowParameterPlaceHolder,\n        params: expr.type === Syntax.SequenceExpression ? expr.expressions : [expr]\n      };\n    }\n    isBindingElement = false;\n    return expr;\n  }\n\n  // ECMA-262 12.2 Primary Expressions\n\n  function parsePrimaryExpression() {\n    var type, token, expr, node;\n    if (match('(')) {\n      isBindingElement = false;\n      return inheritCoverGrammar(parseGroupExpression);\n    }\n    if (match('[')) {\n      return inheritCoverGrammar(parseArrayInitializer);\n    }\n    if (match('{')) {\n      return inheritCoverGrammar(parseObjectInitializer);\n    }\n    type = lookahead.type;\n    node = new Node();\n    if (type === Token.Identifier) {\n      if (state.sourceType === 'module' && lookahead.value === 'await') {\n        tolerateUnexpectedToken(lookahead);\n      }\n      expr = node.finishIdentifier(lex().value);\n    } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n      isAssignmentTarget = isBindingElement = false;\n      if (strict && lookahead.octal) {\n        tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);\n      }\n      expr = node.finishLiteral(lex());\n    } else if (type === Token.Keyword) {\n      if (!strict && state.allowYield && matchKeyword('yield')) {\n        return parseNonComputedProperty();\n      }\n      if (!strict && matchKeyword('let')) {\n        return node.finishIdentifier(lex().value);\n      }\n      isAssignmentTarget = isBindingElement = false;\n      if (matchKeyword('function')) {\n        return parseFunctionExpression();\n      }\n      if (matchKeyword('this')) {\n        lex();\n        return node.finishThisExpression();\n      }\n      if (matchKeyword('class')) {\n        return parseClassExpression();\n      }\n      throwUnexpectedToken(lex());\n    } else if (type === Token.BooleanLiteral) {\n      isAssignmentTarget = isBindingElement = false;\n      token = lex();\n      token.value = token.value === 'true';\n      expr = node.finishLiteral(token);\n    } else if (type === Token.NullLiteral) {\n      isAssignmentTarget = isBindingElement = false;\n      token = lex();\n      token.value = null;\n      expr = node.finishLiteral(token);\n    } else if (match('/') || match('/=')) {\n      isAssignmentTarget = isBindingElement = false;\n      index = startIndex;\n      if (typeof extra.tokens !== 'undefined') {\n        token = collectRegex();\n      } else {\n        token = scanRegExp();\n      }\n      lex();\n      expr = node.finishLiteral(token);\n    } else if (type === Token.Template) {\n      expr = parseTemplateLiteral();\n    } else {\n      throwUnexpectedToken(lex());\n    }\n    return expr;\n  }\n\n  // ECMA-262 12.3 Left-Hand-Side Expressions\n\n  function parseArguments() {\n    var args = [],\n      expr;\n    expect('(');\n    if (!match(')')) {\n      while (startIndex < length) {\n        if (match('...')) {\n          expr = new Node();\n          lex();\n          expr.finishSpreadElement(isolateCoverGrammar(parseAssignmentExpression));\n        } else {\n          expr = isolateCoverGrammar(parseAssignmentExpression);\n        }\n        args.push(expr);\n        if (match(')')) {\n          break;\n        }\n        expectCommaSeparator();\n      }\n    }\n    expect(')');\n    return args;\n  }\n  function parseNonComputedProperty() {\n    var token,\n      node = new Node();\n    token = lex();\n    if (!isIdentifierName(token)) {\n      throwUnexpectedToken(token);\n    }\n    return node.finishIdentifier(token.value);\n  }\n  function parseNonComputedMember() {\n    expect('.');\n    return parseNonComputedProperty();\n  }\n  function parseComputedMember() {\n    var expr;\n    expect('[');\n    expr = isolateCoverGrammar(parseExpression);\n    expect(']');\n    return expr;\n  }\n\n  // ECMA-262 12.3.3 The new Operator\n\n  function parseNewExpression() {\n    var callee,\n      args,\n      node = new Node();\n    expectKeyword('new');\n    if (match('.')) {\n      lex();\n      if (lookahead.type === Token.Identifier && lookahead.value === 'target') {\n        if (state.inFunctionBody) {\n          lex();\n          return node.finishMetaProperty('new', 'target');\n        }\n      }\n      throwUnexpectedToken(lookahead);\n    }\n    callee = isolateCoverGrammar(parseLeftHandSideExpression);\n    args = match('(') ? parseArguments() : [];\n    isAssignmentTarget = isBindingElement = false;\n    return node.finishNewExpression(callee, args);\n  }\n\n  // ECMA-262 12.3.4 Function Calls\n\n  function parseLeftHandSideExpressionAllowCall() {\n    var quasi,\n      expr,\n      args,\n      property,\n      startToken,\n      previousAllowIn = state.allowIn;\n    startToken = lookahead;\n    state.allowIn = true;\n    if (matchKeyword('super') && state.inFunctionBody) {\n      expr = new Node();\n      lex();\n      expr = expr.finishSuper();\n      if (!match('(') && !match('.') && !match('[')) {\n        throwUnexpectedToken(lookahead);\n      }\n    } else {\n      expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);\n    }\n    for (;;) {\n      if (match('.')) {\n        isBindingElement = false;\n        isAssignmentTarget = true;\n        property = parseNonComputedMember();\n        expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n      } else if (match('(')) {\n        isBindingElement = false;\n        isAssignmentTarget = false;\n        args = parseArguments();\n        expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n      } else if (match('[')) {\n        isBindingElement = false;\n        isAssignmentTarget = true;\n        property = parseComputedMember();\n        expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n      } else if (lookahead.type === Token.Template && lookahead.head) {\n        quasi = parseTemplateLiteral();\n        expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);\n      } else {\n        break;\n      }\n    }\n    state.allowIn = previousAllowIn;\n    return expr;\n  }\n\n  // ECMA-262 12.3 Left-Hand-Side Expressions\n\n  function parseLeftHandSideExpression() {\n    var quasi, expr, property, startToken;\n    assert(state.allowIn, 'callee of new expression always allow in keyword.');\n    startToken = lookahead;\n    if (matchKeyword('super') && state.inFunctionBody) {\n      expr = new Node();\n      lex();\n      expr = expr.finishSuper();\n      if (!match('[') && !match('.')) {\n        throwUnexpectedToken(lookahead);\n      }\n    } else {\n      expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);\n    }\n    for (;;) {\n      if (match('[')) {\n        isBindingElement = false;\n        isAssignmentTarget = true;\n        property = parseComputedMember();\n        expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n      } else if (match('.')) {\n        isBindingElement = false;\n        isAssignmentTarget = true;\n        property = parseNonComputedMember();\n        expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n      } else if (lookahead.type === Token.Template && lookahead.head) {\n        quasi = parseTemplateLiteral();\n        expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);\n      } else {\n        break;\n      }\n    }\n    return expr;\n  }\n\n  // ECMA-262 12.4 Postfix Expressions\n\n  function parsePostfixExpression() {\n    var expr,\n      token,\n      startToken = lookahead;\n    expr = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);\n    if (!hasLineTerminator && lookahead.type === Token.Punctuator) {\n      if (match('++') || match('--')) {\n        // ECMA-262 11.3.1, 11.3.2\n        if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n          tolerateError(Messages.StrictLHSPostfix);\n        }\n        if (!isAssignmentTarget) {\n          tolerateError(Messages.InvalidLHSInAssignment);\n        }\n        isAssignmentTarget = isBindingElement = false;\n        token = lex();\n        expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);\n      }\n    }\n    return expr;\n  }\n\n  // ECMA-262 12.5 Unary Operators\n\n  function parseUnaryExpression() {\n    var token, expr, startToken;\n    if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n      expr = parsePostfixExpression();\n    } else if (match('++') || match('--')) {\n      startToken = lookahead;\n      token = lex();\n      expr = inheritCoverGrammar(parseUnaryExpression);\n      // ECMA-262 11.4.4, 11.4.5\n      if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n        tolerateError(Messages.StrictLHSPrefix);\n      }\n      if (!isAssignmentTarget) {\n        tolerateError(Messages.InvalidLHSInAssignment);\n      }\n      expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      isAssignmentTarget = isBindingElement = false;\n    } else if (match('+') || match('-') || match('~') || match('!')) {\n      startToken = lookahead;\n      token = lex();\n      expr = inheritCoverGrammar(parseUnaryExpression);\n      expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      isAssignmentTarget = isBindingElement = false;\n    } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n      startToken = lookahead;\n      token = lex();\n      expr = inheritCoverGrammar(parseUnaryExpression);\n      expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n        tolerateError(Messages.StrictDelete);\n      }\n      isAssignmentTarget = isBindingElement = false;\n    } else {\n      expr = parsePostfixExpression();\n    }\n    return expr;\n  }\n  function binaryPrecedence(token, allowIn) {\n    var prec = 0;\n    if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n      return 0;\n    }\n    switch (token.value) {\n      case '||':\n        prec = 1;\n        break;\n      case '&&':\n        prec = 2;\n        break;\n      case '|':\n        prec = 3;\n        break;\n      case '^':\n        prec = 4;\n        break;\n      case '&':\n        prec = 5;\n        break;\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n        prec = 6;\n        break;\n      case '<':\n      case '>':\n      case '<=':\n      case '>=':\n      case 'instanceof':\n        prec = 7;\n        break;\n      case 'in':\n        prec = allowIn ? 7 : 0;\n        break;\n      case '<<':\n      case '>>':\n      case '>>>':\n        prec = 8;\n        break;\n      case '+':\n      case '-':\n        prec = 9;\n        break;\n      case '*':\n      case '/':\n      case '%':\n        prec = 11;\n        break;\n      default:\n        break;\n    }\n    return prec;\n  }\n\n  // ECMA-262 12.6 Multiplicative Operators\n  // ECMA-262 12.7 Additive Operators\n  // ECMA-262 12.8 Bitwise Shift Operators\n  // ECMA-262 12.9 Relational Operators\n  // ECMA-262 12.10 Equality Operators\n  // ECMA-262 12.11 Binary Bitwise Operators\n  // ECMA-262 12.12 Binary Logical Operators\n\n  function parseBinaryExpression() {\n    var marker, markers, expr, token, prec, stack, right, operator, left, i;\n    marker = lookahead;\n    left = inheritCoverGrammar(parseUnaryExpression);\n    token = lookahead;\n    prec = binaryPrecedence(token, state.allowIn);\n    if (prec === 0) {\n      return left;\n    }\n    isAssignmentTarget = isBindingElement = false;\n    token.prec = prec;\n    lex();\n    markers = [marker, lookahead];\n    right = isolateCoverGrammar(parseUnaryExpression);\n    stack = [left, token, right];\n    while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n      // Reduce: make a binary expression from the three topmost entries.\n      while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {\n        right = stack.pop();\n        operator = stack.pop().value;\n        left = stack.pop();\n        markers.pop();\n        expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n        stack.push(expr);\n      }\n\n      // Shift.\n      token = lex();\n      token.prec = prec;\n      stack.push(token);\n      markers.push(lookahead);\n      expr = isolateCoverGrammar(parseUnaryExpression);\n      stack.push(expr);\n    }\n\n    // Final reduce to clean-up the stack.\n    i = stack.length - 1;\n    expr = stack[i];\n    markers.pop();\n    while (i > 1) {\n      expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n      i -= 2;\n    }\n    return expr;\n  }\n\n  // ECMA-262 12.13 Conditional Operator\n\n  function parseConditionalExpression() {\n    var expr, previousAllowIn, consequent, alternate, startToken;\n    startToken = lookahead;\n    expr = inheritCoverGrammar(parseBinaryExpression);\n    if (match('?')) {\n      lex();\n      previousAllowIn = state.allowIn;\n      state.allowIn = true;\n      consequent = isolateCoverGrammar(parseAssignmentExpression);\n      state.allowIn = previousAllowIn;\n      expect(':');\n      alternate = isolateCoverGrammar(parseAssignmentExpression);\n      expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n      isAssignmentTarget = isBindingElement = false;\n    }\n    return expr;\n  }\n\n  // ECMA-262 14.2 Arrow Function Definitions\n\n  function parseConciseBody() {\n    if (match('{')) {\n      return parseFunctionSourceElements();\n    }\n    return isolateCoverGrammar(parseAssignmentExpression);\n  }\n  function checkPatternParam(options, param) {\n    var i;\n    switch (param.type) {\n      case Syntax.Identifier:\n        validateParam(options, param, param.name);\n        break;\n      case Syntax.RestElement:\n        checkPatternParam(options, param.argument);\n        break;\n      case Syntax.AssignmentPattern:\n        checkPatternParam(options, param.left);\n        break;\n      case Syntax.ArrayPattern:\n        for (i = 0; i < param.elements.length; i++) {\n          if (param.elements[i] !== null) {\n            checkPatternParam(options, param.elements[i]);\n          }\n        }\n        break;\n      case Syntax.YieldExpression:\n        break;\n      default:\n        assert(param.type === Syntax.ObjectPattern, 'Invalid type');\n        for (i = 0; i < param.properties.length; i++) {\n          checkPatternParam(options, param.properties[i].value);\n        }\n        break;\n    }\n  }\n  function reinterpretAsCoverFormalsList(expr) {\n    var i, len, param, params, defaults, defaultCount, options, token;\n    defaults = [];\n    defaultCount = 0;\n    params = [expr];\n    switch (expr.type) {\n      case Syntax.Identifier:\n        break;\n      case PlaceHolders.ArrowParameterPlaceHolder:\n        params = expr.params;\n        break;\n      default:\n        return null;\n    }\n    options = {\n      paramSet: {}\n    };\n    for (i = 0, len = params.length; i < len; i += 1) {\n      param = params[i];\n      switch (param.type) {\n        case Syntax.AssignmentPattern:\n          params[i] = param.left;\n          if (param.right.type === Syntax.YieldExpression) {\n            if (param.right.argument) {\n              throwUnexpectedToken(lookahead);\n            }\n            param.right.type = Syntax.Identifier;\n            param.right.name = 'yield';\n            delete param.right.argument;\n            delete param.right.delegate;\n          }\n          defaults.push(param.right);\n          ++defaultCount;\n          checkPatternParam(options, param.left);\n          break;\n        default:\n          checkPatternParam(options, param);\n          params[i] = param;\n          defaults.push(null);\n          break;\n      }\n    }\n    if (strict || !state.allowYield) {\n      for (i = 0, len = params.length; i < len; i += 1) {\n        param = params[i];\n        if (param.type === Syntax.YieldExpression) {\n          throwUnexpectedToken(lookahead);\n        }\n      }\n    }\n    if (options.message === Messages.StrictParamDupe) {\n      token = strict ? options.stricted : options.firstRestricted;\n      throwUnexpectedToken(token, options.message);\n    }\n    if (defaultCount === 0) {\n      defaults = [];\n    }\n    return {\n      params: params,\n      defaults: defaults,\n      stricted: options.stricted,\n      firstRestricted: options.firstRestricted,\n      message: options.message\n    };\n  }\n  function parseArrowFunctionExpression(options, node) {\n    var previousStrict, previousAllowYield, body;\n    if (hasLineTerminator) {\n      tolerateUnexpectedToken(lookahead);\n    }\n    expect('=>');\n    previousStrict = strict;\n    previousAllowYield = state.allowYield;\n    state.allowYield = true;\n    body = parseConciseBody();\n    if (strict && options.firstRestricted) {\n      throwUnexpectedToken(options.firstRestricted, options.message);\n    }\n    if (strict && options.stricted) {\n      tolerateUnexpectedToken(options.stricted, options.message);\n    }\n    strict = previousStrict;\n    state.allowYield = previousAllowYield;\n    return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);\n  }\n\n  // ECMA-262 14.4 Yield expression\n\n  function parseYieldExpression() {\n    var argument, expr, delegate, previousAllowYield;\n    argument = null;\n    expr = new Node();\n    delegate = false;\n    expectKeyword('yield');\n    if (!hasLineTerminator) {\n      previousAllowYield = state.allowYield;\n      state.allowYield = false;\n      delegate = match('*');\n      if (delegate) {\n        lex();\n        argument = parseAssignmentExpression();\n      } else {\n        if (!match(';') && !match('}') && !match(')') && lookahead.type !== Token.EOF) {\n          argument = parseAssignmentExpression();\n        }\n      }\n      state.allowYield = previousAllowYield;\n    }\n    return expr.finishYieldExpression(argument, delegate);\n  }\n\n  // ECMA-262 12.14 Assignment Operators\n\n  function parseAssignmentExpression() {\n    var token, expr, right, list, startToken;\n    startToken = lookahead;\n    token = lookahead;\n    if (!state.allowYield && matchKeyword('yield')) {\n      return parseYieldExpression();\n    }\n    expr = parseConditionalExpression();\n    if (expr.type === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {\n      isAssignmentTarget = isBindingElement = false;\n      list = reinterpretAsCoverFormalsList(expr);\n      if (list) {\n        firstCoverInitializedNameError = null;\n        return parseArrowFunctionExpression(list, new WrappingNode(startToken));\n      }\n      return expr;\n    }\n    if (matchAssign()) {\n      if (!isAssignmentTarget) {\n        tolerateError(Messages.InvalidLHSInAssignment);\n      }\n\n      // ECMA-262 12.1.1\n      if (strict && expr.type === Syntax.Identifier) {\n        if (isRestrictedWord(expr.name)) {\n          tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);\n        }\n        if (isStrictModeReservedWord(expr.name)) {\n          tolerateUnexpectedToken(token, Messages.StrictReservedWord);\n        }\n      }\n      if (!match('=')) {\n        isAssignmentTarget = isBindingElement = false;\n      } else {\n        reinterpretExpressionAsPattern(expr);\n      }\n      token = lex();\n      right = isolateCoverGrammar(parseAssignmentExpression);\n      expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);\n      firstCoverInitializedNameError = null;\n    }\n    return expr;\n  }\n\n  // ECMA-262 12.15 Comma Operator\n\n  function parseExpression() {\n    var expr,\n      startToken = lookahead,\n      expressions;\n    expr = isolateCoverGrammar(parseAssignmentExpression);\n    if (match(',')) {\n      expressions = [expr];\n      while (startIndex < length) {\n        if (!match(',')) {\n          break;\n        }\n        lex();\n        expressions.push(isolateCoverGrammar(parseAssignmentExpression));\n      }\n      expr = new WrappingNode(startToken).finishSequenceExpression(expressions);\n    }\n    return expr;\n  }\n\n  // ECMA-262 13.2 Block\n\n  function parseStatementListItem() {\n    if (lookahead.type === Token.Keyword) {\n      switch (lookahead.value) {\n        case 'export':\n          if (state.sourceType !== 'module') {\n            tolerateUnexpectedToken(lookahead, Messages.IllegalExportDeclaration);\n          }\n          return parseExportDeclaration();\n        case 'import':\n          if (state.sourceType !== 'module') {\n            tolerateUnexpectedToken(lookahead, Messages.IllegalImportDeclaration);\n          }\n          return parseImportDeclaration();\n        case 'const':\n          return parseLexicalDeclaration({\n            inFor: false\n          });\n        case 'function':\n          return parseFunctionDeclaration(new Node());\n        case 'class':\n          return parseClassDeclaration();\n      }\n    }\n    if (matchKeyword('let') && isLexicalDeclaration()) {\n      return parseLexicalDeclaration({\n        inFor: false\n      });\n    }\n    return parseStatement();\n  }\n  function parseStatementList() {\n    var list = [];\n    while (startIndex < length) {\n      if (match('}')) {\n        break;\n      }\n      list.push(parseStatementListItem());\n    }\n    return list;\n  }\n  function parseBlock() {\n    var block,\n      node = new Node();\n    expect('{');\n    block = parseStatementList();\n    expect('}');\n    return node.finishBlockStatement(block);\n  }\n\n  // ECMA-262 13.3.2 Variable Statement\n\n  function parseVariableIdentifier(kind) {\n    var token,\n      node = new Node();\n    token = lex();\n    if (token.type === Token.Keyword && token.value === 'yield') {\n      if (strict) {\n        tolerateUnexpectedToken(token, Messages.StrictReservedWord);\n      }\n      if (!state.allowYield) {\n        throwUnexpectedToken(token);\n      }\n    } else if (token.type !== Token.Identifier) {\n      if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {\n        tolerateUnexpectedToken(token, Messages.StrictReservedWord);\n      } else {\n        if (strict || token.value !== 'let' || kind !== 'var') {\n          throwUnexpectedToken(token);\n        }\n      }\n    } else if (state.sourceType === 'module' && token.type === Token.Identifier && token.value === 'await') {\n      tolerateUnexpectedToken(token);\n    }\n    return node.finishIdentifier(token.value);\n  }\n  function parseVariableDeclaration(options) {\n    var init = null,\n      id,\n      node = new Node(),\n      params = [];\n    id = parsePattern(params, 'var');\n\n    // ECMA-262 12.2.1\n    if (strict && isRestrictedWord(id.name)) {\n      tolerateError(Messages.StrictVarName);\n    }\n    if (match('=')) {\n      lex();\n      init = isolateCoverGrammar(parseAssignmentExpression);\n    } else if (id.type !== Syntax.Identifier && !options.inFor) {\n      expect('=');\n    }\n    return node.finishVariableDeclarator(id, init);\n  }\n  function parseVariableDeclarationList(options) {\n    var opt, list;\n    opt = {\n      inFor: options.inFor\n    };\n    list = [parseVariableDeclaration(opt)];\n    while (match(',')) {\n      lex();\n      list.push(parseVariableDeclaration(opt));\n    }\n    return list;\n  }\n  function parseVariableStatement(node) {\n    var declarations;\n    expectKeyword('var');\n    declarations = parseVariableDeclarationList({\n      inFor: false\n    });\n    consumeSemicolon();\n    return node.finishVariableDeclaration(declarations);\n  }\n\n  // ECMA-262 13.3.1 Let and Const Declarations\n\n  function parseLexicalBinding(kind, options) {\n    var init = null,\n      id,\n      node = new Node(),\n      params = [];\n    id = parsePattern(params, kind);\n\n    // ECMA-262 12.2.1\n    if (strict && id.type === Syntax.Identifier && isRestrictedWord(id.name)) {\n      tolerateError(Messages.StrictVarName);\n    }\n    if (kind === 'const') {\n      if (!matchKeyword('in') && !matchContextualKeyword('of')) {\n        expect('=');\n        init = isolateCoverGrammar(parseAssignmentExpression);\n      }\n    } else if (!options.inFor && id.type !== Syntax.Identifier || match('=')) {\n      expect('=');\n      init = isolateCoverGrammar(parseAssignmentExpression);\n    }\n    return node.finishVariableDeclarator(id, init);\n  }\n  function parseBindingList(kind, options) {\n    var list = [parseLexicalBinding(kind, options)];\n    while (match(',')) {\n      lex();\n      list.push(parseLexicalBinding(kind, options));\n    }\n    return list;\n  }\n  function tokenizerState() {\n    return {\n      index: index,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      hasLineTerminator: hasLineTerminator,\n      lastIndex: lastIndex,\n      lastLineNumber: lastLineNumber,\n      lastLineStart: lastLineStart,\n      startIndex: startIndex,\n      startLineNumber: startLineNumber,\n      startLineStart: startLineStart,\n      lookahead: lookahead,\n      tokenCount: extra.tokens ? extra.tokens.length : 0\n    };\n  }\n  function resetTokenizerState(ts) {\n    index = ts.index;\n    lineNumber = ts.lineNumber;\n    lineStart = ts.lineStart;\n    hasLineTerminator = ts.hasLineTerminator;\n    lastIndex = ts.lastIndex;\n    lastLineNumber = ts.lastLineNumber;\n    lastLineStart = ts.lastLineStart;\n    startIndex = ts.startIndex;\n    startLineNumber = ts.startLineNumber;\n    startLineStart = ts.startLineStart;\n    lookahead = ts.lookahead;\n    if (extra.tokens) {\n      extra.tokens.splice(ts.tokenCount, extra.tokens.length);\n    }\n  }\n  function isLexicalDeclaration() {\n    var lexical, ts;\n    ts = tokenizerState();\n    lex();\n    lexical = lookahead.type === Token.Identifier || match('[') || match('{') || matchKeyword('let') || matchKeyword('yield');\n    resetTokenizerState(ts);\n    return lexical;\n  }\n  function parseLexicalDeclaration(options) {\n    var kind,\n      declarations,\n      node = new Node();\n    kind = lex().value;\n    assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');\n    declarations = parseBindingList(kind, options);\n    consumeSemicolon();\n    return node.finishLexicalDeclaration(declarations, kind);\n  }\n  function parseRestElement(params) {\n    var param,\n      node = new Node();\n    lex();\n    if (match('{')) {\n      throwError(Messages.ObjectPatternAsRestParameter);\n    }\n    params.push(lookahead);\n    param = parseVariableIdentifier();\n    if (match('=')) {\n      throwError(Messages.DefaultRestParameter);\n    }\n    if (!match(')')) {\n      throwError(Messages.ParameterAfterRestParameter);\n    }\n    return node.finishRestElement(param);\n  }\n\n  // ECMA-262 13.4 Empty Statement\n\n  function parseEmptyStatement(node) {\n    expect(';');\n    return node.finishEmptyStatement();\n  }\n\n  // ECMA-262 12.4 Expression Statement\n\n  function parseExpressionStatement(node) {\n    var expr = parseExpression();\n    consumeSemicolon();\n    return node.finishExpressionStatement(expr);\n  }\n\n  // ECMA-262 13.6 If statement\n\n  function parseIfStatement(node) {\n    var test, consequent, alternate;\n    expectKeyword('if');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n    consequent = parseStatement();\n    if (matchKeyword('else')) {\n      lex();\n      alternate = parseStatement();\n    } else {\n      alternate = null;\n    }\n    return node.finishIfStatement(test, consequent, alternate);\n  }\n\n  // ECMA-262 13.7 Iteration Statements\n\n  function parseDoWhileStatement(node) {\n    var body, test, oldInIteration;\n    expectKeyword('do');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = parseStatement();\n    state.inIteration = oldInIteration;\n    expectKeyword('while');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n    if (match(';')) {\n      lex();\n    }\n    return node.finishDoWhileStatement(body, test);\n  }\n  function parseWhileStatement(node) {\n    var test, body, oldInIteration;\n    expectKeyword('while');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = parseStatement();\n    state.inIteration = oldInIteration;\n    return node.finishWhileStatement(test, body);\n  }\n  function parseForStatement(node) {\n    var init,\n      forIn,\n      initSeq,\n      initStartToken,\n      test,\n      update,\n      left,\n      right,\n      kind,\n      declarations,\n      body,\n      oldInIteration,\n      previousAllowIn = state.allowIn;\n    init = test = update = null;\n    forIn = true;\n    expectKeyword('for');\n    expect('(');\n    if (match(';')) {\n      lex();\n    } else {\n      if (matchKeyword('var')) {\n        init = new Node();\n        lex();\n        state.allowIn = false;\n        declarations = parseVariableDeclarationList({\n          inFor: true\n        });\n        state.allowIn = previousAllowIn;\n        if (declarations.length === 1 && matchKeyword('in')) {\n          init = init.finishVariableDeclaration(declarations);\n          lex();\n          left = init;\n          right = parseExpression();\n          init = null;\n        } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {\n          init = init.finishVariableDeclaration(declarations);\n          lex();\n          left = init;\n          right = parseAssignmentExpression();\n          init = null;\n          forIn = false;\n        } else {\n          init = init.finishVariableDeclaration(declarations);\n          expect(';');\n        }\n      } else if (matchKeyword('const') || matchKeyword('let')) {\n        init = new Node();\n        kind = lex().value;\n        if (!strict && lookahead.value === 'in') {\n          init = init.finishIdentifier(kind);\n          lex();\n          left = init;\n          right = parseExpression();\n          init = null;\n        } else {\n          state.allowIn = false;\n          declarations = parseBindingList(kind, {\n            inFor: true\n          });\n          state.allowIn = previousAllowIn;\n          if (declarations.length === 1 && declarations[0].init === null && matchKeyword('in')) {\n            init = init.finishLexicalDeclaration(declarations, kind);\n            lex();\n            left = init;\n            right = parseExpression();\n            init = null;\n          } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {\n            init = init.finishLexicalDeclaration(declarations, kind);\n            lex();\n            left = init;\n            right = parseAssignmentExpression();\n            init = null;\n            forIn = false;\n          } else {\n            consumeSemicolon();\n            init = init.finishLexicalDeclaration(declarations, kind);\n          }\n        }\n      } else {\n        initStartToken = lookahead;\n        state.allowIn = false;\n        init = inheritCoverGrammar(parseAssignmentExpression);\n        state.allowIn = previousAllowIn;\n        if (matchKeyword('in')) {\n          if (!isAssignmentTarget) {\n            tolerateError(Messages.InvalidLHSInForIn);\n          }\n          lex();\n          reinterpretExpressionAsPattern(init);\n          left = init;\n          right = parseExpression();\n          init = null;\n        } else if (matchContextualKeyword('of')) {\n          if (!isAssignmentTarget) {\n            tolerateError(Messages.InvalidLHSInForLoop);\n          }\n          lex();\n          reinterpretExpressionAsPattern(init);\n          left = init;\n          right = parseAssignmentExpression();\n          init = null;\n          forIn = false;\n        } else {\n          if (match(',')) {\n            initSeq = [init];\n            while (match(',')) {\n              lex();\n              initSeq.push(isolateCoverGrammar(parseAssignmentExpression));\n            }\n            init = new WrappingNode(initStartToken).finishSequenceExpression(initSeq);\n          }\n          expect(';');\n        }\n      }\n    }\n    if (typeof left === 'undefined') {\n      if (!match(';')) {\n        test = parseExpression();\n      }\n      expect(';');\n      if (!match(')')) {\n        update = parseExpression();\n      }\n    }\n    expect(')');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = isolateCoverGrammar(parseStatement);\n    state.inIteration = oldInIteration;\n    return typeof left === 'undefined' ? node.finishForStatement(init, test, update, body) : forIn ? node.finishForInStatement(left, right, body) : node.finishForOfStatement(left, right, body);\n  }\n\n  // ECMA-262 13.8 The continue statement\n\n  function parseContinueStatement(node) {\n    var label = null,\n      key;\n    expectKeyword('continue');\n\n    // Optimize the most common form: 'continue;'.\n    if (source.charCodeAt(startIndex) === 0x3B) {\n      lex();\n      if (!state.inIteration) {\n        throwError(Messages.IllegalContinue);\n      }\n      return node.finishContinueStatement(null);\n    }\n    if (hasLineTerminator) {\n      if (!state.inIteration) {\n        throwError(Messages.IllegalContinue);\n      }\n      return node.finishContinueStatement(null);\n    }\n    if (lookahead.type === Token.Identifier) {\n      label = parseVariableIdentifier();\n      key = '$' + label.name;\n      if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n        throwError(Messages.UnknownLabel, label.name);\n      }\n    }\n    consumeSemicolon();\n    if (label === null && !state.inIteration) {\n      throwError(Messages.IllegalContinue);\n    }\n    return node.finishContinueStatement(label);\n  }\n\n  // ECMA-262 13.9 The break statement\n\n  function parseBreakStatement(node) {\n    var label = null,\n      key;\n    expectKeyword('break');\n\n    // Catch the very common case first: immediately a semicolon (U+003B).\n    if (source.charCodeAt(lastIndex) === 0x3B) {\n      lex();\n      if (!(state.inIteration || state.inSwitch)) {\n        throwError(Messages.IllegalBreak);\n      }\n      return node.finishBreakStatement(null);\n    }\n    if (hasLineTerminator) {\n      if (!(state.inIteration || state.inSwitch)) {\n        throwError(Messages.IllegalBreak);\n      }\n    } else if (lookahead.type === Token.Identifier) {\n      label = parseVariableIdentifier();\n      key = '$' + label.name;\n      if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n        throwError(Messages.UnknownLabel, label.name);\n      }\n    }\n    consumeSemicolon();\n    if (label === null && !(state.inIteration || state.inSwitch)) {\n      throwError(Messages.IllegalBreak);\n    }\n    return node.finishBreakStatement(label);\n  }\n\n  // ECMA-262 13.10 The return statement\n\n  function parseReturnStatement(node) {\n    var argument = null;\n    expectKeyword('return');\n    if (!state.inFunctionBody) {\n      tolerateError(Messages.IllegalReturn);\n    }\n\n    // 'return' followed by a space and an identifier is very common.\n    if (source.charCodeAt(lastIndex) === 0x20) {\n      if (isIdentifierStart(source.charCodeAt(lastIndex + 1))) {\n        argument = parseExpression();\n        consumeSemicolon();\n        return node.finishReturnStatement(argument);\n      }\n    }\n    if (hasLineTerminator) {\n      // HACK\n      return node.finishReturnStatement(null);\n    }\n    if (!match(';')) {\n      if (!match('}') && lookahead.type !== Token.EOF) {\n        argument = parseExpression();\n      }\n    }\n    consumeSemicolon();\n    return node.finishReturnStatement(argument);\n  }\n\n  // ECMA-262 13.11 The with statement\n\n  function parseWithStatement(node) {\n    var object, body;\n    if (strict) {\n      tolerateError(Messages.StrictModeWith);\n    }\n    expectKeyword('with');\n    expect('(');\n    object = parseExpression();\n    expect(')');\n    body = parseStatement();\n    return node.finishWithStatement(object, body);\n  }\n\n  // ECMA-262 13.12 The switch statement\n\n  function parseSwitchCase() {\n    var test,\n      consequent = [],\n      statement,\n      node = new Node();\n    if (matchKeyword('default')) {\n      lex();\n      test = null;\n    } else {\n      expectKeyword('case');\n      test = parseExpression();\n    }\n    expect(':');\n    while (startIndex < length) {\n      if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n        break;\n      }\n      statement = parseStatementListItem();\n      consequent.push(statement);\n    }\n    return node.finishSwitchCase(test, consequent);\n  }\n  function parseSwitchStatement(node) {\n    var discriminant, cases, clause, oldInSwitch, defaultFound;\n    expectKeyword('switch');\n    expect('(');\n    discriminant = parseExpression();\n    expect(')');\n    expect('{');\n    cases = [];\n    if (match('}')) {\n      lex();\n      return node.finishSwitchStatement(discriminant, cases);\n    }\n    oldInSwitch = state.inSwitch;\n    state.inSwitch = true;\n    defaultFound = false;\n    while (startIndex < length) {\n      if (match('}')) {\n        break;\n      }\n      clause = parseSwitchCase();\n      if (clause.test === null) {\n        if (defaultFound) {\n          throwError(Messages.MultipleDefaultsInSwitch);\n        }\n        defaultFound = true;\n      }\n      cases.push(clause);\n    }\n    state.inSwitch = oldInSwitch;\n    expect('}');\n    return node.finishSwitchStatement(discriminant, cases);\n  }\n\n  // ECMA-262 13.14 The throw statement\n\n  function parseThrowStatement(node) {\n    var argument;\n    expectKeyword('throw');\n    if (hasLineTerminator) {\n      throwError(Messages.NewlineAfterThrow);\n    }\n    argument = parseExpression();\n    consumeSemicolon();\n    return node.finishThrowStatement(argument);\n  }\n\n  // ECMA-262 13.15 The try statement\n\n  function parseCatchClause() {\n    var param,\n      params = [],\n      paramMap = {},\n      key,\n      i,\n      body,\n      node = new Node();\n    expectKeyword('catch');\n    expect('(');\n    if (match(')')) {\n      throwUnexpectedToken(lookahead);\n    }\n    param = parsePattern(params);\n    for (i = 0; i < params.length; i++) {\n      key = '$' + params[i].value;\n      if (Object.prototype.hasOwnProperty.call(paramMap, key)) {\n        tolerateError(Messages.DuplicateBinding, params[i].value);\n      }\n      paramMap[key] = true;\n    }\n\n    // ECMA-262 12.14.1\n    if (strict && isRestrictedWord(param.name)) {\n      tolerateError(Messages.StrictCatchVariable);\n    }\n    expect(')');\n    body = parseBlock();\n    return node.finishCatchClause(param, body);\n  }\n  function parseTryStatement(node) {\n    var block,\n      handler = null,\n      finalizer = null;\n    expectKeyword('try');\n    block = parseBlock();\n    if (matchKeyword('catch')) {\n      handler = parseCatchClause();\n    }\n    if (matchKeyword('finally')) {\n      lex();\n      finalizer = parseBlock();\n    }\n    if (!handler && !finalizer) {\n      throwError(Messages.NoCatchOrFinally);\n    }\n    return node.finishTryStatement(block, handler, finalizer);\n  }\n\n  // ECMA-262 13.16 The debugger statement\n\n  function parseDebuggerStatement(node) {\n    expectKeyword('debugger');\n    consumeSemicolon();\n    return node.finishDebuggerStatement();\n  }\n\n  // 13 Statements\n\n  function parseStatement() {\n    var type = lookahead.type,\n      expr,\n      labeledBody,\n      key,\n      node;\n    if (type === Token.EOF) {\n      throwUnexpectedToken(lookahead);\n    }\n    if (type === Token.Punctuator && lookahead.value === '{') {\n      return parseBlock();\n    }\n    isAssignmentTarget = isBindingElement = true;\n    node = new Node();\n    if (type === Token.Punctuator) {\n      switch (lookahead.value) {\n        case ';':\n          return parseEmptyStatement(node);\n        case '(':\n          return parseExpressionStatement(node);\n        default:\n          break;\n      }\n    } else if (type === Token.Keyword) {\n      switch (lookahead.value) {\n        case 'break':\n          return parseBreakStatement(node);\n        case 'continue':\n          return parseContinueStatement(node);\n        case 'debugger':\n          return parseDebuggerStatement(node);\n        case 'do':\n          return parseDoWhileStatement(node);\n        case 'for':\n          return parseForStatement(node);\n        case 'function':\n          return parseFunctionDeclaration(node);\n        case 'if':\n          return parseIfStatement(node);\n        case 'return':\n          return parseReturnStatement(node);\n        case 'switch':\n          return parseSwitchStatement(node);\n        case 'throw':\n          return parseThrowStatement(node);\n        case 'try':\n          return parseTryStatement(node);\n        case 'var':\n          return parseVariableStatement(node);\n        case 'while':\n          return parseWhileStatement(node);\n        case 'with':\n          return parseWithStatement(node);\n        default:\n          break;\n      }\n    }\n    expr = parseExpression();\n\n    // ECMA-262 12.12 Labelled Statements\n    if (expr.type === Syntax.Identifier && match(':')) {\n      lex();\n      key = '$' + expr.name;\n      if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n        throwError(Messages.Redeclaration, 'Label', expr.name);\n      }\n      state.labelSet[key] = true;\n      labeledBody = parseStatement();\n      delete state.labelSet[key];\n      return node.finishLabeledStatement(expr, labeledBody);\n    }\n    consumeSemicolon();\n    return node.finishExpressionStatement(expr);\n  }\n\n  // ECMA-262 14.1 Function Definition\n\n  function parseFunctionSourceElements() {\n    var statement,\n      body = [],\n      token,\n      directive,\n      firstRestricted,\n      oldLabelSet,\n      oldInIteration,\n      oldInSwitch,\n      oldInFunctionBody,\n      node = new Node();\n    expect('{');\n    while (startIndex < length) {\n      if (lookahead.type !== Token.StringLiteral) {\n        break;\n      }\n      token = lookahead;\n      statement = parseStatementListItem();\n      body.push(statement);\n      if (statement.expression.type !== Syntax.Literal) {\n        // this is not directive\n        break;\n      }\n      directive = source.slice(token.start + 1, token.end - 1);\n      if (directive === 'use strict') {\n        strict = true;\n        if (firstRestricted) {\n          tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);\n        }\n      } else {\n        if (!firstRestricted && token.octal) {\n          firstRestricted = token;\n        }\n      }\n    }\n    oldLabelSet = state.labelSet;\n    oldInIteration = state.inIteration;\n    oldInSwitch = state.inSwitch;\n    oldInFunctionBody = state.inFunctionBody;\n    state.labelSet = {};\n    state.inIteration = false;\n    state.inSwitch = false;\n    state.inFunctionBody = true;\n    while (startIndex < length) {\n      if (match('}')) {\n        break;\n      }\n      body.push(parseStatementListItem());\n    }\n    expect('}');\n    state.labelSet = oldLabelSet;\n    state.inIteration = oldInIteration;\n    state.inSwitch = oldInSwitch;\n    state.inFunctionBody = oldInFunctionBody;\n    return node.finishBlockStatement(body);\n  }\n  function validateParam(options, param, name) {\n    var key = '$' + name;\n    if (strict) {\n      if (isRestrictedWord(name)) {\n        options.stricted = param;\n        options.message = Messages.StrictParamName;\n      }\n      if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n        options.stricted = param;\n        options.message = Messages.StrictParamDupe;\n      }\n    } else if (!options.firstRestricted) {\n      if (isRestrictedWord(name)) {\n        options.firstRestricted = param;\n        options.message = Messages.StrictParamName;\n      } else if (isStrictModeReservedWord(name)) {\n        options.firstRestricted = param;\n        options.message = Messages.StrictReservedWord;\n      } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n        options.stricted = param;\n        options.message = Messages.StrictParamDupe;\n      }\n    }\n    options.paramSet[key] = true;\n  }\n  function parseParam(options) {\n    var token,\n      param,\n      params = [],\n      i,\n      def;\n    token = lookahead;\n    if (token.value === '...') {\n      param = parseRestElement(params);\n      validateParam(options, param.argument, param.argument.name);\n      options.params.push(param);\n      options.defaults.push(null);\n      return false;\n    }\n    param = parsePatternWithDefault(params);\n    for (i = 0; i < params.length; i++) {\n      validateParam(options, params[i], params[i].value);\n    }\n    if (param.type === Syntax.AssignmentPattern) {\n      def = param.right;\n      param = param.left;\n      ++options.defaultCount;\n    }\n    options.params.push(param);\n    options.defaults.push(def);\n    return !match(')');\n  }\n  function parseParams(firstRestricted) {\n    var options;\n    options = {\n      params: [],\n      defaultCount: 0,\n      defaults: [],\n      firstRestricted: firstRestricted\n    };\n    expect('(');\n    if (!match(')')) {\n      options.paramSet = {};\n      while (startIndex < length) {\n        if (!parseParam(options)) {\n          break;\n        }\n        expect(',');\n      }\n    }\n    expect(')');\n    if (options.defaultCount === 0) {\n      options.defaults = [];\n    }\n    return {\n      params: options.params,\n      defaults: options.defaults,\n      stricted: options.stricted,\n      firstRestricted: options.firstRestricted,\n      message: options.message\n    };\n  }\n  function parseFunctionDeclaration(node, identifierIsOptional) {\n    var id = null,\n      params = [],\n      defaults = [],\n      body,\n      token,\n      stricted,\n      tmp,\n      firstRestricted,\n      message,\n      previousStrict,\n      isGenerator,\n      previousAllowYield;\n    previousAllowYield = state.allowYield;\n    expectKeyword('function');\n    isGenerator = match('*');\n    if (isGenerator) {\n      lex();\n    }\n    if (!identifierIsOptional || !match('(')) {\n      token = lookahead;\n      id = parseVariableIdentifier();\n      if (strict) {\n        if (isRestrictedWord(token.value)) {\n          tolerateUnexpectedToken(token, Messages.StrictFunctionName);\n        }\n      } else {\n        if (isRestrictedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictFunctionName;\n        } else if (isStrictModeReservedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictReservedWord;\n        }\n      }\n    }\n    state.allowYield = !isGenerator;\n    tmp = parseParams(firstRestricted);\n    params = tmp.params;\n    defaults = tmp.defaults;\n    stricted = tmp.stricted;\n    firstRestricted = tmp.firstRestricted;\n    if (tmp.message) {\n      message = tmp.message;\n    }\n    previousStrict = strict;\n    body = parseFunctionSourceElements();\n    if (strict && firstRestricted) {\n      throwUnexpectedToken(firstRestricted, message);\n    }\n    if (strict && stricted) {\n      tolerateUnexpectedToken(stricted, message);\n    }\n    strict = previousStrict;\n    state.allowYield = previousAllowYield;\n    return node.finishFunctionDeclaration(id, params, defaults, body, isGenerator);\n  }\n  function parseFunctionExpression() {\n    var token,\n      id = null,\n      stricted,\n      firstRestricted,\n      message,\n      tmp,\n      params = [],\n      defaults = [],\n      body,\n      previousStrict,\n      node = new Node(),\n      isGenerator,\n      previousAllowYield;\n    previousAllowYield = state.allowYield;\n    expectKeyword('function');\n    isGenerator = match('*');\n    if (isGenerator) {\n      lex();\n    }\n    state.allowYield = !isGenerator;\n    if (!match('(')) {\n      token = lookahead;\n      id = !strict && !isGenerator && matchKeyword('yield') ? parseNonComputedProperty() : parseVariableIdentifier();\n      if (strict) {\n        if (isRestrictedWord(token.value)) {\n          tolerateUnexpectedToken(token, Messages.StrictFunctionName);\n        }\n      } else {\n        if (isRestrictedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictFunctionName;\n        } else if (isStrictModeReservedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictReservedWord;\n        }\n      }\n    }\n    tmp = parseParams(firstRestricted);\n    params = tmp.params;\n    defaults = tmp.defaults;\n    stricted = tmp.stricted;\n    firstRestricted = tmp.firstRestricted;\n    if (tmp.message) {\n      message = tmp.message;\n    }\n    previousStrict = strict;\n    body = parseFunctionSourceElements();\n    if (strict && firstRestricted) {\n      throwUnexpectedToken(firstRestricted, message);\n    }\n    if (strict && stricted) {\n      tolerateUnexpectedToken(stricted, message);\n    }\n    strict = previousStrict;\n    state.allowYield = previousAllowYield;\n    return node.finishFunctionExpression(id, params, defaults, body, isGenerator);\n  }\n\n  // ECMA-262 14.5 Class Definitions\n\n  function parseClassBody() {\n    var classBody,\n      token,\n      isStatic,\n      hasConstructor = false,\n      body,\n      method,\n      computed,\n      key;\n    classBody = new Node();\n    expect('{');\n    body = [];\n    while (!match('}')) {\n      if (match(';')) {\n        lex();\n      } else {\n        method = new Node();\n        token = lookahead;\n        isStatic = false;\n        computed = match('[');\n        if (match('*')) {\n          lex();\n        } else {\n          key = parseObjectPropertyKey();\n          if (key.name === 'static' && (lookaheadPropertyName() || match('*'))) {\n            token = lookahead;\n            isStatic = true;\n            computed = match('[');\n            if (match('*')) {\n              lex();\n            } else {\n              key = parseObjectPropertyKey();\n            }\n          }\n        }\n        method = tryParseMethodDefinition(token, key, computed, method);\n        if (method) {\n          method['static'] = isStatic; // jscs:ignore requireDotNotation\n          if (method.kind === 'init') {\n            method.kind = 'method';\n          }\n          if (!isStatic) {\n            if (!method.computed && (method.key.name || method.key.value.toString()) === 'constructor') {\n              if (method.kind !== 'method' || !method.method || method.value.generator) {\n                throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);\n              }\n              if (hasConstructor) {\n                throwUnexpectedToken(token, Messages.DuplicateConstructor);\n              } else {\n                hasConstructor = true;\n              }\n              method.kind = 'constructor';\n            }\n          } else {\n            if (!method.computed && (method.key.name || method.key.value.toString()) === 'prototype') {\n              throwUnexpectedToken(token, Messages.StaticPrototype);\n            }\n          }\n          method.type = Syntax.MethodDefinition;\n          delete method.method;\n          delete method.shorthand;\n          body.push(method);\n        } else {\n          throwUnexpectedToken(lookahead);\n        }\n      }\n    }\n    lex();\n    return classBody.finishClassBody(body);\n  }\n  function parseClassDeclaration(identifierIsOptional) {\n    var id = null,\n      superClass = null,\n      classNode = new Node(),\n      classBody,\n      previousStrict = strict;\n    strict = true;\n    expectKeyword('class');\n    if (!identifierIsOptional || lookahead.type === Token.Identifier) {\n      id = parseVariableIdentifier();\n    }\n    if (matchKeyword('extends')) {\n      lex();\n      superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);\n    }\n    classBody = parseClassBody();\n    strict = previousStrict;\n    return classNode.finishClassDeclaration(id, superClass, classBody);\n  }\n  function parseClassExpression() {\n    var id = null,\n      superClass = null,\n      classNode = new Node(),\n      classBody,\n      previousStrict = strict;\n    strict = true;\n    expectKeyword('class');\n    if (lookahead.type === Token.Identifier) {\n      id = parseVariableIdentifier();\n    }\n    if (matchKeyword('extends')) {\n      lex();\n      superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);\n    }\n    classBody = parseClassBody();\n    strict = previousStrict;\n    return classNode.finishClassExpression(id, superClass, classBody);\n  }\n\n  // ECMA-262 15.2 Modules\n\n  function parseModuleSpecifier() {\n    var node = new Node();\n    if (lookahead.type !== Token.StringLiteral) {\n      throwError(Messages.InvalidModuleSpecifier);\n    }\n    return node.finishLiteral(lex());\n  }\n\n  // ECMA-262 15.2.3 Exports\n\n  function parseExportSpecifier() {\n    var exported,\n      local,\n      node = new Node(),\n      def;\n    if (matchKeyword('default')) {\n      // export {default} from 'something';\n      def = new Node();\n      lex();\n      local = def.finishIdentifier('default');\n    } else {\n      local = parseVariableIdentifier();\n    }\n    if (matchContextualKeyword('as')) {\n      lex();\n      exported = parseNonComputedProperty();\n    }\n    return node.finishExportSpecifier(local, exported);\n  }\n  function parseExportNamedDeclaration(node) {\n    var declaration = null,\n      isExportFromIdentifier,\n      src = null,\n      specifiers = [];\n\n    // non-default export\n    if (lookahead.type === Token.Keyword) {\n      // covers:\n      // export var f = 1;\n      switch (lookahead.value) {\n        case 'let':\n        case 'const':\n          declaration = parseLexicalDeclaration({\n            inFor: false\n          });\n          return node.finishExportNamedDeclaration(declaration, specifiers, null);\n        case 'var':\n        case 'class':\n        case 'function':\n          declaration = parseStatementListItem();\n          return node.finishExportNamedDeclaration(declaration, specifiers, null);\n      }\n    }\n    expect('{');\n    while (!match('}')) {\n      isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');\n      specifiers.push(parseExportSpecifier());\n      if (!match('}')) {\n        expect(',');\n        if (match('}')) {\n          break;\n        }\n      }\n    }\n    expect('}');\n    if (matchContextualKeyword('from')) {\n      // covering:\n      // export {default} from 'foo';\n      // export {foo} from 'foo';\n      lex();\n      src = parseModuleSpecifier();\n      consumeSemicolon();\n    } else if (isExportFromIdentifier) {\n      // covering:\n      // export {default}; // missing fromClause\n      throwError(lookahead.value ? Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n    } else {\n      // cover\n      // export {foo};\n      consumeSemicolon();\n    }\n    return node.finishExportNamedDeclaration(declaration, specifiers, src);\n  }\n  function parseExportDefaultDeclaration(node) {\n    var declaration = null,\n      expression = null;\n\n    // covers:\n    // export default ...\n    expectKeyword('default');\n    if (matchKeyword('function')) {\n      // covers:\n      // export default function foo () {}\n      // export default function () {}\n      declaration = parseFunctionDeclaration(new Node(), true);\n      return node.finishExportDefaultDeclaration(declaration);\n    }\n    if (matchKeyword('class')) {\n      declaration = parseClassDeclaration(true);\n      return node.finishExportDefaultDeclaration(declaration);\n    }\n    if (matchContextualKeyword('from')) {\n      throwError(Messages.UnexpectedToken, lookahead.value);\n    }\n\n    // covers:\n    // export default {};\n    // export default [];\n    // export default (1 + 2);\n    if (match('{')) {\n      expression = parseObjectInitializer();\n    } else if (match('[')) {\n      expression = parseArrayInitializer();\n    } else {\n      expression = parseAssignmentExpression();\n    }\n    consumeSemicolon();\n    return node.finishExportDefaultDeclaration(expression);\n  }\n  function parseExportAllDeclaration(node) {\n    var src;\n\n    // covers:\n    // export * from 'foo';\n    expect('*');\n    if (!matchContextualKeyword('from')) {\n      throwError(lookahead.value ? Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n    }\n    lex();\n    src = parseModuleSpecifier();\n    consumeSemicolon();\n    return node.finishExportAllDeclaration(src);\n  }\n  function parseExportDeclaration() {\n    var node = new Node();\n    if (state.inFunctionBody) {\n      throwError(Messages.IllegalExportDeclaration);\n    }\n    expectKeyword('export');\n    if (matchKeyword('default')) {\n      return parseExportDefaultDeclaration(node);\n    }\n    if (match('*')) {\n      return parseExportAllDeclaration(node);\n    }\n    return parseExportNamedDeclaration(node);\n  }\n\n  // ECMA-262 15.2.2 Imports\n\n  function parseImportSpecifier() {\n    // import {<foo as bar>} ...;\n    var local,\n      imported,\n      node = new Node();\n    imported = parseNonComputedProperty();\n    if (matchContextualKeyword('as')) {\n      lex();\n      local = parseVariableIdentifier();\n    }\n    return node.finishImportSpecifier(local, imported);\n  }\n  function parseNamedImports() {\n    var specifiers = [];\n    // {foo, bar as bas}\n    expect('{');\n    while (!match('}')) {\n      specifiers.push(parseImportSpecifier());\n      if (!match('}')) {\n        expect(',');\n        if (match('}')) {\n          break;\n        }\n      }\n    }\n    expect('}');\n    return specifiers;\n  }\n  function parseImportDefaultSpecifier() {\n    // import <foo> ...;\n    var local,\n      node = new Node();\n    local = parseNonComputedProperty();\n    return node.finishImportDefaultSpecifier(local);\n  }\n  function parseImportNamespaceSpecifier() {\n    // import <* as foo> ...;\n    var local,\n      node = new Node();\n    expect('*');\n    if (!matchContextualKeyword('as')) {\n      throwError(Messages.NoAsAfterImportNamespace);\n    }\n    lex();\n    local = parseNonComputedProperty();\n    return node.finishImportNamespaceSpecifier(local);\n  }\n  function parseImportDeclaration() {\n    var specifiers = [],\n      src,\n      node = new Node();\n    if (state.inFunctionBody) {\n      throwError(Messages.IllegalImportDeclaration);\n    }\n    expectKeyword('import');\n    if (lookahead.type === Token.StringLiteral) {\n      // import 'foo';\n      src = parseModuleSpecifier();\n    } else {\n      if (match('{')) {\n        // import {bar}\n        specifiers = specifiers.concat(parseNamedImports());\n      } else if (match('*')) {\n        // import * as foo\n        specifiers.push(parseImportNamespaceSpecifier());\n      } else if (isIdentifierName(lookahead) && !matchKeyword('default')) {\n        // import foo\n        specifiers.push(parseImportDefaultSpecifier());\n        if (match(',')) {\n          lex();\n          if (match('*')) {\n            // import foo, * as foo\n            specifiers.push(parseImportNamespaceSpecifier());\n          } else if (match('{')) {\n            // import foo, {bar}\n            specifiers = specifiers.concat(parseNamedImports());\n          } else {\n            throwUnexpectedToken(lookahead);\n          }\n        }\n      } else {\n        throwUnexpectedToken(lex());\n      }\n      if (!matchContextualKeyword('from')) {\n        throwError(lookahead.value ? Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n      }\n      lex();\n      src = parseModuleSpecifier();\n    }\n    consumeSemicolon();\n    return node.finishImportDeclaration(specifiers, src);\n  }\n\n  // ECMA-262 15.1 Scripts\n\n  function parseScriptBody() {\n    var statement,\n      body = [],\n      token,\n      directive,\n      firstRestricted;\n    while (startIndex < length) {\n      token = lookahead;\n      if (token.type !== Token.StringLiteral) {\n        break;\n      }\n      statement = parseStatementListItem();\n      body.push(statement);\n      if (statement.expression.type !== Syntax.Literal) {\n        // this is not directive\n        break;\n      }\n      directive = source.slice(token.start + 1, token.end - 1);\n      if (directive === 'use strict') {\n        strict = true;\n        if (firstRestricted) {\n          tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);\n        }\n      } else {\n        if (!firstRestricted && token.octal) {\n          firstRestricted = token;\n        }\n      }\n    }\n    while (startIndex < length) {\n      statement = parseStatementListItem();\n      /* istanbul ignore if */\n      if (typeof statement === 'undefined') {\n        break;\n      }\n      body.push(statement);\n    }\n    return body;\n  }\n  function parseProgram() {\n    var body, node;\n    peek();\n    node = new Node();\n    body = parseScriptBody();\n    return node.finishProgram(body, state.sourceType);\n  }\n  function filterTokenLocation() {\n    var i,\n      entry,\n      token,\n      tokens = [];\n    for (i = 0; i < extra.tokens.length; ++i) {\n      entry = extra.tokens[i];\n      token = {\n        type: entry.type,\n        value: entry.value\n      };\n      if (entry.regex) {\n        token.regex = {\n          pattern: entry.regex.pattern,\n          flags: entry.regex.flags\n        };\n      }\n      if (extra.range) {\n        token.range = entry.range;\n      }\n      if (extra.loc) {\n        token.loc = entry.loc;\n      }\n      tokens.push(token);\n    }\n    extra.tokens = tokens;\n  }\n  function tokenize(code, options, delegate) {\n    var toString, tokens;\n    toString = String;\n    if (typeof code !== 'string' && !(code instanceof String)) {\n      code = toString(code);\n    }\n    source = code;\n    index = 0;\n    lineNumber = source.length > 0 ? 1 : 0;\n    lineStart = 0;\n    startIndex = index;\n    startLineNumber = lineNumber;\n    startLineStart = lineStart;\n    length = source.length;\n    lookahead = null;\n    state = {\n      allowIn: true,\n      allowYield: true,\n      labelSet: {},\n      inFunctionBody: false,\n      inIteration: false,\n      inSwitch: false,\n      lastCommentStart: -1,\n      curlyStack: []\n    };\n    extra = {};\n\n    // Options matching.\n    options = options || {};\n\n    // Of course we collect tokens here.\n    options.tokens = true;\n    extra.tokens = [];\n    extra.tokenValues = [];\n    extra.tokenize = true;\n    extra.delegate = delegate;\n\n    // The following two fields are necessary to compute the Regex tokens.\n    extra.openParenToken = -1;\n    extra.openCurlyToken = -1;\n    extra.range = typeof options.range === 'boolean' && options.range;\n    extra.loc = typeof options.loc === 'boolean' && options.loc;\n    if (typeof options.comment === 'boolean' && options.comment) {\n      extra.comments = [];\n    }\n    if (typeof options.tolerant === 'boolean' && options.tolerant) {\n      extra.errors = [];\n    }\n    try {\n      peek();\n      if (lookahead.type === Token.EOF) {\n        return extra.tokens;\n      }\n      lex();\n      while (lookahead.type !== Token.EOF) {\n        try {\n          lex();\n        } catch (lexError) {\n          if (extra.errors) {\n            recordError(lexError);\n            // We have to break on the first error\n            // to avoid infinite loops.\n            break;\n          } else {\n            throw lexError;\n          }\n        }\n      }\n      tokens = extra.tokens;\n      if (typeof extra.errors !== 'undefined') {\n        tokens.errors = extra.errors;\n      }\n    } catch (e) {\n      throw e;\n    } finally {\n      extra = {};\n    }\n    return tokens;\n  }\n  function parse(code, options) {\n    var program, toString;\n    toString = String;\n    if (typeof code !== 'string' && !(code instanceof String)) {\n      code = toString(code);\n    }\n    source = code;\n    index = 0;\n    lineNumber = source.length > 0 ? 1 : 0;\n    lineStart = 0;\n    startIndex = index;\n    startLineNumber = lineNumber;\n    startLineStart = lineStart;\n    length = source.length;\n    lookahead = null;\n    state = {\n      allowIn: true,\n      allowYield: true,\n      labelSet: {},\n      inFunctionBody: false,\n      inIteration: false,\n      inSwitch: false,\n      lastCommentStart: -1,\n      curlyStack: [],\n      sourceType: 'script'\n    };\n    strict = false;\n    extra = {};\n    if (typeof options !== 'undefined') {\n      extra.range = typeof options.range === 'boolean' && options.range;\n      extra.loc = typeof options.loc === 'boolean' && options.loc;\n      extra.attachComment = typeof options.attachComment === 'boolean' && options.attachComment;\n      if (extra.loc && options.source !== null && options.source !== undefined) {\n        extra.source = toString(options.source);\n      }\n      if (typeof options.tokens === 'boolean' && options.tokens) {\n        extra.tokens = [];\n      }\n      if (typeof options.comment === 'boolean' && options.comment) {\n        extra.comments = [];\n      }\n      if (typeof options.tolerant === 'boolean' && options.tolerant) {\n        extra.errors = [];\n      }\n      if (extra.attachComment) {\n        extra.range = true;\n        extra.comments = [];\n        extra.bottomRightStack = [];\n        extra.trailingComments = [];\n        extra.leadingComments = [];\n      }\n      if (options.sourceType === 'module') {\n        // very restrictive condition for now\n        state.sourceType = options.sourceType;\n        strict = true;\n      }\n    }\n    try {\n      program = parseProgram();\n      if (typeof extra.comments !== 'undefined') {\n        program.comments = extra.comments;\n      }\n      if (typeof extra.tokens !== 'undefined') {\n        filterTokenLocation();\n        program.tokens = extra.tokens;\n      }\n      if (typeof extra.errors !== 'undefined') {\n        program.errors = extra.errors;\n      }\n    } catch (e) {\n      throw e;\n    } finally {\n      extra = {};\n    }\n    return program;\n  }\n\n  // Sync with *.json manifests.\n  exports.version = '2.7.3';\n  exports.tokenize = tokenize;\n  exports.parse = parse;\n\n  // Deep copy.\n  /* istanbul ignore next */\n  exports.Syntax = function () {\n    var name,\n      types = {};\n    if (typeof Object.create === 'function') {\n      types = Object.create(null);\n    }\n    for (name in Syntax) {\n      if (Syntax.hasOwnProperty(name)) {\n        types[name] = Syntax[name];\n      }\n    }\n    if (typeof Object.freeze === 'function') {\n      Object.freeze(types);\n    }\n    return types;\n  }();\n});\n/* vim: set sw=4 ts=4 et tw=80 : */"],"sourceRoot":""}